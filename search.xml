<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>快速入门脚手架(Node.js CLI)开发</title>
      <link href="/posts/20240504211910/"/>
      <url>/posts/20240504211910/</url>
      
        <content type="html"><![CDATA[<p>开发一个 Node.js CLI 脚手架，是创建高效开发工具的重要一步。本文将从基础概念入手，逐步深入开发过程，并以最小依赖实现第一个 CLI 工具。</p><h2 id="一、基础概念与预备知识"><a href="#一、基础概念与预备知识" class="headerlink" title="一、基础概念与预备知识"></a>一、基础概念与预备知识</h2><h3 id="1-什么是-Shell-和-Bash？"><a href="#1-什么是-Shell-和-Bash？" class="headerlink" title="1. 什么是 Shell 和 Bash？"></a>1. 什么是 Shell 和 Bash？</h3><ul><li>Shell：操作系统的命令解释器，允许用户与系统进行交互。常见的 Shell 包括 Bash、zsh、fish 等。</li><li>Bash (Bourne Again Shell)：是 Linux 和 macOS 默认的 Shell，提供了丰富的命令和脚本支持。</li><li>Shell 脚本允许自动化任务，许多 CLI 工具的核心逻辑往往需要与 Shell 交互。</li></ul><h3 id="2-什么是-CLI-与-GUI？"><a href="#2-什么是-CLI-与-GUI？" class="headerlink" title="2. 什么是 CLI 与 GUI？"></a>2. 什么是 CLI 与 GUI？</h3><ul><li>CLI（Command Line Interface，命令行接口）：用户通过命令输入与程序交互，如 git 或 npm。</li><li>GUI（Graphical User Interface，图形用户界面）：用户通过窗口和按钮与系统交互，如 VSCode。</li></ul><p>CLI 工具的优势在于：</p><ul><li>自动化程度高、支持脚本化操作。</li><li>高效处理批量任务，开发时可远程执行。</li></ul><h2 id="二、脚手架开发的预备知识"><a href="#二、脚手架开发的预备知识" class="headerlink" title="二、脚手架开发的预备知识"></a>二、脚手架开发的预备知识</h2><h3 id="1-了解-Node-js-的能力"><a href="#1-了解-Node-js-的能力" class="headerlink" title="1. 了解 Node.js 的能力"></a>1. 了解 Node.js 的能力</h3><ul><li>Node.js 提供内置模块（如 fs、child_process 等），适合开发 CLI。</li><li>Node.js 支持同步与异步 API，CLI 通常选择同步执行关键任务，确保顺序执行。</li></ul><h3 id="2-package-json-的-bin-字段"><a href="#2-package-json-的-bin-字段" class="headerlink" title="2. package.json 的 bin 字段"></a>2. package.json 的 bin 字段</h3><p>在 package.json 中配置 bin 字段，让你的脚手架可以全局执行。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;bin&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;my-cli&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./index.js&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="三、开发第一个脚手架"><a href="#三、开发第一个脚手架" class="headerlink" title="三、开发第一个脚手架"></a>三、开发第一个脚手架</h2><h3 id="1-初始化项目"><a href="#1-初始化项目" class="headerlink" title="1. 初始化项目"></a>1. 初始化项目</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> my-cli &amp;&amp; <span class="built_in">cd</span> my-cli</span><br><span class="line">npm init -y</span><br><span class="line"><span class="built_in">touch</span> index.js</span><br></pre></td></tr></table></figure><h3 id="2-在-index-js-中实现基础-CLI"><a href="#2-在-index-js-中实现基础-CLI" class="headerlink" title="2. 在 index.js 中实现基础 CLI"></a>2. 在 index.js 中实现基础 CLI</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env node</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [,, command, ...args] = process.<span class="property">argv</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (command) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;greet&#x27;</span>:</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;args[<span class="number">0</span>] || <span class="string">&#x27;World&#x27;</span>&#125;</span>!`</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="attr">default</span>:</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Usage: my-cli greet &lt;name&gt;&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>解释</strong> <code>const [,, command, ...args] = process.argv;</code></p><p>这行代码利用了 <strong>解构赋值</strong>，用于从 process.argv 中提取命令和参数。我们逐步解析这一部分代码，并解释为什么 command 前面有两个逗号。</p><p>process.argv 是一个数组，包含运行 Node.js 脚本时传入的所有命令行参数。其中：</p><ul><li>第 0 个元素：Node.js 可执行文件的路径（如 /usr/local/bin/node）。</li><li>第 1 个元素：正在执行的脚本路径（如 /Users/alice/my-cli/index.js）。</li><li>第 2 个元素及之后：用户传入的命令和参数。</li></ul><p>示例：</p><p>如果用户运行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node index.js greet Alice</span><br></pre></td></tr></table></figure><p>那么 process.argv 的值将是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  <span class="string">&#x27;/usr/local/bin/node&#x27;</span>,          <span class="comment">// 第 0 个元素</span></span><br><span class="line">  <span class="string">&#x27;/Users/alice/my-cli/index.js&#x27;</span>, <span class="comment">// 第 1 个元素</span></span><br><span class="line">  <span class="string">&#x27;greet&#x27;</span>,                        <span class="comment">// 第 2 个元素（命令）</span></span><br><span class="line">  <span class="string">&#x27;Alice&#x27;</span>                         <span class="comment">// 第 3 个元素（参数）</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>在 Node.js 中运行脚本时，第 0 个和第 1 个元素分别是 Node.js 可执行文件和脚本的路径。</p><p>对于命令行工具，我们通常不需要这两个路径，因此直接跳过。</p></blockquote><h3 id="3-本地测试"><a href="#3-本地测试" class="headerlink" title="3. 本地测试"></a>3. 本地测试</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./index.js greet Alice</span><br></pre></td></tr></table></figure><h3 id="4-配置全局运行"><a href="#4-配置全局运行" class="headerlink" title="4. 配置全局运行"></a>4. 配置全局运行</h3><p>在 package.json 中添加 bin 字段：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;bin&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;my-cli&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./index.js&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>使用 npm link 进行本地测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="built_in">link</span></span><br><span class="line">my-cli greet Bob</span><br></pre></td></tr></table></figure><h2 id="四、核心原生实现"><a href="#四、核心原生实现" class="headerlink" title="四、核心原生实现"></a>四、核心原生实现</h2><h3 id="1-读取用户输入（process-argv）"><a href="#1-读取用户输入（process-argv）" class="headerlink" title="1. 读取用户输入（process.argv）"></a>1. 读取用户输入（process.argv）</h3><p>Node.js 的 process.argv 提供命令行参数的访问能力：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> args = process.<span class="property">argv</span>.<span class="title function_">slice</span>(<span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Arguments: <span class="subst">$&#123;args.join(<span class="string">&#x27; &#x27;</span>)&#125;</span>`</span>);</span><br></pre></td></tr></table></figure><h3 id="2-文件系统操作（fs-模块）"><a href="#2-文件系统操作（fs-模块）" class="headerlink" title="2. 文件系统操作（fs 模块）"></a>2. 文件系统操作（fs 模块）</h3><p>创建和写入文件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">writeFileSync</span>(<span class="string">&#x27;hello.txt&#x27;</span>, <span class="string">&#x27;Hello, Node.js CLI!&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;File created: hello.txt&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="3-执行系统命令（child-process-模块）"><a href="#3-执行系统命令（child-process-模块）" class="headerlink" title="3. 执行系统命令（child_process 模块）"></a>3. 执行系统命令（child_process 模块）</h3><p>通过 Shell 执行命令：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; execSync &#125; = <span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = <span class="title function_">execSync</span>(<span class="string">&#x27;ls&#x27;</span>).<span class="title function_">toString</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br></pre></td></tr></table></figure><h3 id="4-处理用户交互（readline-模块）"><a href="#4-处理用户交互（readline-模块）" class="headerlink" title="4. 处理用户交互（readline 模块）"></a>4. 处理用户交互（readline 模块）</h3><p>简单实现用户输入：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> readline = <span class="built_in">require</span>(<span class="string">&#x27;readline&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rl = readline.<span class="title function_">createInterface</span>(&#123;</span><br><span class="line">  <span class="attr">input</span>: process.<span class="property">stdin</span>,</span><br><span class="line">  <span class="attr">output</span>: process.<span class="property">stdout</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">rl.<span class="title function_">question</span>(<span class="string">&#x27;What is your name? &#x27;</span>, <span class="function">(<span class="params">answer</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;answer&#125;</span>!`</span>);</span><br><span class="line">  rl.<span class="title function_">close</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="五、第三方库与框架介绍"><a href="#五、第三方库与框架介绍" class="headerlink" title="五、第三方库与框架介绍"></a>五、第三方库与框架介绍</h2><h3 id="1-commander：简化命令和参数处理。"><a href="#1-commander：简化命令和参数处理。" class="headerlink" title="1. commander：简化命令和参数处理。"></a>1. commander：简化命令和参数处理。</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install commander</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">Command</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;commander&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> program = <span class="keyword">new</span> <span class="title class_">Command</span>();</span><br><span class="line"></span><br><span class="line">program</span><br><span class="line">  .<span class="title function_">version</span>(<span class="string">&#x27;1.0.0&#x27;</span>)</span><br><span class="line">  .<span class="title function_">command</span>(<span class="string">&#x27;greet &lt;name&gt;&#x27;</span>)</span><br><span class="line">  .<span class="title function_">description</span>(<span class="string">&#x27;Say hello to someone&#x27;</span>)</span><br><span class="line">  .<span class="title function_">action</span>(<span class="function">(<span class="params">name</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;name&#125;</span>!`</span>));</span><br><span class="line"></span><br><span class="line">program.<span class="title function_">parse</span>(process.<span class="property">argv</span>);</span><br></pre></td></tr></table></figure><h3 id="2-inquirer：增强用户交互体验。"><a href="#2-inquirer：增强用户交互体验。" class="headerlink" title="2. inquirer：增强用户交互体验。"></a>2. inquirer：增强用户交互体验。</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install inquirer</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> inquirer = <span class="built_in">require</span>(<span class="string">&#x27;inquirer&#x27;</span>);</span><br><span class="line"></span><br><span class="line">inquirer.<span class="title function_">prompt</span>([</span><br><span class="line">  &#123; <span class="attr">type</span>: <span class="string">&#x27;input&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;username&#x27;</span>, <span class="attr">message</span>: <span class="string">&#x27;What is your name?&#x27;</span> &#125;</span><br><span class="line">]).<span class="title function_">then</span>(<span class="function"><span class="params">answers</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;answers.username&#125;</span>!`</span>));</span><br></pre></td></tr></table></figure><h3 id="3-chalk：为终端输出添加颜色。"><a href="#3-chalk：为终端输出添加颜色。" class="headerlink" title="3. chalk：为终端输出添加颜色。"></a>3. chalk：为终端输出添加颜色。</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install chalk</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> chalk = <span class="built_in">require</span>(<span class="string">&#x27;chalk&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(chalk.<span class="title function_">green</span>(<span class="string">&#x27;Success!&#x27;</span>));</span><br></pre></td></tr></table></figure><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>开发 CLI 脚手架并不复杂，只需掌握 Node.js 基础模块即可实现很多功能。在此基础上，你可以根据项目需求引入第三方库来增强用户体验。以下是脚手架开发的流程回顾：</p><ol><li>基础概念：理解 Shell、Bash、CLI 与 GUI 的区别。</li><li>项目初始化：配置 package.json 的 bin 字段。</li><li>核心实现：使用 process.argv、fs、child_process 等原生模块。</li><li>扩展功能：根据需要引入第三方库（如 commander 和 inquirer）。</li></ol><p>最后，分享一个自己开发的 Node.js CLI 工具：</p><p><a href="https://www.npmjs.com/package/douban-scanner">douban-scanner</a> —— 豆瓣扫描器，一个用来抓取豆瓣 “书影音” 数据的 CLI 工具</p>]]></content>
      
      
      <categories>
          
          <category> 未分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无标签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从 Dark 看编程语言空安全特性</title>
      <link href="/posts/20231109193941/"/>
      <url>/posts/20231109193941/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前段时间想做一个小工具 APP，考虑想用 Flutter 实现，于是去看了看 Dart 语言，发现一个比较有意思的特性 —— “空安全”，这里和大家聊一聊。</p></blockquote><h2 id="什么是空安全"><a href="#什么是空安全" class="headerlink" title="什么是空安全"></a>什么是空安全</h2><p>空安全是指编程语言的类型系统能够区分可为空的类型和不能为空的类型，这种区别可以防止空引用错误（Null Reference Errors）。</p><h2 id="Dart-的空安全"><a href="#Dart-的空安全" class="headerlink" title="Dart 的空安全"></a>Dart 的空安全</h2><p>Dart 在 2.12 版本引入了空安全。</p><h3 id="可空和非空类型"><a href="#可空和非空类型" class="headerlink" title="可空和非空类型"></a><strong><strong>可空和非空类型</strong></strong></h3><p>在 Dart 中，所有类型默认都是非空的。例如，如果你声明一个 <code>String</code> 类型的变量，Dart 会假设它永远不会为空：</p><p><img src="/posts/20231109193941/%E6%B0%B8%E8%BF%9C%E4%B8%8D%E4%BC%9A%E4%B8%BA%E7%A9%BA.png" class="lazyload" data-srcset="/posts/20231109193941/%E6%B0%B8%E8%BF%9C%E4%B8%8D%E4%BC%9A%E4%B8%BA%E7%A9%BA.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="永远不会为空"></p><p>且不能将它赋予 <code>null</code> 值：</p><p><img src="/posts/20231109193941/%E4%B8%8D%E8%83%BD%E8%B5%8B%E4%BA%88null.png" class="lazyload" data-srcset="/posts/20231109193941/%E4%B8%8D%E8%83%BD%E8%B5%8B%E4%BA%88null.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="不能赋予null"></p><p>如果你想声明一个可以为空的 <code>String</code>，你需要在类型后面加上 <code>?</code>：</p><p><img src="/posts/20231109193941/%E5%A3%B0%E6%98%8E%E5%8F%AF%E4%B8%BA%E7%A9%BA%E7%9A%84String.png" class="lazyload" data-srcset="/posts/20231109193941/%E5%A3%B0%E6%98%8E%E5%8F%AF%E4%B8%BA%E7%A9%BA%E7%9A%84String.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="声明可为空的String"></p><h3 id="处理可空值"><a href="#处理可空值" class="headerlink" title="处理可空值"></a><strong><strong>处理可空值</strong></strong></h3><p>与 JS 类似，Dart 也提供了几种方式来处理可能为空的值。</p><p>例如，可以使用 <code>??</code> 操作符来提供一个默认值：</p><p><img src="/posts/20231109193941/%E6%8F%90%E4%BE%9B%E4%B8%80%E4%B8%AA%E9%BB%98%E8%AE%A4%E5%80%BC.png" class="lazyload" data-srcset="/posts/20231109193941/%E6%8F%90%E4%BE%9B%E4%B8%80%E4%B8%AA%E9%BB%98%E8%AE%A4%E5%80%BC.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="提供一个默认值"></p><p>可以使用 <code>?.</code> 操作符，在对象为空时，跳过方法调用或属性访问，避免抛出空引用错误：</p><p><img src="/posts/20231109193941/%E6%8A%9B%E5%87%BA%E7%A9%BA%E5%BC%95%E7%94%A8%E9%94%99%E8%AF%AF.png" class="lazyload" data-srcset="/posts/20231109193941/%E6%8A%9B%E5%87%BA%E7%A9%BA%E5%BC%95%E7%94%A8%E9%94%99%E8%AF%AF.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="抛出空引用错误"></p><p>针对上面这种情况，如果编译器解析出你去访问一个可能为空的对象的属性或方法时，没有使用 <code>?.</code> 操作符，这会在编译时就会报错，避免了运行时才暴露问题：</p><p><img src="/posts/20231109193941/%E9%81%BF%E5%85%8D%E4%BA%86%E8%BF%90%E8%A1%8C%E6%97%B6%E6%89%8D%E6%9A%B4%E9%9C%B2%E9%94%99%E8%AF%AF.png" class="lazyload" data-srcset="/posts/20231109193941/%E9%81%BF%E5%85%8D%E4%BA%86%E8%BF%90%E8%A1%8C%E6%97%B6%E6%89%8D%E6%9A%B4%E9%9C%B2%E9%94%99%E8%AF%AF.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="避免了运行时才暴露错误"></p><h3 id="空值断言操作符-的使用"><a href="#空值断言操作符-的使用" class="headerlink" title="空值断言操作符 ! 的使用"></a>空值断言操作符 <code>!</code> 的使用</h3><p>当我们排除变量或参数的可空的可能后，可以通过 <code>!</code> 来告诉编译器这个可空的变量或者参数不可空，这对我们进行方法传参或将可空的参数传递给一个不可空的入参时特别有用。</p><p>引用 Dart 文档中的一个例子⬇️：（From：<a href="https://dart.cn/null-safety/understanding-null-safety#null-assertion-operator">Dart｜ 空值断言操作符</a>）</p><p><img src="/posts/20231109193941/Dart%E6%96%87%E6%A1%A3%E4%B8%AD%E7%9A%84%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90.png" class="lazyload" data-srcset="/posts/20231109193941/Dart%E6%96%87%E6%A1%A3%E4%B8%AD%E7%9A%84%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="Dart文档中的一个例子"></p><p>由于 <code>error</code> 属性是可空的，在返回结果成功时，它不会有值。我们通过仔细观察类可以看出，当消息为空时，我们永远不会访问 <code>error</code>。但为了知晓这个行为，必须要理解 <code>code</code> 的值与 <code>error</code> 的可空性之间的联系。类型检查器看不出这种联系。</p><p>换句话说，作为代码的人类维护者，我们知道在使用 <code>error</code> 时，它的值不会是 <code>null</code>，并且我们需要对其进行断言。通常你可以通过使用 <code>as</code> 转换来断言类型，这里你也可以这样做：</p><p><img src="/posts/20231109193941/%E9%80%9A%E8%BF%87as%E8%BD%AC%E6%8D%A2%E6%9D%A5%E6%96%AD%E8%A8%80%E7%B1%BB%E5%9E%8B.png" class="lazyload" data-srcset="/posts/20231109193941/%E9%80%9A%E8%BF%87as%E8%BD%AC%E6%8D%A2%E6%9D%A5%E6%96%AD%E8%A8%80%E7%B1%BB%E5%9E%8B.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="通过as转换来断言类型"></p><p>编译时的报错消失了！⬆️</p><p>如果在运行时，将 <code>error</code> 转换为非空的 <code>String</code> 类型出现了无法转换的错误，会抛出一个异常。若转换成功，一个非空的字符串就会回到我们的手上，让我们可以进行方法调用。</p><p>“排除可空性的转换”的场景频繁出现，这促使了 Dart 带来了新的短小精悍的语法。一个作为后缀的感叹号标记 (<code>!</code>) 会让左侧的表达式转换成其对应的非空类型。所以上面的函数等效于：</p><p><img src="/posts/20231109193941/%E9%9D%9E%E7%A9%BA%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.png" class="lazyload" data-srcset="/posts/20231109193941/%E9%9D%9E%E7%A9%BA%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="非空类型转换"></p><p>当原有的类型非常繁琐的时候，这个只有一个字符的 “<code>!</code> 操作符” 就会非常顺手。如果仅仅是为了将一个类型转换为非空，就需要写出类似于 <code>as Map&lt;TransactionProviderFactory, List&lt;Set&lt;ResponseFilter&gt;&gt;&gt;</code> 这样的代码，会让这个过程变得非常烦人。</p><h2 id="TypeScript-开启严格空值检查"><a href="#TypeScript-开启严格空值检查" class="headerlink" title="TypeScript 开启严格空值检查"></a>TypeScript 开启严格空值检查</h2><blockquote><p>目前很多主流编程语言都对空安全有自己的支持，比如：Kotlink、Swift、Rust，包括我们熟悉的 TypeScript，其实也可以手动开启严格空值检查。</p></blockquote><p>TypeScript 里，JS 中的基本数据类型 <code>undefined</code> 和 <code>null</code> 两者各自有自己的类型分别叫做 <code>undefined</code> 和 <code>null</code>。</p><p>默认情况下 <code>null</code> 和 <code>undefined</code> 是所有类型的子类型。 就是说你可以把 <code>null</code> 和 <code>undefined</code> 赋值给 <code>number</code> 类型的变量。</p><p>例如下面的代码，在 TS 中是完全可以执行的：</p><p><img src="/posts/20231109193941/TS%E4%B8%AD%E6%94%AF%E6%8C%81%E6%83%85%E5%86%B5.png" class="lazyload" data-srcset="/posts/20231109193941/TS%E4%B8%AD%E6%94%AF%E6%8C%81%E6%83%85%E5%86%B5.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="TS中支持情况"></p><h3 id="strictNullChecks"><a href="#strictNullChecks" class="headerlink" title="strictNullChecks"></a><strong><strong>strictNullChecks</strong></strong></h3><p>TypeScript 2.0 增加了对 <strong>不可为空类型</strong> 的支持。有一种新的 <strong>严格空值检查</strong> 模式，他提供了 <strong><code>strictNullChecks</code></strong> 来限制对空值的检查，可以通过在命令行上添加 <code>--strictNullChecks</code> 参数来启功严格空值检查，也可以在项目的 <code>tsconfig.json</code> **文件中启用 <code>strictNullChecks</code> 编译器选项。</p><p>在TS中，为了各版本的兼容，<code>strictNullChecks</code> 的默认值是 <code>false</code>，我们需要手动设置为 <code>true</code>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;strictNullChecks&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>此时，我们刚刚的代码，就无法通过编译器检查了：</p><p><img src="/posts/20231109193941/%E6%97%A0%E6%B3%95%E9%80%9A%E8%BF%87%E7%BC%96%E8%AF%91%E5%99%A8%E6%A3%80%E6%9F%A5.png" class="lazyload" data-srcset="/posts/20231109193941/%E6%97%A0%E6%B3%95%E9%80%9A%E8%BF%87%E7%BC%96%E8%AF%91%E5%99%A8%E6%A3%80%E6%9F%A5.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="无法通过编译器检查"></p><h3 id="变量如何可以为空"><a href="#变量如何可以为空" class="headerlink" title="变量如何可以为空"></a>变量如何可以为空</h3><p>开启严格空值检查后，如果我们想要一个变量可以接受空值，我们该怎么办呢？</p><ol><li>使用联合类型 比如下面的代码，<code>username</code> 可以接受 <code>null</code> 类型的值，但是无法接受 <code>undefined</code> 的值：</li></ol><p><img src="/posts/20231109193941/%E5%8F%AF%E4%BB%A5%E6%8E%A5%E5%8F%97null%E4%BD%86%E6%98%AF%E6%97%A0%E6%B3%95%E6%8E%A5%E5%8F%97undefined.png" class="lazyload" data-srcset="/posts/20231109193941/%E5%8F%AF%E4%BB%A5%E6%8E%A5%E5%8F%97null%E4%BD%86%E6%98%AF%E6%97%A0%E6%B3%95%E6%8E%A5%E5%8F%97undefined.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="可以接受null但是无法接受undefined"></p><ol><li>在 Object 中使用 <code>?</code> 可选属性 首先，联合类型可以在 Object 中使用： <img src="/posts/20231109193941/%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B%E5%8F%AF%E4%BB%A5%E5%9C%A8Object%E4%B8%AD%E4%BD%BF%E7%94%A8.png" class="lazyload" data-srcset="/posts/20231109193941/%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B%E5%8F%AF%E4%BB%A5%E5%9C%A8Object%E4%B8%AD%E4%BD%BF%E7%94%A8.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="联合类型可以在Object中使用"> 这里我们设置 <code>age</code> 的类型为 <code>number</code> 和 <code>undefined</code>，下面的两种用法都是正确的： <img src="/posts/20231109193941/%E4%B8%A4%E7%A7%8D%E7%94%A8%E6%B3%95%E9%83%BD%E6%98%AF%E6%AD%A3%E7%A1%AE%E7%9A%84.png" class="lazyload" data-srcset="/posts/20231109193941/%E4%B8%A4%E7%A7%8D%E7%94%A8%E6%B3%95%E9%83%BD%E6%98%AF%E6%AD%A3%E7%A1%AE%E7%9A%84.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="两种用法都是正确的"> 如果我们想要下面的效果，不需要手动给 <code>age</code> 赋值： <img src="/posts/20231109193941/%E4%B8%8D%E9%9C%80%E8%A6%81%E6%89%8B%E5%8A%A8%E7%BB%99age%E8%B5%8B%E5%80%BC.png" class="lazyload" data-srcset="/posts/20231109193941/%E4%B8%8D%E9%9C%80%E8%A6%81%E6%89%8B%E5%8A%A8%E7%BB%99age%E8%B5%8B%E5%80%BC.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="不需要手动给age赋值"> 此时我们就需要用到 <code>?</code> 来使属性成为可选，这样我们就可以完全省略 <code>age</code> 属性的定义。 <img src="/posts/20231109193941/%E7%9C%81%E7%95%A5age%E5%B1%9E%E6%80%A7%E7%9A%84%E5%AE%9A%E4%B9%89.png" class="lazyload" data-srcset="/posts/20231109193941/%E7%9C%81%E7%95%A5age%E5%B1%9E%E6%80%A7%E7%9A%84%E5%AE%9A%E4%B9%89.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="省略age属性的定义"> 在这种情况下：<code>undefined</code> 类型会自动添加到联合类型中。因此，以下所有赋值都是正确的： <img src="/posts/20231109193941/%E4%BB%A5%E4%B8%8B%E6%89%80%E6%9C%89%E8%B5%8B%E5%80%BC%E9%83%BD%E6%98%AF%E6%AD%A3%E7%A1%AE%E7%9A%84.png" class="lazyload" data-srcset="/posts/20231109193941/%E4%BB%A5%E4%B8%8B%E6%89%80%E6%9C%89%E8%B5%8B%E5%80%BC%E9%83%BD%E6%98%AF%E6%AD%A3%E7%A1%AE%E7%9A%84.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="以下所有赋值都是正确的"></li></ol><h2 id="引入空安全的好处"><a href="#引入空安全的好处" class="headerlink" title="引入空安全的好处"></a>引入空安全的好处</h2><ul><li>可以将原本运行时的空值引用错误，变为编译时的分析错误</li><li>增强程序的健壮性，有效避免由Null而导致的崩溃</li><li>由于空安全特性的存在，编译层面可以做很多优化</li></ul>]]></content>
      
      
      <categories>
          
          <category> 未分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无标签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>客户端与服务器即时通信的几种实现方式</title>
      <link href="/posts/20231019221911/"/>
      <url>/posts/20231019221911/</url>
      
        <content type="html"><![CDATA[<h2 id="1-轮询（Polling）——-简单直接的老方法"><a href="#1-轮询（Polling）——-简单直接的老方法" class="headerlink" title="1. 轮询（Polling）—— 简单直接的老方法"></a>1. 轮询（Polling）—— 简单直接的老方法</h2><p>轮询是一种最基础的通信方式，客户端定期向服务器发送 HTTP 请求，询问是否有新数据。</p><h3 id="实现示例"><a href="#实现示例" class="headerlink" title="实现示例"></a><strong>实现示例</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每隔5秒轮询一次服务器是否有新消息</span></span><br><span class="line"><span class="built_in">setInterval</span>(<span class="title function_">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;/api/messages&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> response.<span class="title function_">json</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;新消息:&#x27;</span>, data);</span><br><span class="line">&#125;, <span class="number">5000</span>);</span><br></pre></td></tr></table></figure><h3 id="优缺点分析"><a href="#优缺点分析" class="headerlink" title="优缺点分析"></a><strong>优缺点分析</strong></h3><ul><li>优点：简单易用，所有浏览器都支持。</li><li>缺点：响应不及时，浪费带宽，服务器压力大。</li></ul><p><strong>适用场景</strong>：对实时性要求不高的项目，如低频更新的系统状态检查。</p><h2 id="2-长轮询（Long-Polling）——-聊天系统的好搭档"><a href="#2-长轮询（Long-Polling）——-聊天系统的好搭档" class="headerlink" title="2. 长轮询（Long Polling）—— 聊天系统的好搭档"></a>2. 长轮询（Long Polling）—— 聊天系统的好搭档</h2><p>长轮询是轮询的升级版：客户端发起请求后，如果服务器暂时没有数据，不会立即返回响应，而是等到有新数据时才返回。</p><h3 id="实现示例-1"><a href="#实现示例-1" class="headerlink" title="实现示例"></a><strong>实现示例</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 长轮询请求示例</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">longPoll</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;/api/messages&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> data = <span class="keyword">await</span> response.<span class="title function_">json</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;收到消息:&#x27;</span>, data);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;连接错误:&#x27;</span>, error);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 收到消息或连接断开后，立即发起下一次请求</span></span><br><span class="line">    <span class="title function_">longPoll</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">longPoll</span>();</span><br></pre></td></tr></table></figure><h3 id="优缺点分析-1"><a href="#优缺点分析-1" class="headerlink" title="优缺点分析"></a><strong>优缺点分析</strong></h3><ul><li>优点：比传统轮询更高效，减少了不必要的请求。</li><li>缺点：服务器需要长时间维护连接，对资源占用较高。</li></ul><p><strong>适用场景</strong>：适用于需要准实时响应的聊天系统或通知系统。</p><h2 id="3-WebSocket-——-全双工通信的利器"><a href="#3-WebSocket-——-全双工通信的利器" class="headerlink" title="3. WebSocket —— 全双工通信的利器"></a>3. WebSocket —— 全双工通信的利器</h2><p>WebSocket 是一种基于 TCP 的全双工通信协议，允许客户端和服务器之间建立持久连接，双方可以互相主动发送数据。</p><h3 id="实现示例-2"><a href="#实现示例-2" class="headerlink" title="实现示例"></a><strong>实现示例</strong></h3><p>客户端代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> socket = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&#x27;wss://example.com/socket&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听服务器消息</span></span><br><span class="line">socket.<span class="property">onmessage</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;收到消息:&#x27;</span>, event.<span class="property">data</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送消息给服务器</span></span><br><span class="line">socket.<span class="property">onopen</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  socket.<span class="title function_">send</span>(<span class="string">&#x27;Hello, Server!&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理错误</span></span><br><span class="line">socket.<span class="property">onerror</span> = <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;WebSocket 错误:&#x27;</span>, error);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="优缺点分析-2"><a href="#优缺点分析-2" class="headerlink" title="优缺点分析"></a><strong>优缺点分析</strong></h3><ul><li>优点：双向通信，实时性极高，适合高并发应用。</li><li>缺点：需要服务器支持 WebSocket，客户端实现也较复杂。</li></ul><p><strong>适用场景</strong>：在线游戏、实时协作工具、股票交易系统等对实时性要求极高的应用。</p><h2 id="4-服务器推送事件（Server-Sent-Events-SSE）——-简单的单向推送"><a href="#4-服务器推送事件（Server-Sent-Events-SSE）——-简单的单向推送" class="headerlink" title="4. 服务器推送事件（Server-Sent Events, SSE）—— 简单的单向推送"></a>4. 服务器推送事件（Server-Sent Events, SSE）—— 简单的单向推送</h2><p>SSE 允许服务器主动推送数据给客户端，客户端只需建立一次连接。<br>这是一个基于 HTTP 协议的单向通信方式。</p><h3 id="实现示例-3"><a href="#实现示例-3" class="headerlink" title="实现示例"></a><strong>实现示例</strong></h3><p>服务器端（Node.js 示例）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"></span><br><span class="line">http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.<span class="title function_">writeHead</span>(<span class="number">200</span>, &#123;</span><br><span class="line">    <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/event-stream&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Cache-Control&#x27;</span>: <span class="string">&#x27;no-cache&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Connection&#x27;</span>: <span class="string">&#x27;keep-alive&#x27;</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    res.<span class="title function_">write</span>(<span class="string">`data: <span class="subst">$&#123;<span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleTimeString()&#125;</span>\n\n`</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;).<span class="title function_">listen</span>(<span class="number">3000</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;SSE 服务器已启动，监听端口 3000&#x27;</span>);</span><br></pre></td></tr></table></figure><p>客户端代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> eventSource = <span class="keyword">new</span> <span class="title class_">EventSource</span>(<span class="string">&#x27;/sse&#x27;</span>);</span><br><span class="line"></span><br><span class="line">eventSource.<span class="property">onmessage</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;收到服务器推送:&#x27;</span>, event.<span class="property">data</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="优缺点分析-3"><a href="#优缺点分析-3" class="headerlink" title="优缺点分析"></a><strong>优缺点分析</strong></h3><ul><li>优点：实现简单，支持自动重连，节省带宽。</li><li>缺点：只支持单向通信，客户端无法主动发送数据。</li></ul><p><strong>适用场景</strong>：实时新闻推送、数据监控面板。</p><h2 id="5-HTTP-2-Push-——-优化资源加载的新选择"><a href="#5-HTTP-2-Push-——-优化资源加载的新选择" class="headerlink" title="5. HTTP/2 Push —— 优化资源加载的新选择"></a>5. HTTP/2 Push —— 优化资源加载的新选择</h2><p>HTTP/2 Push 是 HTTP/2 协议中的一项功能，允许服务器在客户端请求前主动推送资源。</p><h3 id="优缺点分析-4"><a href="#优缺点分析-4" class="headerlink" title="优缺点分析"></a><strong>优缺点分析</strong></h3><ul><li>优点：减少延迟，提高页面加载速度。</li><li>缺点：浏览器和服务器必须都支持 HTTP/2。</li></ul><p><strong>适用场景</strong>：主要用于优化前端资源加载，例如预加载 CSS 或 JavaScript 文件。</p><h2 id="总结：如何选择合适的即时通信方案？"><a href="#总结：如何选择合适的即时通信方案？" class="headerlink" title="总结：如何选择合适的即时通信方案？"></a>总结：如何选择合适的即时通信方案？</h2><table><thead><tr><th align="center">方案</th><th align="center">优点</th><th align="center">缺点</th><th align="center">适用场景</th></tr></thead><tbody><tr><td align="center">轮询</td><td align="center">简单直接</td><td align="center">浪费带宽，响应不及时</td><td align="center">低频数据刷新</td></tr><tr><td align="center">长轮询</td><td align="center">相对高效</td><td align="center">服务器资源占用较高</td><td align="center">聊天系统、通知系统</td></tr><tr><td align="center">WebSocket</td><td align="center">双向通信，实时性高</td><td align="center">实现复杂</td><td align="center">在线游戏、协作工具</td></tr><tr><td align="center">SSE</td><td align="center">实现简单，支持自动重连</td><td align="center">单向通信</td><td align="center">数据监控、实时新闻</td></tr><tr><td align="center">HTTP/2 Push</td><td align="center">优化资源加载</td><td align="center">需要 HTTP/2 支持</td><td align="center">前端性能优化</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 未分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无标签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 浮点数与 0 按位或，实现舍弃小数位取整</title>
      <link href="/posts/20230607191236/"/>
      <url>/posts/20230607191236/</url>
      
        <content type="html"><![CDATA[<p>今天工作时，在项目中发现一处有趣的 JavaScript 代码，它将一个浮点数与 0，进行了一个 <strong>按位或</strong> 运算。开始还不清楚所谓何意，后来通过测试和查证才知道。</p><p>原来，使用 <strong>按位或运算符 (|)</strong> 可以将浮点数转为整数，并舍弃小数部分。这是因为按位操作会将数字隐式转换为 <strong>32 位整数</strong>，从而舍弃小数部分。示例代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">5.67</span>;</span><br><span class="line"><span class="keyword">let</span> result = num | <span class="number">0</span>;  <span class="comment">// 按位或运算</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);   <span class="comment">// 输出: 5</span></span><br></pre></td></tr></table></figure><p><strong>原理：</strong></p><ol><li><strong>按位或 (|)</strong> 运算符会将操作数转换为32位有符号整数。</li><li>浮点型的小数部分在转换过程中会被截断，而不是四舍五入。</li></ol><p><strong>优点：</strong></p><ul><li>   性能好：比 Math.floor()、parseInt() 等函数更快。</li><li>   简洁：代码简单，易于书写。</li></ul><p><strong>注意事项：</strong></p><ol><li>只能处理 <strong>32位整数范围内的数值</strong> （即：-2^31 到 2^31 - 1）。对于超出此范围的数，结果可能不准确。</li><li>如果需要 <strong>向下取整</strong> 或处理 <strong>负数</strong>，可以改用 Math.floor()：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(-<span class="number">5.67</span> | <span class="number">0</span>);     <span class="comment">// 输出: -5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="title function_">floor</span>(-<span class="number">5.67</span>)); <span class="comment">// 输出: -6</span></span><br></pre></td></tr></table></figure><p><strong>结论：</strong></p><p>所以，num | 0 确实是一种快速、简便的方式来舍弃小数部分取整，但要注意其处理负数的行为和范围限制。</p>]]></content>
      
      
      <categories>
          
          <category> 未分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无标签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>macOS - 给 Terminal(终端)配置网络代理</title>
      <link href="/posts/20230102172153/"/>
      <url>/posts/20230102172153/</url>
      
        <content type="html"><![CDATA[<blockquote><p>与浏览器不同，mac 的终端默认并没有开启代理模式，也就是说即使我们电脑安装了代理客户端，在终端中也是无法使用代理的。下面通过样例演示如何对终端配置网络代理。</p></blockquote><h2 id="1-确定客户端端口"><a href="#1-确定客户端端口" class="headerlink" title="1. 确定客户端端口"></a>1. 确定客户端端口</h2><p>首先我们打开使用的代理客户端设置界面，查看其开放的 HTTP 端口，比如我这里是 1087</p><p><img src="/posts/20230102172153/%E7%9B%91%E5%90%AC%E7%AB%AF%E5%8F%A3.png" class="lazyload" data-srcset="/posts/20230102172153/%E7%9B%91%E5%90%AC%E7%AB%AF%E5%8F%A3.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="监听端口"></p><h2 id="2-配置代理"><a href="#2-配置代理" class="headerlink" title="2. 配置代理"></a>2. 配置代理</h2><p>macOS Catalina 之后，Mac 使用 zsh 作为默认的 Shell 终端，我们这里就以 zsh 配置为例展示配置方法。</p><p>修改 <code>~/.zshrc</code> 配置文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.zshrc</span><br></pre></td></tr></table></figure><p>向其中添加如下内容：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Turn on and off all_proxy</span></span><br><span class="line"><span class="built_in">alias</span> proxy=<span class="string">&quot;export all_proxy=http://127.0.0.1:1087 &amp;&amp; echo &#x27;Already turn on all_proxy to http://127.0.0.1:1087&#x27;&quot;</span></span><br><span class="line"><span class="built_in">alias</span> unproxy=<span class="string">&quot;unset all_proxy &amp;&amp; echo &#x27;Already turn off all_proxy&#x27;&quot;</span></span><br></pre></td></tr></table></figure><p>保存退出 vim 后，执行如下命令，使配置生效</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure><h2 id="3-测试"><a href="#3-测试" class="headerlink" title="3. 测试"></a>3. 测试</h2><p>首先我们使用 curl 命令查看终端目前的 IP：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl ipinfo.io</span><br></pre></td></tr></table></figure><p>得到类似下面的结果，可以看出确实使用的是国内的 IP 地址：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;ip&quot;</span><span class="punctuation">:</span> <span class="string">&quot;...&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;region&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Guangdong&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;country&quot;</span><span class="punctuation">:</span> <span class="string">&quot;CN&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;timezone&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Asia/Shanghai&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>接着我们执行 <code>proxy</code> 命令开启终端代理模式（仅针对当前会话生效）：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxy</span><br></pre></td></tr></table></figure><p>再次使用 curl 命令查看可以发现变成了国外的 IP（代理服务器的 IP）：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;ip&quot;</span><span class="punctuation">:</span> <span class="string">&quot;...&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;region&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Tokyo&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;country&quot;</span><span class="punctuation">:</span> <span class="string">&quot;JP&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;timezone&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Asia/Tokyo&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>如果需要关闭代理模式，执行如下命令即可：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unproxy</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 未分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无标签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何减少关键路径渲染（Critical Rendering Path）</title>
      <link href="/posts/20221122231311/"/>
      <url>/posts/20221122231311/</url>
      
        <content type="html"><![CDATA[<p><strong>关键路径渲染（Critical Rendering Path，CRP）</strong> 是指浏览器将 HTML、CSS 和 JavaScript 解析为可视页面的过程。CRP 的优化直接影响 <strong>页面的首次内容呈现时间</strong> 和用户的 <strong>加载体验</strong>。在现代前端开发中，减少关键路径渲染的时间已成为提升网页性能的关键环节。本文将逐步讲解 CRP 的工作原理，并提供实用的优化策略。</p><h2 id="一、什么是关键路径渲染（CRP）？"><a href="#一、什么是关键路径渲染（CRP）？" class="headerlink" title="一、什么是关键路径渲染（CRP）？"></a>一、什么是关键路径渲染（CRP）？</h2><p>浏览器渲染页面的过程大致如下：</p><ol><li>HTML 解析为 DOM 树：浏览器逐行解析 HTML 代码，构建 DOM（Document Object Model）树。</li><li>CSS 解析为 CSSOM 树：同时解析 CSS，构建 CSSOM（CSS Object Model）树。</li><li>合并 DOM 和 CSSOM 树：生成渲染树（Render Tree），决定哪些元素可见。</li><li>布局和绘制：浏览器计算元素的位置和大小（布局），然后将其绘制到屏幕。</li></ol><p>如果某些资源（如 JS 或 CSS 文件）未及时加载并阻塞了这个过程，就会延长页面的首屏呈现时间，导致用户体验下降。</p><h2 id="二、如何减少关键路径渲染的时间？"><a href="#二、如何减少关键路径渲染的时间？" class="headerlink" title="二、如何减少关键路径渲染的时间？"></a>二、如何减少关键路径渲染的时间？</h2><p>减少 CRP 的时间，主要依赖减少资源体积、缩短加载时间和优化资源的解析顺序。以下是一些行之有效的优化策略。</p><h3 id="1-减少阻塞资源"><a href="#1-减少阻塞资源" class="headerlink" title="1. 减少阻塞资源"></a>1. 减少阻塞资源</h3><h4 id="1-1-延迟加载-JavaScript"><a href="#1-1-延迟加载-JavaScript" class="headerlink" title="1.1 延迟加载 JavaScript"></a>1.1 延迟加载 JavaScript</h4><p>JavaScript 文件会阻塞 HTML 的解析，因此可以使用 defer 或 async 来延迟脚本加载。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 使用 <span class="keyword">async</span> 加载，脚本下载完成后立即执行 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;script.js&quot;</span> <span class="attr">async</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;!-- 使用 defer 加载，脚本在 <span class="variable constant_">HTML</span> 解析完成后执行 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;script.js&quot;</span> <span class="attr">defer</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>推荐：将不影响页面首屏展示的 JS 脚本标记为 defer。</p><h4 id="1-2-内联关键-CSS"><a href="#1-2-内联关键-CSS" class="headerlink" title="1.2 内联关键 CSS"></a>1.2 内联关键 CSS</h4><p>将首屏展示所需的 CSS内联到 HTML 中，减少 CSS 文件的加载延迟。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">body</span> &#123; <span class="attribute">margin</span>: <span class="number">0</span>; <span class="attribute">font-family</span>: sans-serif; &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.hero</span> &#123; <span class="attribute">background-color</span>: <span class="number">#4CAF50</span>; <span class="attribute">height</span>: <span class="number">100vh</span>; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-压缩和优化资源"><a href="#2-压缩和优化资源" class="headerlink" title="2. 压缩和优化资源"></a>2. 压缩和优化资源</h3><h4 id="2-1-使用-Gzip-或-Brotli-压缩"><a href="#2-1-使用-Gzip-或-Brotli-压缩" class="headerlink" title="2.1 使用 Gzip 或 Brotli 压缩"></a>2.1 使用 Gzip 或 Brotli 压缩</h4><p>启用服务器端压缩，减少 HTML、CSS 和 JavaScript 文件的传输体积。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 nginx 配置中启用 Gzip</span></span><br><span class="line">gzip on;</span><br><span class="line">gzip_types text/plain text/css application/javascript;</span><br></pre></td></tr></table></figure><h4 id="2-2-使用-Tree-Shaking-和代码拆分"><a href="#2-2-使用-Tree-Shaking-和代码拆分" class="headerlink" title="2.2 使用 Tree Shaking 和代码拆分"></a>2.2 使用 Tree Shaking 和代码拆分</h4><p>通过 Tree Shaking 移除未使用的代码，并利用代码拆分减少首次加载的资源量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Tree Shaking 示例，只打包实际使用的函数</span></span><br><span class="line"><span class="keyword">import</span> &#123; usedFunction &#125; <span class="keyword">from</span> <span class="string">&#x27;./utils&#x27;</span>;</span><br><span class="line"><span class="title function_">usedFunction</span>();</span><br></pre></td></tr></table></figure><h3 id="3-优化-CSS-和字体加载"><a href="#3-优化-CSS-和字体加载" class="headerlink" title="3. 优化 CSS 和字体加载"></a>3. 优化 CSS 和字体加载</h3><h4 id="3-1-减少-CSS-文件体积"><a href="#3-1-减少-CSS-文件体积" class="headerlink" title="3.1 减少 CSS 文件体积"></a>3.1 减少 CSS 文件体积</h4><ul><li>删除未使用的 CSS。</li><li>使用 CSS 压缩工具（如 cssnano）。</li></ul><h4 id="3-2-使用字体加载优化"><a href="#3-2-使用字体加载优化" class="headerlink" title="3.2 使用字体加载优化"></a>3.2 使用字体加载优化</h4><p>使用 font-display: swap 避免字体阻塞渲染。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@font-face</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">&#x27;CustomFont&#x27;</span>;</span><br><span class="line">  <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">&#x27;custom-font.woff2&#x27;</span>) <span class="built_in">format</span>(<span class="string">&#x27;woff2&#x27;</span>);</span><br><span class="line">  <span class="attribute">font-display</span>: swap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-使用缓存提升加载速度"><a href="#4-使用缓存提升加载速度" class="headerlink" title="4. 使用缓存提升加载速度"></a>4. 使用缓存提升加载速度</h3><ol><li>启用浏览器缓存：设置 HTTP 头，如 Cache-Control 和 ETag，确保静态资源被缓存。</li><li>使用 Service Worker：利用 PWA 技术，将资源缓存到本地，提高页面的离线访问能力。</li></ol><h3 id="5-优先加载关键资源"><a href="#5-优先加载关键资源" class="headerlink" title="5. 优先加载关键资源"></a>5. 优先加载关键资源</h3><h4 id="5-1-使用"><a href="#5-1-使用" class="headerlink" title="5.1 使用 "></a>5.1 使用 <link rel="preload"></h4><p>预加载关键资源，确保它们尽快开始下载。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;preload&quot;</span> <span class="attr">href</span>=<span class="string">&quot;styles.css&quot;</span> <span class="attr">as</span>=<span class="string">&quot;style&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;preload&quot;</span> <span class="attr">href</span>=<span class="string">&quot;script.js&quot;</span> <span class="attr">as</span>=<span class="string">&quot;script&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="5-2-使用"><a href="#5-2-使用" class="headerlink" title="5.2 使用 "></a>5.2 使用 <link rel="prefetch"></h4><p>为非关键资源使用预获取策略，提高后续页面加载速度。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;prefetch&quot;</span> <span class="attr">href</span>=<span class="string">&quot;next-page.html&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="6-减少重排与重绘"><a href="#6-减少重排与重绘" class="headerlink" title="6. 减少重排与重绘"></a>6. 减少重排与重绘</h3><ul><li>避免频繁操作 DOM：合并多次 DOM 修改，减少重排开销。</li><li>使用 CSS 动画代替 JavaScript 动画：CSS 动画通常性能更好。</li><li>避免触发 Layout Thrashing：避免在 JS 中频繁读取和写入 DOM 属性。</li></ul><h2 id="三、常见问题与解决方案"><a href="#三、常见问题与解决方案" class="headerlink" title="三、常见问题与解决方案"></a>三、常见问题与解决方案</h2><h3 id="问题-1：如何判断哪些资源属于关键资源？"><a href="#问题-1：如何判断哪些资源属于关键资源？" class="headerlink" title="问题 1：如何判断哪些资源属于关键资源？"></a>问题 1：如何判断哪些资源属于关键资源？</h3><p>解决方案：使用 Chrome DevTools 的“性能面板”查看加载的资源，并标记延迟页面渲染的关键资源。</p><h3 id="问题-2：如何避免字体加载造成的闪烁（FOIT）？"><a href="#问题-2：如何避免字体加载造成的闪烁（FOIT）？" class="headerlink" title="问题 2：如何避免字体加载造成的闪烁（FOIT）？"></a>问题 2：如何避免字体加载造成的闪烁（FOIT）？</h3><p>解决方案：为字体添加 font-display: swap，让浏览器使用系统字体进行替代，直至自定义字体加载完成。</p><h3 id="问题-3：如何减少第三方库对渲染的影响？"><a href="#问题-3：如何减少第三方库对渲染的影响？" class="headerlink" title="问题 3：如何减少第三方库对渲染的影响？"></a>问题 3：如何减少第三方库对渲染的影响？</h3><p>解决方案：</p><ul><li>使用 async 或 defer 延迟加载第三方 JS 脚本，如广告、分析工具等。</li><li>利用动态导入按需加载部分第三方依赖。</li><li>使用轻量替代库，如用 day.js 替代 moment.js。</li></ul><h3 id="问题-4：如何避免图片加载影响页面首屏渲染？"><a href="#问题-4：如何避免图片加载影响页面首屏渲染？" class="headerlink" title="问题 4：如何避免图片加载影响页面首屏渲染？"></a>问题 4：如何避免图片加载影响页面首屏渲染？</h3><p>解决方案：</p><ul><li>使用 lazyload 延迟加载首屏外的图片。</li><li>将小图片转换为 Base64 格式内联到 HTML 中，减少 HTTP 请求。</li><li>使用 srcset 和 sizes 优化响应式图片加载。</li></ul><h3 id="问题-5：如何优化首次访问与返回访问的性能差异？"><a href="#问题-5：如何优化首次访问与返回访问的性能差异？" class="headerlink" title="问题 5：如何优化首次访问与返回访问的性能差异？"></a>问题 5：如何优化首次访问与返回访问的性能差异？</h3><p>解决方案：</p><ul><li>配置 Service Worker 将关键资源缓存到本地，缩短后续访问时间。</li><li>使用 HTTP/2 或 HTTP/3 多路复用技术，提升首次访问时的资源加载速度。</li></ul><h3 id="问题-6：如何监控并持续优化-CRP？"><a href="#问题-6：如何监控并持续优化-CRP？" class="headerlink" title="问题 6：如何监控并持续优化 CRP？"></a>问题 6：如何监控并持续优化 CRP？</h3><p>解决方案：</p><ul><li>使用 Lighthouse 或 Web Vitals 插件定期生成性能报告。</li><li>集成 Google Analytics 的 First Input Delay (FID) 指标，实时分析页面交互性能。</li><li>持续关注 CLS（Cumulative Layout Shift），减少布局偏移问题。</li></ul><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>减少关键路径渲染时间对于提升网页性能和用户体验至关重要。通过减少阻塞资源、压缩和优化资源、优先加载关键内容和减少重排与重绘，我们可以有效缩短页面的首次内容呈现时间。</p><p>在实际项目中，优化 CRP 是一个持续的过程。建议借助 Chrome DevTools 等工具，实时监控性能瓶颈，并逐步优化。优化后的页面不仅能显著提升加载速度，也能提高用户的访问体验，带来更高的转化率。</p>]]></content>
      
      
      <categories>
          
          <category> 未分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无标签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手动实现 JavaScript 迭代器</title>
      <link href="/posts/20221121203323/"/>
      <url>/posts/20221121203323/</url>
      
        <content type="html"><![CDATA[<p>在 JavaScript 中，迭代器是一个非常强大的工具。它允许我们逐步遍历集合中的元素，如数组、字符串、Map 等。然而，除了使用内置的迭代器（如 for…of、Array.prototype.entries() 等），我们还可以手动实现自己的迭代器来满足特殊需求。今天我们就从零开始，逐步带你了解如何实现一个 JavaScript 迭代器。</p><h2 id="一、什么是迭代器？"><a href="#一、什么是迭代器？" class="headerlink" title="一、什么是迭代器？"></a>一、什么是迭代器？</h2><p>迭代器的本质是一个对象，它提供了一种标准化的访问数据的方法。它需要具备两个关键要素：</p><ol><li><strong>next() 方法：</strong> 每次调用时，返回一个包含 value 和 done 属性的对象。</li><li><strong>状态跟踪：</strong> 用于记录当前迭代的进度。</li></ol><p>返回的对象结构为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">value</span>: &lt;当前值&gt;, <span class="attr">done</span>: &lt;是否结束&gt; &#125;</span><br></pre></td></tr></table></figure><ul><li>value 表示当前迭代项的值。</li><li>done 是一个布尔值，用于表示迭代是否结束。</li></ul><h2 id="二、内置迭代器的简单例子"><a href="#二、内置迭代器的简单例子" class="headerlink" title="二、内置迭代器的简单例子"></a>二、内置迭代器的简单例子</h2><p>在继续之前，我们先来看一个数组的内置迭代器：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> iterator = arr[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>()); <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>()); <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>()); <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>()); <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>这里我们使用了数组的内置 Symbol.iterator 方法。每次调用 next() 都会依次获取数组的下一个元素，直到所有元素遍历完成。</p><h2 id="三、手动实现一个简单的迭代器"><a href="#三、手动实现一个简单的迭代器" class="headerlink" title="三、手动实现一个简单的迭代器"></a>三、手动实现一个简单的迭代器</h2><p>我们现在尝试手动实现一个基本的迭代器。目标是实现一个能遍历数组的自定义迭代器。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createArrayIterator</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (index &lt; arr.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">value</span>: arr[index++], <span class="attr">done</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> iterator = <span class="title function_">createArrayIterator</span>([<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>]);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>()); <span class="comment">// &#123; value: 10, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>()); <span class="comment">// &#123; value: 20, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>()); <span class="comment">// &#123; value: 30, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>()); <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><p><strong>代码说明：</strong></p><ol><li>createArrayIterator 函数接收一个数组作为参数。</li><li>每次调用 next()，都会返回当前数组元素并将索引前进一位。</li><li>当数组遍历完成后，返回 { value: undefined, done: true }。</li></ol><h2 id="四、为对象添加迭代器"><a href="#四、为对象添加迭代器" class="headerlink" title="四、为对象添加迭代器"></a>四、为对象添加迭代器</h2><p>我们可以通过 Symbol.iterator 为任何对象定义自定义的迭代逻辑。这样，我们的对象也能在 for…of 循环中使用。下面，我们为一个自定义对象实现迭代器。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> range = &#123;</span><br><span class="line">  <span class="attr">start</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">end</span>: <span class="number">5</span>,</span><br><span class="line">  </span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">    <span class="keyword">let</span> current = <span class="variable language_">this</span>.<span class="property">start</span>;</span><br><span class="line">    <span class="keyword">const</span> end = <span class="variable language_">this</span>.<span class="property">end</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current &lt;= end) &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123; <span class="attr">value</span>: current++, <span class="attr">done</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123; <span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> num <span class="keyword">of</span> range) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(num); <span class="comment">// 输出 1 2 3 4 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码说明：</strong></p><ol><li>range 对象表示一个范围，从 start 到 end。</li><li>在对象内部使用 Symbol.iterator 定义了一个迭代器。</li><li>for…of 会自动调用对象的 <a href>Symbol.iterator</a> 方法来获取迭代器。</li></ol><h2 id="五、实现无限迭代器"><a href="#五、实现无限迭代器" class="headerlink" title="五、实现无限迭代器"></a>五、实现无限迭代器</h2><p>有时候，我们需要创建一个无限序列，比如生成斐波那契数列。下面是一个无限斐波那契迭代器的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fibonacciIterator</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> [prev, curr] = [<span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">      [prev, curr] = [curr, prev + curr];</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">value</span>: prev, <span class="attr">done</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fib = <span class="title function_">fibonacciIterator</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fib.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fib.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fib.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fib.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fib.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// 5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fib.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// 8</span></span><br></pre></td></tr></table></figure><p><strong>代码说明：</strong></p><ul><li>每次调用 next()，斐波那契序列都会前进一位，并返回当前的值。</li><li>无限序列的迭代器没有终止条件，因此 done 始终为 false。</li></ul><h2 id="六、可迭代对象与迭代器的区别"><a href="#六、可迭代对象与迭代器的区别" class="headerlink" title="六、可迭代对象与迭代器的区别"></a>六、可迭代对象与迭代器的区别</h2><ol><li>可迭代对象：具有 <a href>Symbol.iterator</a> 方法的对象，可以在 for…of 中使用，如数组、字符串等。</li><li>迭代器：实现了 next() 方法的对象，每次调用 next() 返回一个 { value, done } 对象。</li></ol><p><strong>总结：</strong> 可迭代对象内部使用迭代器来实现元素的逐个访问。for…of 只是对迭代器的一种封装。</p>]]></content>
      
      
      <categories>
          
          <category> 未分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无标签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于 axios 手写文件上传，实现进度监听、上传中断</title>
      <link href="/posts/20220512221823/"/>
      <url>/posts/20220512221823/</url>
      
        <content type="html"><![CDATA[<p>要基于 axios 手写一个文件上传组件，并实现以下功能：</p><ol><li>选择文件并上传</li><li>监听上传进度</li><li>支持上传中断（取消请求）</li><li>处理成功和失败的回调</li></ol><p>下面是一个完整的实现代码示例：</p><h2 id="1-安装依赖"><a href="#1-安装依赖" class="headerlink" title="1. 安装依赖"></a>1. 安装依赖</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install axios</span><br></pre></td></tr></table></figure><h2 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2. 代码实现"></a>2. 代码实现</h2><p><strong>HTML 模板示例：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">id</span>=<span class="string">&quot;fileInput&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;uploadButton&quot;</span>&gt;</span>上传<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;cancelButton&quot;</span>&gt;</span>取消上传<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;progress&quot;</span>&gt;</span>上传进度: 0%<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>JavaScript 代码实现：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cancelTokenSource = <span class="literal">null</span>; <span class="comment">// 用于取消上传</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听文件选择并上传</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;uploadButton&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> fileInput = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;fileInput&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span> (fileInput.<span class="property">files</span>.<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;请选择文件&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> file = fileInput.<span class="property">files</span>[<span class="number">0</span>];</span><br><span class="line">  <span class="title function_">uploadFile</span>(file);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消上传</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;cancelButton&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (cancelTokenSource) &#123;</span><br><span class="line">    cancelTokenSource.<span class="title function_">cancel</span>(<span class="string">&#x27;上传已取消&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件上传逻辑</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">uploadFile</span>(<span class="params">file</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> url = <span class="string">&#x27;https://your-upload-endpoint.com/upload&#x27;</span>; <span class="comment">// 替换为实际上传地址</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建 Axios 的取消令牌</span></span><br><span class="line">  cancelTokenSource = axios.<span class="property">CancelToken</span>.<span class="title function_">source</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建表单数据</span></span><br><span class="line">  <span class="keyword">const</span> formData = <span class="keyword">new</span> <span class="title class_">FormData</span>();</span><br><span class="line">  formData.<span class="title function_">append</span>(<span class="string">&#x27;file&#x27;</span>, file);</span><br><span class="line"></span><br><span class="line">  axios.<span class="title function_">post</span>(url, formData, &#123;</span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;multipart/form-data&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">cancelToken</span>: cancelTokenSource.<span class="property">token</span>,</span><br><span class="line">    <span class="attr">onUploadProgress</span>: <span class="function">(<span class="params">progressEvent</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> percentCompleted = <span class="title class_">Math</span>.<span class="title function_">round</span>(</span><br><span class="line">        (progressEvent.<span class="property">loaded</span> * <span class="number">100</span>) / progressEvent.<span class="property">total</span></span><br><span class="line">      );</span><br><span class="line">      <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;progress&#x27;</span>).<span class="property">innerText</span> = <span class="string">`上传进度: <span class="subst">$&#123;percentCompleted&#125;</span>%`</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;上传成功&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">data</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (axios.<span class="title function_">isCancel</span>(error)) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;上传被取消:&#x27;</span>, error.<span class="property">message</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;上传失败:&#x27;</span>, error);</span><br><span class="line">      <span class="title function_">alert</span>(<span class="string">&#x27;上传失败&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-代码说明"><a href="#3-代码说明" class="headerlink" title="3. 代码说明"></a>3. 代码说明</h2><ul><li>选择文件并上传：用户点击上传按钮时，调用 uploadFile 函数，将文件上传到指定的服务器端。</li><li>监听上传进度：使用 onUploadProgress 回调函数来实时更新进度。</li><li>支持上传中断：使用 axios.CancelToken 创建可取消的请求，并在用户点击“取消上传”按钮时触发中断。</li><li>处理错误：区分普通错误和用户主动取消上传的情况。</li></ul><h2 id="4-效果预览"><a href="#4-效果预览" class="headerlink" title="4. 效果预览"></a>4. 效果预览</h2><ul><li>进度监听：上传时，页面上会实时显示百分比。</li><li>取消上传：上传过程中的任何时间都可以中断请求。</li></ul><h2 id="5-服务器端（可选参考）"><a href="#5-服务器端（可选参考）" class="headerlink" title="5. 服务器端（可选参考）"></a>5. 服务器端（可选参考）</h2><p>后端需要支持接收 multipart/form-data 请求。如果你使用的是 Node.js，可以用 express 搭配 multer 处理文件上传。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> multer = <span class="built_in">require</span>(<span class="string">&#x27;multer&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> upload = <span class="title function_">multer</span>(&#123; <span class="attr">dest</span>: <span class="string">&#x27;uploads/&#x27;</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">post</span>(<span class="string">&#x27;/upload&#x27;</span>, upload.<span class="title function_">single</span>(<span class="string">&#x27;file&#x27;</span>), <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;文件信息:&#x27;</span>, req.<span class="property">file</span>);</span><br><span class="line">  res.<span class="title function_">send</span>(&#123; <span class="attr">status</span>: <span class="string">&#x27;上传成功&#x27;</span> &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;服务器启动在 http://localhost:3000&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这个组件实现了完整的文件上传流程，你还可以根据需要进一步定制，比如支持多个文件、添加更多的上传校验等。</p>]]></content>
      
      
      <categories>
          
          <category> 未分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无标签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在 PowerShell 中使用 Git</title>
      <link href="/posts/20220422181821/"/>
      <url>/posts/20220422181821/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 macOS 下 git 命令行工具默认有着很好的 tab 补全功能，而在 Windows 下通过 exe 安装的 git 程序，看起来就有些简陋。</p><p>其自带的 Unix Shell 环境模拟窗口 Git Bash，有着丑陋的外观，即便可以通过配置字体、颜色等手段稍加改善，但其一会儿类 Unix 工具链环境的反馈，一会儿 Windows cmd 工具链混搭的集成环境，着实容易让人精神分裂。</p><p>为了更好的自始至终统一使用体验，我们通常会将 git 程序添加到 全局 path 中（引导安装程序即可选配），然后在 cmd 或 PowerShell（通常是功能更强大的 PowerShell）中调用 git。</p><p>然而在 PowerShell 中调用 git 时，我们丧失了 tab 补全功能。</p><p>这里，我们介绍使用 <a href="https://github.com/dahlbyk/posh-git">Posh-Git</a> 这个扩展包，从而在 PowerShell 中应用 git 的 tab 补全。</p><h2 id="安装-Post-Git"><a href="#安装-Post-Git" class="headerlink" title="安装 Post-Git"></a>安装 Post-Git</h2><h3 id="配置脚本执行权限"><a href="#配置脚本执行权限" class="headerlink" title="配置脚本执行权限"></a>配置脚本执行权限</h3><p>在可以运行 PowerShell 脚本之前，你需要将本地的 ExecutionPolicy 设置为 RemoteSigned</p><p>在 PowerShell 中执行下面的命令，更精细化的配置参见 <a href="https://learn.microsoft.com/zh-cn/powershell/module/microsoft.powershell.security/set-executionpolicy?view=powershell-7.2">微软文档 Set-ExecutionPolicy</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope LocalMachine</span><br></pre></td></tr></table></figure><h3 id="使用包管理器安装-posh-git"><a href="#使用包管理器安装-posh-git" class="headerlink" title="使用包管理器安装 posh-git"></a>使用包管理器安装 posh-git</h3><p>在 PowerShell 中执行下面的命令，通过包管理器来安装 posh-git</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Install-Module posh-git -Scope CurrentUser -Force</span><br><span class="line">Install-Module posh-git -Scope CurrentUser -AllowPrerelease -Force # 带有 PowerShell Core 支持的更新的 beta 版</span><br></pre></td></tr></table></figure><p>如果你想为所有的用户安装 posh-git，请使用 <code>-Scope AllUsers</code> 并在管理员权限启动的 PowerShell 控制台中执行。</p><h3 id="更新-PowerShell-提示符"><a href="#更新-PowerShell-提示符" class="headerlink" title="更新 PowerShell 提示符"></a>更新 PowerShell 提示符</h3><p>要在你的提示符中包含 Git 信息，那么需要导入 Posh-Git 模块。 要让 PowerShell 在每次启动时都导入 Posh-Git，请执行 <code>Add-PoshGitToProfile</code> 命令， 它会在你的 $profile 脚本中添加导入语句。此脚本会在每次打开新的 PowerShell 终端时执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Import-Module posh-git</span><br><span class="line">Add-PoshGitToProfile -AllHosts</span><br></pre></td></tr></table></figure><p>更多详细内容，参见：<a href="https://git-scm.com/book/zh/v2/%E9%99%84%E5%BD%95-A%3A-%E5%9C%A8%E5%85%B6%E5%AE%83%E7%8E%AF%E5%A2%83%E4%B8%AD%E4%BD%BF%E7%94%A8-Git-Git-%E5%9C%A8-PowerShell-%E4%B8%AD%E4%BD%BF%E7%94%A8-Git">Git 文档：A1.9 附录 A: 在其它环境中使用 Git - Git 在 PowerShell 中使用 Git</a></p><h2 id="自定义-posh-git-提示符"><a href="#自定义-posh-git-提示符" class="headerlink" title="自定义 posh-git 提示符"></a>自定义 posh-git 提示符</h2><p>当您导入 posh-git 模块时，它将用新的提示功能替换 PowerShell 的默认提示功能。当当前目录位于 Git 存储库中时，posh-git 提示功能将显示 Git 状态摘要信息。如果 posh-git 检测到您有自己的自定义提示功能，则不会替换提示功能。</p><p>这里可以通过编辑当前用户 ps1 文件，实现自定义提示符：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$Profile</span></span><br></pre></td></tr></table></figure><p>得到形如下方的绝对路径，表示当前用户 ps1 配置文件默认加载位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\liang\Documents\WindowsPowerShell\Microsoft.PowerShell_profile.ps1</span><br></pre></td></tr></table></figure><p>打开并编辑这个文件，加入下面的内容：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$GitPromptSettings</span>.DefaultPromptPrefix.Text = <span class="string">&#x27;PS [$(Get-Date -f &quot;HH:mm:ss&quot;)] &#x27;</span></span><br><span class="line"><span class="variable">$GitPromptSettings</span>.DefaultPromptPrefix.ForegroundColor = [ConsoleColor]::Magenta</span><br><span class="line"><span class="variable">$GitPromptSettings</span>.DefaultPromptAbbreviateHomeDirectory = <span class="variable">$true</span></span><br><span class="line"><span class="variable">$GitPromptSettings</span>.BeforePath = <span class="string">&#x27;&#123;&#x27;</span></span><br><span class="line"><span class="variable">$GitPromptSettings</span>.AfterPath = <span class="string">&#x27;&#125;&#x27;</span></span><br><span class="line"><span class="variable">$GitPromptSettings</span>.DefaultPromptPath.ForegroundColor = 0xFFA500</span><br><span class="line"><span class="variable">$GitPromptSettings</span>.BeforePath.ForegroundColor = 0xFFA500</span><br><span class="line"><span class="variable">$GitPromptSettings</span>.AfterPath.ForegroundColor = 0xFFA500</span><br><span class="line"><span class="variable">$GitPromptSettings</span>.DefaultPromptBeforeSuffix.Text = <span class="string">&#x27;`n&#x27;</span></span><br></pre></td></tr></table></figure><p>你将获得一个同时拥有 时间、家目录缩写、git 状态的提示符，它会像下面这样：</p><p><img src="/posts/20220422181821/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8F%90%E7%A4%BA%E7%AC%A6.png" class="lazyload" data-srcset="/posts/20220422181821/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8F%90%E7%A4%BA%E7%AC%A6.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="自定义提示符"></p><p>更多详细内容，参见：<a href="https://github.com/dahlbyk/posh-git?tab=readme-ov-file#customizing-the-posh-git-prompt">GitHub - dahlbyk/posh-git - Customizing the posh-git prompt</a></p><h2 id="顺便说下中文乱码问题"><a href="#顺便说下中文乱码问题" class="headerlink" title="顺便说下中文乱码问题"></a>顺便说下中文乱码问题</h2><p>PowerShell 下 <code>git log</code> 中文、<code>git status</code> 文件名等，可能存在中文乱码的问题。</p><p>可以向下面一样配置 git：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.quotepath false</span><br><span class="line">git config --global gui.encoding utf-8</span><br><span class="line">git config --global i18n.commit.encoding utf-8</span><br><span class="line">git config --global i18n.logoutputencoding utf-8</span><br></pre></td></tr></table></figure><p>一劳永逸的方式：</p><p>系统设置 -&gt; 管理语言设置，打开旧版的区域设置窗口</p><p>更改系统区域设置 -&gt; Beta 版：使用 Unicode UTF-8 提供全球语言支持，勾选它，重启✅</p>]]></content>
      
      
      <categories>
          
          <category> 未分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无标签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PowerShell 修改提示符的文字内容和样式</title>
      <link href="/posts/20220422000813/"/>
      <url>/posts/20220422000813/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>默认的 PowerShell 提示符丑？</p><p>其实我们可以通过编辑 PowerShell 的启动脚本，来自定义提示符的文字内容和样式</p><h3 id="配置脚本执行权限"><a href="#配置脚本执行权限" class="headerlink" title="配置脚本执行权限"></a>配置脚本执行权限</h3><p>在可以运行 PowerShell 脚本之前，你需要将本地的 ExecutionPolicy 设置为 RemoteSigned</p><p>在 PowerShell 中执行下面的命令，更精细化的配置参见 <a href="https://learn.microsoft.com/zh-cn/powershell/module/microsoft.powershell.security/set-executionpolicy?view=powershell-7.2">微软文档 Set-ExecutionPolicy</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope LocalMachine</span><br></pre></td></tr></table></figure><h2 id="查看当前用户-ps1-文件位置"><a href="#查看当前用户-ps1-文件位置" class="headerlink" title="查看当前用户 ps1 文件位置"></a>查看当前用户 ps1 文件位置</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $Profile</span><br></pre></td></tr></table></figure><p>得到形如下方的绝对路径，表示当前用户 ps1 配置文件默认加载位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\liang\Documents\WindowsPowerShell\Microsoft.PowerShell_profile.ps1</span><br></pre></td></tr></table></figure><h2 id="编辑-ps1-配置文件"><a href="#编辑-ps1-配置文件" class="headerlink" title="编辑 ps1 配置文件"></a>编辑 ps1 配置文件</h2><p>编辑这个 ps1 配置文件，可以改变 PowerShell 初始化时的一些行为</p><p>如果是第一次使用 PowerShell，这个文件可能不存在，需要我们手动创建</p><p>如果当前系统安装有 VScode，可以执行一下命令，快速创建或打开</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code $Profile</span><br></pre></td></tr></table></figure><p>下方是我的自定义配置文件内容，可以参考</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function prompt</span><br><span class="line">&#123;</span><br><span class="line">  Write-Host (&quot;`nPS [&quot;) -nonewline</span><br><span class="line">  Write-Host ($(get-date -Format &quot;HH:mm:ss&quot;)) -nonewline -foregroundcolor Red</span><br><span class="line">  Write-Host (&quot;] &#123;&quot;) -nonewline</span><br><span class="line">  Write-Host ($(pwd)) -nonewline -foregroundcolor Blue</span><br><span class="line">  Write-Host (&quot;&#125;&quot;)</span><br><span class="line">  return &quot;$ &quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使自定义配置文件生效"><a href="#使自定义配置文件生效" class="headerlink" title="使自定义配置文件生效"></a>使自定义配置文件生效</h2><p>一种方式是：</p><p>关闭并重新打开当前 PowerShell 会话，修改的配置文件效果便会生效</p><p>另一种即时生效的方式是：</p><p>执行重新加载命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">. $Profile</span><br></pre></td></tr></table></figure><h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><p><img src="/posts/20220422000813/PowerShell%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8F%90%E7%A4%BA%E7%AC%A6.png" class="lazyload" data-srcset="/posts/20220422000813/PowerShell%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8F%90%E7%A4%BA%E7%AC%A6.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="PowerShell自定义提示符"></p>]]></content>
      
      
      <categories>
          
          <category> 未分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无标签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何封装一个 JavaScript 的轻量级事件总线（Event Bus）</title>
      <link href="/posts/20220305202211/"/>
      <url>/posts/20220305202211/</url>
      
        <content type="html"><![CDATA[<h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h2><p>在前端开发中，组件之间的通信是一项常见需求。虽然常用的库（如 Redux 或 Vuex）可以解决状态管理问题，但有时我们只需要一个简单的事件总线（Event Bus），来让组件之间交换事件，而不引入复杂的状态管理工具。</p><p>接下来我们将一步步实现一个轻量级 JavaScript 事件总线，并介绍其应用场景和最佳实践。</p><h2 id="2-什么是事件总线？"><a href="#2-什么是事件总线？" class="headerlink" title="2. 什么是事件总线？"></a>2. 什么是事件总线？</h2><p>事件总线是一种 发布-订阅模式（Publish-Subscribe）的实现。其核心思想是将事件的发布者和订阅者解耦，让它们无需直接相互依赖。事件总线扮演的是一个中央通道的角色，负责协调不同组件之间的事件通知。</p><h2 id="3-实现一个简单的事件总线"><a href="#3-实现一个简单的事件总线" class="headerlink" title="3. 实现一个简单的事件总线"></a>3. 实现一个简单的事件总线</h2><p>下面我们使用 JavaScript 的原生能力来封装一个简单易用的事件总线。</p><p>基础实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EventBus</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">events</span> = <span class="keyword">new</span> <span class="title class_">Map</span>(); <span class="comment">// 使用 Map 存储事件</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注册事件监听器</span></span><br><span class="line">  <span class="title function_">on</span>(<span class="params">eventName, listener</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">events</span>.<span class="title function_">has</span>(eventName)) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">events</span>.<span class="title function_">set</span>(eventName, []);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">events</span>.<span class="title function_">get</span>(eventName).<span class="title function_">push</span>(listener);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 触发事件</span></span><br><span class="line">  <span class="title function_">emit</span>(<span class="params">eventName, ...args</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">events</span>.<span class="title function_">has</span>(eventName)) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">events</span>.<span class="title function_">get</span>(eventName).<span class="title function_">forEach</span>(<span class="function"><span class="params">listener</span> =&gt;</span> <span class="title function_">listener</span>(...args));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取消注册事件监听器</span></span><br><span class="line">  <span class="title function_">off</span>(<span class="params">eventName, listener</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">events</span>.<span class="title function_">has</span>(eventName)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">const</span> listeners = <span class="variable language_">this</span>.<span class="property">events</span>.<span class="title function_">get</span>(eventName).<span class="title function_">filter</span>(<span class="function"><span class="params">fn</span> =&gt;</span> fn !== listener);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">events</span>.<span class="title function_">set</span>(eventName, listeners);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 清除所有事件监听器</span></span><br><span class="line">  <span class="title function_">clear</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">events</span>.<span class="title function_">clear</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出一个单例事件总线</span></span><br><span class="line"><span class="keyword">const</span> eventBus = <span class="keyword">new</span> <span class="title class_">EventBus</span>();</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> eventBus;</span><br></pre></td></tr></table></figure><h2 id="4-使用方法"><a href="#4-使用方法" class="headerlink" title="4. 使用方法"></a>4. 使用方法</h2><h3 id="4-1-注册事件监听器"><a href="#4-1-注册事件监听器" class="headerlink" title="4.1 注册事件监听器"></a>4.1 注册事件监听器</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> eventBus <span class="keyword">from</span> <span class="string">&#x27;./eventBus&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册一个事件监听器</span></span><br><span class="line">eventBus.<span class="title function_">on</span>(<span class="string">&#x27;userLoggedIn&#x27;</span>, <span class="function">(<span class="params">user</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`用户 <span class="subst">$&#123;user.name&#125;</span> 已登录`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="4-2-触发事件"><a href="#4-2-触发事件" class="headerlink" title="4.2 触发事件"></a>4.2 触发事件</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 触发 &#x27;userLoggedIn&#x27; 事件</span></span><br><span class="line">eventBus.<span class="title function_">emit</span>(<span class="string">&#x27;userLoggedIn&#x27;</span>, &#123; <span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span> &#125;);</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户 Alice 已登录</span><br></pre></td></tr></table></figure><h3 id="4-3-取消事件监听"><a href="#4-3-取消事件监听" class="headerlink" title="4.3 取消事件监听"></a>4.3 取消事件监听</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">onUserLoggedOut</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;用户已登出&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册并取消监听器</span></span><br><span class="line">eventBus.<span class="title function_">on</span>(<span class="string">&#x27;userLoggedOut&#x27;</span>, onUserLoggedOut);</span><br><span class="line">eventBus.<span class="title function_">off</span>(<span class="string">&#x27;userLoggedOut&#x27;</span>, onUserLoggedOut);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试触发（不会有任何输出）</span></span><br><span class="line">eventBus.<span class="title function_">emit</span>(<span class="string">&#x27;userLoggedOut&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="4-4-清除所有事件"><a href="#4-4-清除所有事件" class="headerlink" title="4.4 清除所有事件"></a>4.4 清除所有事件</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 清除所有事件监听器</span></span><br><span class="line">eventBus.<span class="title function_">clear</span>();</span><br></pre></td></tr></table></figure><h2 id="5-进阶功能：一次性监听（once）"><a href="#5-进阶功能：一次性监听（once）" class="headerlink" title="5. 进阶功能：一次性监听（once）"></a>5. 进阶功能：一次性监听（once）</h2><p>有时候，我们希望某个监听器只响应一次事件，这可以通过扩展 on 方法来实现。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EventBus</span> &#123;</span><br><span class="line">  <span class="comment">// 省略其他方法...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一次性监听事件</span></span><br><span class="line">  <span class="title function_">once</span>(<span class="params">eventName, listener</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">wrapper</span> = (<span class="params">...args</span>) =&gt; &#123;</span><br><span class="line">      <span class="title function_">listener</span>(...args);</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">off</span>(eventName, wrapper); <span class="comment">// 自动取消监听</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">on</span>(eventName, wrapper);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 once 监听事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">eventBus.<span class="title function_">once</span>(<span class="string">&#x27;dataLoaded&#x27;</span>, <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;数据已加载:&#x27;</span>, data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一次触发会响应</span></span><br><span class="line">eventBus.<span class="title function_">emit</span>(<span class="string">&#x27;dataLoaded&#x27;</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// 输出: 数据已加载: [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二次触发不会响应</span></span><br><span class="line">eventBus.<span class="title function_">emit</span>(<span class="string">&#x27;dataLoaded&#x27;</span>, [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]);</span><br></pre></td></tr></table></figure><h2 id="6-常见应用场景"><a href="#6-常见应用场景" class="headerlink" title="6. 常见应用场景"></a>6. 常见应用场景</h2><ul><li>组件通信：在 React、Vue 等框架中，实现兄弟组件或跨层级组件的通信。</li><li>全局状态管理：用于简易的全局事件通知，比如用户登录、登出事件。</li><li>异步事件处理：监听某些异步任务的状态变更，如网络请求完成或 WebSocket 消息接收。</li><li>解耦模块之间的依赖：减少模块之间的直接调用，提升代码的可维护性。</li></ul><h2 id="7-性能优化与注意事项"><a href="#7-性能优化与注意事项" class="headerlink" title="7. 性能优化与注意事项"></a>7. 性能优化与注意事项</h2><ul><li>内存泄漏：确保在组件销毁或不再需要事件时取消监听器，否则可能导致内存泄漏。</li><li>事件名规范：为事件命名时，建议使用命名空间风格，如 user:login，以防止事件名冲突。</li><li>频繁触发的事件：对于高频事件（如滚动或鼠标移动），可以结合 <strong>节流（throttle）或防抖（debounce）</strong> 来优化性能。</li></ul><h2 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. 总结</h2><p>通过本文的介绍，我们实现了一个简单且高效的事件总线，并展示了它在实际开发中的使用场景。相比于 Redux 等复杂的状态管理库，这种轻量级的事件总线能满足许多日常需求，尤其适用于中小型项目或临时状态共享的场景。</p><p>如果你有更多需求，比如需要持久化事件状态、事件队列等功能，可以在此基础上进一步扩展。</p>]]></content>
      
      
      <categories>
          
          <category> 未分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无标签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是微前端（Micro-Frontend）</title>
      <link href="/posts/20220220222831/"/>
      <url>/posts/20220220222831/</url>
      
        <content type="html"><![CDATA[<p>随着前端项目的复杂度不断提升，传统的单页应用（SPA）架构逐渐暴露出性能瓶颈和团队协作难题。为了解决这些问题，微前端（Micro-Frontend）应运而生。微前端是一种将大型前端应用拆分为多个可独立开发和部署的微型应用的架构理念。本文将介绍微前端的基本概念、核心思想、常见实现方式和优缺点，为你快速入门奠定基础。</p><h2 id="一、微前端的背景和由来"><a href="#一、微前端的背景和由来" class="headerlink" title="一、微前端的背景和由来"></a>一、微前端的背景和由来</h2><p>传统的前端开发以单页应用（SPA）为主流。随着业务复杂度增加，单一代码库会遇到以下问题：</p><ul><li>代码库庞大：单一应用的代码量庞大，构建速度变慢，调试和维护困难。</li><li>协作复杂：多团队协作时容易发生代码冲突，团队之间的开发周期互相依赖。</li><li>技术升级困难：某部分需要升级技术栈时可能影响整个项目。</li></ul><p>微前端借鉴了微服务架构的理念，通过将大型前端项目拆分为多个独立的小型应用来解决这些问题。</p><h2 id="二、什么是微前端？"><a href="#二、什么是微前端？" class="headerlink" title="二、什么是微前端？"></a>二、什么是微前端？</h2><p>微前端是一种将前端应用按功能模块划分为多个独立单元，每个单元称为微应用（Micro App）。这些微应用可以独立开发、测试和部署，但在用户看来，它们协同组成一个完整的网站。</p><p>核心思想：</p><ol><li>独立性：每个微应用可以独立开发、构建和部署，甚至可以采用不同的技术栈。</li><li>松耦合：微应用之间尽量减少依赖，保证彼此独立运行。</li><li>团队自治：不同团队可以负责不同的微应用，减少协作冲突。</li><li>渐进集成：支持逐步从传统应用迁移到微前端架构，避免一次性重构的高风险。</li></ol><h2 id="三、微前端的常见实现方式"><a href="#三、微前端的常见实现方式" class="headerlink" title="三、微前端的常见实现方式"></a>三、微前端的常见实现方式</h2><h3 id="1-基于-iframe-的方式"><a href="#1-基于-iframe-的方式" class="headerlink" title="1. 基于 iframe 的方式"></a>1. 基于 iframe 的方式</h3><ul><li>将不同的微应用嵌入到主应用的页面中。</li><li>优点：隔离性强，不同应用之间不会相互干扰。</li><li>缺点：iframe 的体验较差，SEO 和跨应用通信复杂。</li></ul><h3 id="2-基于路由的分割（主子应用架构）"><a href="#2-基于路由的分割（主子应用架构）" class="headerlink" title="2. 基于路由的分割（主子应用架构）"></a>2. 基于路由的分割（主子应用架构）</h3><ul><li>通过路由系统将不同的路径映射到不同的微应用上。</li><li>场景：用户访问 /dashboard 时加载微应用 A，访问 /profile 时加载微应用 B。</li><li>实现方式：采用 single-spa 等框架，实现多个微应用的动态加载。</li></ul><h3 id="3-模块联邦（Module-Federation）"><a href="#3-模块联邦（Module-Federation）" class="headerlink" title="3. 模块联邦（Module Federation）"></a>3. 模块联邦（Module Federation）</h3><ul><li>利用 Webpack 5 的模块联邦功能，实现微应用之间的模块共享。</li><li>优点：支持在运行时加载远程模块，实现不同应用之间的动态依赖。</li><li>缺点：需要复杂的构建配置和依赖管理。</li></ul><h2 id="四、微前端的优缺点"><a href="#四、微前端的优缺点" class="headerlink" title="四、微前端的优缺点"></a>四、微前端的优缺点</h2><p>优点</p><ul><li>技术栈无关：不同微应用可以使用不同的技术框架（React、Vue、Angular 等）。</li><li>独立部署：每个微应用可以单独更新、部署，减少对其他模块的影响。</li><li>提高协作效率：多个团队可以并行开发不同的微应用，减少代码冲突。</li><li>渐进迁移：支持逐步迁移和重构，降低系统升级风险。</li></ul><p>缺点</p><ul><li>复杂性增加：需要处理微应用之间的通信、状态共享和样式隔离等问题。</li><li>性能开销：加载多个微应用可能增加页面加载时间，需要优化资源管理。</li><li>构建配置繁琐：不同微应用的构建和集成需要复杂的工具链支持。</li></ul><h2 id="五、微前端的应用场景"><a href="#五、微前端的应用场景" class="headerlink" title="五、微前端的应用场景"></a>五、微前端的应用场景</h2><h3 id="1-大型企业级项目"><a href="#1-大型企业级项目" class="headerlink" title="1. 大型企业级项目"></a>1. 大型企业级项目</h3><ul><li>适合具有多个团队合作、业务模块复杂的大型企业项目，如电商平台或企业管理系统。</li></ul><h3 id="2-多品牌或多产品线网站"><a href="#2-多品牌或多产品线网站" class="headerlink" title="2. 多品牌或多产品线网站"></a>2. 多品牌或多产品线网站</h3><ul><li>当一个网站需要支持多个品牌或产品线时，每个品牌可以作为一个独立的微应用。</li></ul><h3 id="3-渐进式重构"><a href="#3-渐进式重构" class="headerlink" title="3. 渐进式重构"></a>3. 渐进式重构</h3><ul><li>在原有单页应用基础上，通过逐步拆分为微应用实现系统的渐进重构。</li></ul><h2 id="六、微前端的框架与工具"><a href="#六、微前端的框架与工具" class="headerlink" title="六、微前端的框架与工具"></a>六、微前端的框架与工具</h2><ul><li>single-spa：一个流行的微前端框架，支持多框架共存和微应用集成。</li><li>qiankun：基于 single-spa 的增强版，适用于企业级应用。</li><li>Webpack Module Federation：用于实现运行时模块共享的强大工具。</li><li>Pirate Ship：一款实验性的微前端开发工具，专注于快速集成。</li></ul><h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>微前端是一种有效解决大型前端项目复杂性和团队协作问题的架构理念。通过将应用拆分为多个独立的微应用，团队可以提高开发效率，并减少部署和升级的风险。然而，微前端也带来了更多的复杂性，需要开发者在应用设计、工具链选择和性能优化上进行合理规划。</p>]]></content>
      
      
      <categories>
          
          <category> 未分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无标签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解防抖与节流</title>
      <link href="/posts/20211120211545/"/>
      <url>/posts/20211120211545/</url>
      
        <content type="html"><![CDATA[<p>在前端开发中，<strong>防抖（Debounce）和节流（Throttle）</strong>是两个优化频繁操作的常用技巧。它们主要用于减少高频率触发的事件处理次数，提升性能。本文将由浅入深地介绍这两者的原理、实现方式及应用场景，并比较它们的异同。</p><h2 id="一、为什么需要防抖与节流？"><a href="#一、为什么需要防抖与节流？" class="headerlink" title="一、为什么需要防抖与节流？"></a>一、为什么需要防抖与节流？</h2><p>在浏览器中，有一些事件会频繁触发，比如：</p><ul><li>窗口 resize、scroll 事件：用户移动滚轮或拖拽窗口时会连续触发。</li><li>输入框 keyup 事件：用户快速输入内容时会在每次按键后触发。</li></ul><p>如果这些事件都直接绑定了处理函数，可能会触发大量不必要的计算，导致页面卡顿或响应迟缓。</p><p>防抖和节流应运而生，帮助我们控制事件触发频率，避免性能瓶颈。</p><h2 id="二、防抖（Debounce）"><a href="#二、防抖（Debounce）" class="headerlink" title="二、防抖（Debounce）"></a>二、防抖（Debounce）</h2><h3 id="1-防抖的定义"><a href="#1-防抖的定义" class="headerlink" title="1. 防抖的定义"></a>1. 防抖的定义</h3><p>防抖的核心是多次触发同一事件时，只执行最后一次。即：事件被触发后，只有在指定时间内没有再次触发，处理函数才会执行。如果事件在等待时间内又触发了，则重新计时。</p><h3 id="2-防抖的实现"><a href="#2-防抖的实现" class="headerlink" title="2. 防抖的实现"></a>2. 防抖的实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">func, delay</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timeout;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timeout);  <span class="comment">// 每次触发时清除之前的计时器</span></span><br><span class="line">    timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      func.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);  <span class="comment">// 最后一次触发后执行</span></span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-应用场景"><a href="#3-应用场景" class="headerlink" title="3. 应用场景"></a>3. 应用场景</h3><ul><li>搜索框：用户输入时避免每次按键都发送请求，只有停止输入一段时间后再进行搜索。</li><li>窗口调整：防止频繁 resize 事件导致页面频繁重绘。</li></ul><h2 id="三、节流（Throttle）"><a href="#三、节流（Throttle）" class="headerlink" title="三、节流（Throttle）"></a>三、节流（Throttle）</h2><h3 id="1-节流的定义"><a href="#1-节流的定义" class="headerlink" title="1. 节流的定义"></a>1. 节流的定义</h3><p>节流的核心是规定在单位时间内只能执行一次，即使在这段时间内事件被多次触发，处理函数也只会按规定间隔执行。</p><h3 id="2-节流的实现"><a href="#2-节流的实现" class="headerlink" title="2. 节流的实现"></a>2. 节流的实现</h3><p>时间戳版</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">func, interval</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> lastTime = <span class="number">0</span>;  </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> now = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">    <span class="keyword">if</span> (now - lastTime &gt;= interval) &#123;</span><br><span class="line">      lastTime = now;</span><br><span class="line">      func.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定时器版</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">func, interval</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timeout;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!timeout) &#123;</span><br><span class="line">      timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        timeout = <span class="literal">null</span>;</span><br><span class="line">        func.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">      &#125;, interval);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-应用场景-1"><a href="#3-应用场景-1" class="headerlink" title="3. 应用场景"></a>3. 应用场景</h3><ul><li>   页面滚动事件：滚动过程中每隔一段时间触发一次，而非每像素移动都触发。</li><li>   按钮防重复点击：避免用户频繁点击按钮导致多次触发请求。</li></ul><h2 id="四、防抖与节流的区别"><a href="#四、防抖与节流的区别" class="headerlink" title="四、防抖与节流的区别"></a>四、防抖与节流的区别</h2><table><thead><tr><th align="center">特性</th><th align="center">防抖(Debounce)</th><th align="center">节流(Throttle)</th></tr></thead><tbody><tr><td align="center">触发方式</td><td align="center">多次触发后只执行最后一次</td><td align="center">每隔固定间隔执行一次</td></tr><tr><td align="center">适合场景</td><td align="center">用户停止频繁操作后执行处理逻辑</td><td align="center">持续执行过程中限制调用频率</td></tr><tr><td align="center">实现方式</td><td align="center">基于计时器</td><td align="center">基于时间戳或定时器</td></tr><tr><td align="center">效果</td><td align="center">避免短时间内的频繁触发</td><td align="center">限制高频操作的处理次数</td></tr></tbody></table><h2 id="五、如何选择？"><a href="#五、如何选择？" class="headerlink" title="五、如何选择？"></a>五、如何选择？</h2><ol><li>用户停止操作后需要进行处理：选用防抖。例如搜索框输入、防止多次提交表单。</li><li>限制操作频率：选用节流。例如页面滚动、窗口大小调整等需要频繁触发的事件。</li></ol><h2 id="六、结合防抖与节流"><a href="#六、结合防抖与节流" class="headerlink" title="六、结合防抖与节流"></a>六、结合防抖与节流</h2><p>在某些复杂场景中，可能需要结合防抖和节流的特点。<br>举例：在页面滚动时进行懒加载时，我们希望：</p><ul><li>滚动时限频触发（节流），减少性能消耗；</li><li>停止滚动后立即处理剩余任务（防抖），确保用户停下后能立刻看到内容。</li></ul><p>可以使用如下方式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounceThrottle</span>(<span class="params">func, delay, interval</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> lastTime = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> timeout;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> now = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (now - lastTime &gt;= interval) &#123;</span><br><span class="line">      lastTime = now;</span><br><span class="line">      func.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">      timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        lastTime = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">        func.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">      &#125;, delay);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>七、总结</p><p>防抖和节流是前端开发中的重要性能优化手段，能有效减少不必要的事件处理。防抖适用于停止操作后的处理逻辑，节流适用于持续操作的限频处理。理解两者的异同与应用场景，能帮助我们编写更加高效的代码。</p>]]></content>
      
      
      <categories>
          
          <category> 未分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无标签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>宏任务、微任务，以及 Vue.js 中的 nextTick</title>
      <link href="/posts/20211116193512/"/>
      <url>/posts/20211116193512/</url>
      
        <content type="html"><![CDATA[<p>在 JavaScript 的异步机制中，“宏任务”（Macro Task）和“微任务”（Micro Task）扮演着非常重要的角色。特别是当我们使用 Vue 2 或 Vue 3 进行前端开发时，nextTick 这个 API 与它们密切相关。本文将由浅入深，带你理解它们的区别，以及 nextTick 在 Vue 中的应用。</p><h2 id="一、宏任务与微任务：事件循环的基础"><a href="#一、宏任务与微任务：事件循环的基础" class="headerlink" title="一、宏任务与微任务：事件循环的基础"></a>一、宏任务与微任务：事件循环的基础</h2><h3 id="1-1-什么是事件循环（Event-Loop）？"><a href="#1-1-什么是事件循环（Event-Loop）？" class="headerlink" title="1.1 什么是事件循环（Event Loop）？"></a>1.1 什么是事件循环（Event Loop）？</h3><p>JavaScript 是一种单线程的语言，意味着同一时间只能执行一段代码。为了解决阻塞问题，JavaScript 引入了事件循环机制，允许任务异步执行。事件循环的主要逻辑是：</p><ol><li>从任务队列中取出一个任务并执行（主线程）。</li><li>如果任务内部产生异步操作（如定时器、Promise），这些任务会被放入不同队列。</li><li>等到当前执行栈为空时，再根据优先级处理这些任务。</li></ol><h3 id="1-2-宏任务-vs-微任务"><a href="#1-2-宏任务-vs-微任务" class="headerlink" title="1.2 宏任务 vs. 微任务"></a>1.2 宏任务 vs. 微任务</h3><p>在事件循环中，任务分为宏任务和微任务两类：</p><p>常见的宏任务（Macro Task）包括：</p><ul><li>setTimeout、setInterval</li><li>DOM 渲染任务</li><li>用户交互事件（如点击、输入）</li></ul><p>宏任务会先进入“任务队列”，等待前面的所有任务执行完毕后，才会进入主线程执行。</p><p>微任务（Micro Task）主要包括：</p><ul><li>Promise.then、queueMicrotask</li><li>MutationObserver（监听 DOM 变化）</li></ul><p>微任务的优先级高于宏任务，在当前宏任务执行完之后，会立刻执行微任务队列中的任务。</p><p>顺序总结：</p><ol><li>一个宏任务执行完毕后，检查所有的微任务并执行它们。</li><li>微任务执行完毕后，事件循环再去执行下一个宏任务。</li></ol><h3 id="1-3-宏任务与微任务的简单示例"><a href="#1-3-宏任务与微任务的简单示例" class="headerlink" title="1.3 宏任务与微任务的简单示例"></a>1.3 宏任务与微任务的简单示例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script start&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;macro task - setTimeout&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;micro task - Promise&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script end&#x27;</span>);</span><br></pre></td></tr></table></figure><p>输出顺序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">script start</span><br><span class="line">script end</span><br><span class="line">micro task - Promise</span><br><span class="line">macro task - setTimeout</span><br></pre></td></tr></table></figure><p>解释：</p><ol><li>console.log(‘script start’) 和 console.log(‘script end’) 属于主线程中的同步任务，按顺序执行。</li><li>setTimeout 的回调是宏任务，放入宏任务队列中。</li><li>Promise.then 是微任务，会在当前宏任务结束后立即执行。</li><li>最后，setTimeout 的回调才会执行。</li></ol><h2 id="二、nextTick-在-Vue-2-和-Vue-3-中的作用"><a href="#二、nextTick-在-Vue-2-和-Vue-3-中的作用" class="headerlink" title="二、nextTick 在 Vue 2 和 Vue 3 中的作用"></a>二、nextTick 在 Vue 2 和 Vue 3 中的作用</h2><p>在 Vue 中，我们经常遇到这样的场景：修改数据后，DOM 并未立刻更新。这是因为 Vue 的响应式更新是异步的。为优化性能，Vue 会在本次事件循环结束后，统一执行所有的 DOM 更新任务。此时，nextTick 就派上了用场。</p><h3 id="2-1-Vue-的异步-DOM-更新"><a href="#2-1-Vue-的异步-DOM-更新" class="headerlink" title="2.1 Vue 的异步 DOM 更新"></a>2.1 Vue 的异步 DOM 更新</h3><p>Vue 会把数据变更后的 DOM 更新任务放入微任务队列中，而不是立即更新。假设我们在修改数据后立即访问 DOM，会发现 DOM 还没有反应过来。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">count</span> = <span class="number">1</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">counter</span>.<span class="property">innerText</span>); <span class="comment">// 可能还是 0</span></span><br></pre></td></tr></table></figure><p>要确保获取到最新的 DOM，需要等待下一次 DOM 更新完成。Vue 提供了 this.$nextTick 来解决这个问题。</p><h2 id="三、Vue-2-和-Vue-3-中的-nextTick-使用"><a href="#三、Vue-2-和-Vue-3-中的-nextTick-使用" class="headerlink" title="三、Vue 2 和 Vue 3 中的 nextTick 使用"></a>三、Vue 2 和 Vue 3 中的 nextTick 使用</h2><h3 id="3-1-Vue-2-的-nextTick"><a href="#3-1-Vue-2-的-nextTick" class="headerlink" title="3.1 Vue 2 的 nextTick"></a>3.1 Vue 2 的 nextTick</h3><p>在 Vue 2 中，this.$nextTick 是一个实例方法，用于等待 DOM 更新完成后执行回调：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">count</span> = <span class="number">1</span>;</span><br><span class="line"><span class="variable language_">this</span>.$nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">counter</span>.<span class="property">innerText</span>); <span class="comment">// 1</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果你需要确保多个数据变更后统一操作 DOM，可以将所有逻辑放在 nextTick 回调中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">count</span> = <span class="number">1</span>;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">msg</span> = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line"><span class="variable language_">this</span>.$nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">counter</span>.<span class="property">innerText</span>); <span class="comment">// 1</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">message</span>.<span class="property">innerText</span>); <span class="comment">// Hello</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="3-2-Vue-3-的-nextTick"><a href="#3-2-Vue-3-的-nextTick" class="headerlink" title="3.2 Vue 3 的 nextTick"></a>3.2 Vue 3 的 nextTick</h3><p>在 Vue 3 中，nextTick 变成了一个顶层导出的函数，不再需要通过实例调用。使用方法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; nextTick &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"></span><br><span class="line">count.<span class="property">value</span> = <span class="number">1</span>;</span><br><span class="line"><span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(counterRef.<span class="property">value</span>.<span class="property">innerText</span>); <span class="comment">// 1</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Vue 3 的 nextTick 在 Composition API 中的使用更加灵活，因为你可以在任何地方调用它，而不需要依赖组件实例。</p><h2 id="四、nextTick-底层原理分析"><a href="#四、nextTick-底层原理分析" class="headerlink" title="四、nextTick 底层原理分析"></a>四、nextTick 底层原理分析</h2><h3 id="4-1-nextTick-的实现：微任务的运用"><a href="#4-1-nextTick-的实现：微任务的运用" class="headerlink" title="4.1 nextTick 的实现：微任务的运用"></a>4.1 nextTick 的实现：微任务的运用</h3><p>Vue 的 nextTick 内部实现非常巧妙，它利用了微任务机制（Promise 或 MutationObserver）来确保回调函数在 DOM 更新后执行。</p><p>Vue 2 的实现简要代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">nextTick</span>(<span class="params">cb</span>) &#123;</span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(cb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Vue 3 的实现会更加复杂：</p><p>Vue 3 内部根据环境决定使用何种微任务，比如优先使用 queueMicrotask，在不支持的环境下降级为 Promise。</p><h3 id="4-2-为什么不直接使用-setTimeout？"><a href="#4-2-为什么不直接使用-setTimeout？" class="headerlink" title="4.2 为什么不直接使用 setTimeout？"></a>4.2 为什么不直接使用 setTimeout？</h3><p>虽然 setTimeout 也可以异步执行任务，但它是宏任务，会导致回调的执行延迟。Vue 选择使用微任务（如 Promise），确保在本轮事件循环内尽快更新 DOM。</p><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><ul><li>宏任务和微任务是 JavaScript 异步机制中的重要概念。微任务优先于宏任务执行。</li><li>Vue 的响应式更新是异步的，为了性能优化，Vue 会将多次数据更新合并到一个微任务中执行。</li><li>nextTick 是 Vue 中用于确保 DOM 更新完成后执行回调的工具。在 Vue 2 中，它是实例方法，而在 Vue 3 中，它变成了顶层导出的函数。</li></ul><p>了解了宏任务、微任务和 nextTick 后，你就能更好地掌握 Vue 的异步更新机制，写出更高效的代码！</p>]]></content>
      
      
      <categories>
          
          <category> 未分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无标签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 支持哪些模块加载方式</title>
      <link href="/posts/20211028211629/"/>
      <url>/posts/20211028211629/</url>
      
        <content type="html"><![CDATA[<p>在 JavaScript 中，导入模块的方式根据使用的模块规范（如 CommonJS、ESM 等）有所不同。下面介绍几种常见的导入方式：</p><h2 id="1-CommonJS-模块导入"><a href="#1-CommonJS-模块导入" class="headerlink" title="1. CommonJS 模块导入"></a>1. CommonJS 模块导入</h2><ul><li>用于 Node.js 环境（也可以在支持的工具中使用，如 Webpack）。</li><li>语法：require</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>); <span class="comment">// 导入 Node 内置模块</span></span><br><span class="line"><span class="keyword">const</span> myModule = <span class="built_in">require</span>(<span class="string">&#x27;./myModule&#x27;</span>); <span class="comment">// 导入本地模块</span></span><br></pre></td></tr></table></figure><ul><li>特性：<ul><li>模块导入是同步的。</li><li>   常用于老版本项目和 Node.js 中。</li></ul></li></ul><h2 id="2-ESM（ECMAScript-Module）导入"><a href="#2-ESM（ECMAScript-Module）导入" class="headerlink" title="2. ESM（ECMAScript Module）导入"></a>2. ESM（ECMAScript Module）导入</h2><ul><li>   原生支持的 ES6 模块系统。现代前端项目和 Node.js (v12+) 支持 ESM。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入默认导出</span></span><br><span class="line"><span class="keyword">import</span> defaultExport <span class="keyword">from</span> <span class="string">&#x27;./myModule.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入命名导出</span></span><br><span class="line"><span class="keyword">import</span> &#123; namedExport1, namedExport2 &#125; <span class="keyword">from</span> <span class="string">&#x27;./myModule.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重命名导入的变量</span></span><br><span class="line"><span class="keyword">import</span> &#123; namedExport <span class="keyword">as</span> alias &#125; <span class="keyword">from</span> <span class="string">&#x27;./myModule.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入所有内容为对象</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> myModule <span class="keyword">from</span> <span class="string">&#x27;./myModule.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态导入</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable language_">module</span> = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">&#x27;./myModule.js&#x27;</span>);</span><br></pre></td></tr></table></figure><ul><li> 特性：<ul><li>   更加模块化，支持 tree-shaking。</li><li>   可与 async/await 配合动态导入。</li></ul></li></ul><h2 id="3-AMD（Asynchronous-Module-Definition）导入"><a href="#3-AMD（Asynchronous-Module-Definition）导入" class="headerlink" title="3. AMD（Asynchronous Module Definition）导入"></a>3. AMD（Asynchronous Module Definition）导入</h2><ul><li>   常见于老的前端工具（如 RequireJS）。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="string">&#x27;./myModule&#x27;</span>], <span class="keyword">function</span> (<span class="params">myModule</span>) &#123;</span><br><span class="line">  <span class="comment">// 模块加载完成后的操作</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li> 特性：<ul><li>   适用于浏览器，支持异步加载模块。</li><li>   不常见于现代项目。</li></ul></li></ul><h2 id="4-UMD（Universal-Module-Definition）导入"><a href="#4-UMD（Universal-Module-Definition）导入" class="headerlink" title="4. UMD（Universal Module Definition）导入"></a>4. UMD（Universal Module Definition）导入</h2><ul><li>   兼容 CommonJS、AMD 和全局变量的模块。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> (<span class="params">root, factory</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">&#x27;function&#x27;</span> &amp;&amp; define.<span class="property">amd</span>) &#123;</span><br><span class="line">    <span class="title function_">define</span>([<span class="string">&#x27;dependency&#x27;</span>], factory); <span class="comment">// AMD</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">module</span> === <span class="string">&#x27;object&#x27;</span> &amp;&amp; <span class="variable language_">module</span>.<span class="property">exports</span>) &#123;</span><br><span class="line">    <span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title function_">factory</span>(<span class="built_in">require</span>(<span class="string">&#x27;dependency&#x27;</span>)); <span class="comment">// CommonJS</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    root.<span class="property">myModule</span> = <span class="title function_">factory</span>(root.<span class="property">dependency</span>); <span class="comment">// 浏览器全局</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;(<span class="variable language_">this</span>, <span class="keyword">function</span> (<span class="params">dependency</span>) &#123;</span><br><span class="line">  <span class="comment">// 模块逻辑</span></span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><ul><li> 特性：<ul><li>   用于需要同时支持多种环境的库。</li></ul></li></ul><h2 id="5-全局变量方式导入"><a href="#5-全局变量方式导入" class="headerlink" title="5. 全局变量方式导入"></a>5. 全局变量方式导入</h2><ul><li>   不使用模块系统，通过 &lt;script&gt; 标签引入脚本。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;myModule.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">myModule</span>); <span class="comment">// 直接访问全局变量</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li> 特性：<ul><li>   适合简单页面，但无法实现模块隔离。</li></ul></li></ul><h2 id="总结：什么时候用哪种导入方式？"><a href="#总结：什么时候用哪种导入方式？" class="headerlink" title="总结：什么时候用哪种导入方式？"></a>总结：什么时候用哪种导入方式？</h2><ul><li>   Node.js：推荐使用 ESM (import)，但 CommonJS (require) 仍然广泛支持。</li><li>   现代前端项目：推荐使用 ESM 导入。</li><li>   老旧项目或浏览器兼容性需求：可能使用 AMD 或 UMD。</li><li>   简单静态页面：直接使用全局变量导入。</li></ul><p>如需在 ESM 和 CommonJS 间兼容，你可能需要配置工具（如 Rollup、Webpack）或添加 .cjs、.mjs 文件后缀来区分模块类型。</p>]]></content>
      
      
      <categories>
          
          <category> 未分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无标签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何区分反向代理和正向代理</title>
      <link href="/posts/20211026095522/"/>
      <url>/posts/20211026095522/</url>
      
        <content type="html"><![CDATA[<p>反向代理和正向代理的主要区别在于它们代理的对象和使用场景不同。</p><p>以下是它们的概念、工作方式和使用场景的详细对比：</p><h2 id="1-反向代理（Reverse-Proxy）"><a href="#1-反向代理（Reverse-Proxy）" class="headerlink" title="1. 反向代理（Reverse Proxy）"></a>1. 反向代理（Reverse Proxy）</h2><p><strong>定义：</strong></p><p>反向代理服务器位于客户端和服务器之间，它代表服务器接收客户端的请求，并将请求转发给真正的后端服务器，然后将服务器的响应返回给客户端。</p><p><strong>工作流程：</strong></p><ol><li>客户端发出请求到代理服务器。</li><li>代理服务器将请求转发给内部的真实服务器。</li><li>真实服务器返回响应给代理服务器。</li><li>代理服务器再将响应返回给客户端。</li></ol><p><strong>典型场景：</strong></p><ul><li>负载均衡：将请求分配到多个后端服务器，减轻单一服务器的压力。</li><li>安全防护：隐藏后端服务器的真实 IP，保护其不受攻击。</li><li>缓存加速：将常用资源缓存在代理服务器上，提高响应速度。</li><li>跨域处理（CORS）：前端开发时，通过反向代理解决跨域问题。</li></ul><p><strong>示例：</strong></p><ul><li>   使用 Nginx 或 Apache 作为反向代理，将请求转发到不同的后端服务器。</li><li>CDN（内容分发网络）也是反向代理的一种，通过代理服务器缓存资源，减少主服务器负载。</li></ul><h2 id="2-正向代理（Forward-Proxy）"><a href="#2-正向代理（Forward-Proxy）" class="headerlink" title="2. 正向代理（Forward Proxy）"></a>2. 正向代理（Forward Proxy）</h2><p><strong>定义：</strong></p><p>正向代理位于客户端和服务器之间，它代表客户端发出请求，将客户端的请求转发给目标服务器，然后将服务器的响应返回给客户端。</p><p><strong>工作流程：</strong></p><ol><li>客户端先向正向代理服务器发送请求。</li><li>代理服务器代表客户端与目标服务器建立连接。</li><li>目标服务器返回响应给代理服务器。</li><li>代理服务器再将响应传回客户端。</li></ol><p><strong>典型场景：</strong></p><ul><li>   访问受限资源：通过代理访问被屏蔽的网站（例如翻墙工具）。</li><li>   隐匿客户端 IP：隐藏用户的真实 IP，提高匿名性和隐私。</li><li>   缓存内容：减少多次访问相同资源的网络消耗。</li><li>   企业内网管理：限制员工访问某些网站或监控上网行为。</li></ul><p><strong>示例：</strong></p><ul><li>   使用 Shadowsocks 或 Squid 实现网络代理访问外网。</li><li>   通过公司内网的代理服务器访问互联网。</li></ul><h2 id="3-反向代理-vs-正向代理：核心区别"><a href="#3-反向代理-vs-正向代理：核心区别" class="headerlink" title="3. 反向代理 vs 正向代理：核心区别"></a>3. 反向代理 vs 正向代理：核心区别</h2><table><thead><tr><th align="center">对比维度</th><th align="center">反向代理</th><th align="center">正向代理</th></tr></thead><tbody><tr><td align="center">代理对象</td><td align="center">服务器（替服务器接收请求）</td><td align="center">客户端（替客户端发出请求）</td></tr><tr><td align="center">客户端感知</td><td align="center">客户端无需知道真实服务器的存在</td><td align="center">目标服务器无需知道客户端的存在</td></tr><tr><td align="center">隐藏的 IP</td><td align="center">隐藏服务器的 IP</td><td align="center">隐藏客户端的 IP</td></tr><tr><td align="center">适用场景</td><td align="center">负载均衡、安全防护、缓存、CORS 处理</td><td align="center">匿名上网、访问受限资源、缓存、企业管控</td></tr><tr><td align="center">典型应用</td><td align="center">Nginx、CDN、API、网关</td><td align="center">Shadowsocks、VPN、公司网络代理</td></tr></tbody></table><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><ul><li>   正向代理更像是客户端的“助手”，帮助客户端访问外部资源，尤其是那些受限或无法直接访问的资源。</li><li>   反向代理更像是服务器的“看门人”，代理服务器替后端服务器处理请求，提供安全性、负载均衡和缓存等服务。</li></ul><p>简而言之：</p><ul><li>   正向代理是“我（客户端）无法直接访问，但通过代理我能去”。</li><li>   反向代理是“你找我（代理服务器）就对了，我帮你转发给正确的后端服务器”。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 未分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无标签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文彻底搞懂 CORS 及常见开发调试的解决方案</title>
      <link href="/posts/20211025192521/"/>
      <url>/posts/20211025192521/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>你是否在开发前后端分离项目时遇到过 <strong>跨域资源共享 (CORS)</strong> 的报错？<br>比如，明明后端已经返回了数据，前端却弹出一个 <strong>“Access-Control-Allow-Origin”</strong> 的错误。这篇文章将带你深入理解 CORS 的原理，并分享一些常见的开发调试解决方案，帮你在开发过程中游刃有余。</p><h2 id="什么是-CORS？"><a href="#什么是-CORS？" class="headerlink" title="什么是 CORS？"></a>什么是 CORS？</h2><p><strong>CORS</strong>（Cross-Origin Resource Sharing）是一种 <strong>浏览器安全机制</strong>，用于限制来自不同源的请求，以防止潜在的跨站攻击。</p><p>简单来说，**”同源”** 是指：  </p><ul><li><strong>协议</strong>、<strong>域名</strong>、<strong>端口号</strong> 三者相同<br>例如：<code>https://example.com:8080</code> 和 <code>https://example.com:80</code> 因端口号不同，就被视为 <strong>不同源</strong>。</li></ul><p>浏览器对跨源请求的限制，主要是为了保护用户信息。CORS 的出现，允许服务器明确声明哪些跨源请求是允许的，从而控制前端是否可以正常访问这些资源。</p><hr><h2 id="浏览器中的-CORS-行为"><a href="#浏览器中的-CORS-行为" class="headerlink" title="浏览器中的 CORS 行为"></a>浏览器中的 CORS 行为</h2><p>浏览器根据 <strong>HTTP 请求方法</strong> 对跨域请求分为两类：</p><ol><li><strong>简单请求 (Simple Request)</strong>  </li><li><strong>预检请求 (Preflight Request)</strong>  </li></ol><h3 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h3><p>如果满足以下条件，浏览器会直接发送请求：</p><ul><li>请求方法是 <code>GET</code>、<code>POST</code> 或 <code>HEAD</code>。</li><li>请求头是<strong>简单头</strong>：如 <code>Accept</code>、<code>Content-Type: text/plain</code> 等。</li><li>没有使用复杂的自定义头。</li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;https://api.example.com/data&#x27;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> response.<span class="title function_">json</span>())</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(data))</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;CORS 错误:&#x27;</span>, error));</span><br></pre></td></tr></table></figure><p>如果服务器允许这个跨域请求，响应头中会包含如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: *</span><br></pre></td></tr></table></figure><p>* 表示允许任何来源的请求访问资源。</p><h3 id="预检请求"><a href="#预检请求" class="headerlink" title="预检请求"></a>预检请求</h3><p>对于复杂请求（如 PUT、DELETE 或带有自定义头的请求），浏览器会在发送请求前，先发起一个 OPTIONS 请求，这就是 预检请求。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;https://api.example.com/data&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">  <span class="attr">headers</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;X-Custom-Header&#x27;</span>: <span class="string">&#x27;foobar&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">body</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span> &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>预检请求的目的是询问服务器：</p><p>“这个请求可以发送吗？如果可以，我该如何发送？”</p><p><strong>响应示例：</strong></p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">204</span> No Content</span><br><span class="line"><span class="attribute">Access-Control-Allow-Origin</span><span class="punctuation">: </span>https://myfrontend.com</span><br><span class="line"><span class="attribute">Access-Control-Allow-Methods</span><span class="punctuation">: </span>POST, OPTIONS</span><br><span class="line"><span class="attribute">Access-Control-Allow-Headers</span><span class="punctuation">: </span>X-Custom-Header</span><br></pre></td></tr></table></figure><h2 id="CORS-常见错误及解决方案"><a href="#CORS-常见错误及解决方案" class="headerlink" title="CORS 常见错误及解决方案"></a>CORS 常见错误及解决方案</h2><h3 id="错误-1：No-‘Access-Control-Allow-Origin’-header-is-present"><a href="#错误-1：No-‘Access-Control-Allow-Origin’-header-is-present" class="headerlink" title="错误 1：No ‘Access-Control-Allow-Origin’ header is present"></a>错误 1：No ‘Access-Control-Allow-Origin’ header is present</h3><p>这是最常见的错误，表示服务器没有返回 Access-Control-Allow-Origin 头。</p><p><strong>解决方案：</strong></p><p>在服务器端增加响应头：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Node.js 示例</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;*&#x27;</span>); <span class="comment">// 允许所有来源</span></span><br><span class="line">  <span class="title function_">next</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/data&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.<span class="title function_">json</span>(&#123; <span class="attr">message</span>: <span class="string">&#x27;Hello, CORS!&#x27;</span> &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>, <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Server running on port 3000&#x27;</span>));</span><br></pre></td></tr></table></figure><p>注意：生产环境中尽量不要使用 *，而是指定具体的来源，避免安全隐患。</p><h3 id="错误-2：CORS-Preflight-Did-Not-Succeed"><a href="#错误-2：CORS-Preflight-Did-Not-Succeed" class="headerlink" title="错误 2：CORS Preflight Did Not Succeed"></a>错误 2：CORS Preflight Did Not Succeed</h3><p>这是由于 <strong>预检请求</strong> 被服务器拒绝。</p><p><strong>解决方案：</strong></p><p>确保服务器正确处理 OPTIONS 请求：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">options</span>(<span class="string">&#x27;/data&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;https://myfrontend.com&#x27;</span>);</span><br><span class="line">  res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Methods&#x27;</span>, <span class="string">&#x27;POST, OPTIONS&#x27;</span>);</span><br><span class="line">  res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>, <span class="string">&#x27;X-Custom-Header&#x27;</span>);</span><br><span class="line">  res.<span class="title function_">sendStatus</span>(<span class="number">204</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果使用 NGINX 代理服务，可以配置：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> /api/ &#123;</span><br><span class="line">    <span class="attribute">if</span> (<span class="variable">$request_method</span> = OPTIONS) &#123;</span><br><span class="line">        <span class="attribute">add_header</span> <span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span> <span class="string">&#x27;https://myfrontend.com&#x27;</span>;</span><br><span class="line">        <span class="attribute">add_header</span> <span class="string">&#x27;Access-Control-Allow-Methods&#x27;</span> <span class="string">&#x27;GET, POST, OPTIONS&#x27;</span>;</span><br><span class="line">        <span class="attribute">add_header</span> <span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span> <span class="string">&#x27;X-Custom-Header&#x27;</span>;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">204</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何在开发环境中绕过-CORS？"><a href="#如何在开发环境中绕过-CORS？" class="headerlink" title="如何在开发环境中绕过 CORS？"></a>如何在开发环境中绕过 CORS？</h2><p>在开发过程中，为了快速调试，你可以采用以下方法：</p><h3 id="方法-1：使用-Chrome-禁用-CORS-检查"><a href="#方法-1：使用-Chrome-禁用-CORS-检查" class="headerlink" title="方法 1：使用 Chrome 禁用 CORS 检查"></a>方法 1：使用 Chrome 禁用 CORS 检查</h3><p>你可以通过命令行启动 Chrome，禁用 CORS 检查：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open -na <span class="string">&quot;Google Chrome&quot;</span> --args --disable-web-security --user-data-dir=/tmp/cors</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 此方法仅适用于开发环境，不要在生产环境中使用。</p><h3 id="方法-2：使用代理服务器"><a href="#方法-2：使用代理服务器" class="headerlink" title="方法 2：使用代理服务器"></a>方法 2：使用代理服务器</h3><p>你可以通过前端设置 反向代理，将跨域请求转发到同源服务器。例如，在本地的 webpack 中配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="attr">proxy</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;/api&#x27;</span>: &#123;</span><br><span class="line">        <span class="attr">target</span>: <span class="string">&#x27;https://api.example.com&#x27;</span>,</span><br><span class="line">        <span class="attr">changeOrigin</span>: <span class="literal">true</span>, <span class="comment">// 解决跨域问题</span></span><br><span class="line">        <span class="attr">pathRewrite</span>: &#123; <span class="string">&#x27;^/api&#x27;</span>: <span class="string">&#x27;&#x27;</span> &#125;, <span class="comment">// 重写路径，将 /api 去掉</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>使用说明：</strong></p><ol><li>上述配置将前端发往 /api 的请求代理到 <a href="https://api.example.com./">https://api.example.com。</a></li><li>changeOrigin: true 可以伪造请求来源，避免目标服务器拒绝求。</li><li>pathRewrite 将匹配到的 /api 前缀去掉，保证请求路径正确射。</li></ol><h3 id="方法-3：安装-CORS-浏览器插件"><a href="#方法-3：安装-CORS-浏览器插件" class="headerlink" title="方法 3：安装 CORS 浏览器插件"></a>方法 3：安装 CORS 浏览器插件</h3><p>一些浏览器插件可以绕过 CORS 检查，例如 CORS Unblock。虽然方便，但这种方法存在安全风险，建议慎用。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>CORS 是现代 Web 开发中的重要机制，它帮助浏览器保护用户数据的安全。理解其工作原理并合理配置服务器，可以有效避免开发中的跨域问题。</p><p>总结一下，我们可以：</p><ol><li>在服务器端设置 Access-Control-Allow-Origin 响应头。</li><li>正确处理 预检请求，避免 CORS 请求被拒绝。</li><li>在开发环境中使用代理或临时禁用 CORS 检查，提升调试效率。</li></ol><p>希望这篇文章能帮助你彻底搞懂 CORS，并在开发过程中得心应手。如果你遇到其他跨域问题，欢迎在评论区交流！</p>]]></content>
      
      
      <categories>
          
          <category> 未分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无标签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>script元素脚本加载详解</title>
      <link href="/posts/20210320215035/"/>
      <url>/posts/20210320215035/</url>
      
        <content type="html"><![CDATA[<blockquote><p>我们知道，将 JavaScript 插入 HTML 的主要方法是使用 <code>&lt;script&gt;</code> 元素。这个元素是由网景公司创造出来，并最早在 Netscape Navigator 2 中实现的。后来，这个元素被正式加入到 HTML 规范。</p><p>为了更好地了解 JavaScript 在 HTML 中的加载情况，我们先简单介绍一些基础知识。</p></blockquote><p><code>&lt;script&gt;</code> 元素有下列 8 个属性：</p><ul><li><strong><code>async</code></strong> : 可选。表示应该立即开始下载脚本，但不能组织其他页面动作，比如下载资源或等待其他脚本加载。只对外部脚本文件有效。</li><li><code>charset</code> : 可选。使用 <code>src</code> 属性指定的代码字符集。这个属性很少使用，因为大多数浏览器不在乎它的值。</li><li><code>crossorigin</code> : 可选。配置相关请求 CORS（跨域资源共享）设置。默认不适用 CORS。crossorigin=”anonymous” 配置文件请求不必设置凭据标志。</li><li><strong><code>defer</code></strong> : 可选。表示脚本可以延迟到文档完全被解析和显示之后再执行。只对外部脚本文件有效。在 IE7 及更早的版本中，对行内脚本也可以指定这个属性。</li><li><code>integrity</code> : 可选。允许比对接收到和指定的加密签名以验证子资源完整性（SRI，Subresource Integrity）。如果接收到的资源的签名与这个属性指定的签名不匹配，则页面会报错，脚本不会执行。这个属性可以用于确保内容分发网络（CDN，Content Delivery Network）不会提供恶意内容。</li><li><code>language</code> : 废弃。最初用于表示代码块中的脚本语言（如“JavaScript”、“JavaScript 1.2”或“VBScript”）。大多数浏览器都会忽略这个属性，不应该再使用它。</li><li><strong><code>src</code></strong> : 可选。表示包含要执行的代码的外部文件。</li><li><code>type</code> : 可选。代替 <code>language</code>，表示代码块中脚本语言的内容类型（也称 MIME 类型）。按照惯例，这个值始终都是 <code>text/javascript</code> ，尽管 <code>text/javascript</code> 和 <code>ecmascript</code> 都已经废弃了。JavaScript 文件的 MIME 类型通常是 <code>application/x-javascript</code> ，不过给 <code>type</code> 属性这个值有可能 <strong>导致脚本被忽略</strong>。在非 IE 的浏览器中有效的其他值还有 <code>application/javascript</code> 和 <code>application/ecmascript</code> 。如果这个是 <strong><code>module</code></strong> ，则代码会被当成 ES6 模块，而且只有这时候代码中才能出现 <strong><code>import</code></strong> 和 <strong><code>export</code></strong> 关键字。</li></ul><h2 id="外部-JavaScript-的加载与解释"><a href="#外部-JavaScript-的加载与解释" class="headerlink" title="外部 JavaScript 的加载与解释"></a>外部 JavaScript 的加载与解释</h2><p>使用 <code>src</code> 属性解析外部资源时，会向 <code>src</code> 属性指定的路径发送一个 GET 请求，以取得相应资源，假定是一个 JavaScript 文件。这个初始的请求不受浏览器同源策略限制，但返回并执行的 JavaScript 则受限制。当然，这个请求仍然受父页面 HTTP/HTTPS 协议的限制。</p><p>默认状态下，浏览器会按照 <code>&lt;script&gt;</code> 在页面中出现的顺序依次解释它们，前提是它们没有使用 <code>defer</code> 和 <code>async</code> 属性。第二个 <code>&lt;script&gt;</code> 元素的代码必须在第一个 <code>&lt;script&gt;</code> 元素的代码解释完毕才能开始解释，第三个则必须等第二个解释完，以此类推。</p><h2 id="标签位置"><a href="#标签位置" class="headerlink" title="标签位置"></a>标签位置</h2><p>过去，所有 <code>&lt;script</code> 元素都被放在页面的 <code>&lt;head&gt;</code> 标签内，如下面的例子所示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;example11.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;example12.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 这里是页面内容 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这种做法的主要目的是把外部的 CSS 和 JavaScript 文件都集中放到一起。不过，把所有 JavaScript 文件都放在 <code>&lt;head&gt;</code> 里，也就意味着必须把所有 JavaScript 代码都下载、解析和解释完成后，才能开始渲染页面（页面在浏览器解析到 <code>&lt;body&gt;</code> 的起始标签时开始渲染）。对于需要很多 JavaScript 的页面，这会导致页面渲染的明显延迟，在此期间浏览器窗口完全空白。未解决这个问题，现代 Web 应用程序通常将所有 JavaScript 引用放在 <code>&lt;body&gt;</code> 元素中的页面内容后面，如下面的例子所示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 这里是页面内容 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;example11.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;example12.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样一来，页面会在处理 JavaScript 代码之前完全渲染页面。用户会感觉页面加载更快了，因为浏览器显示空白页面的时间短了。</p><h2 id="推迟脚本执行（defer）"><a href="#推迟脚本执行（defer）" class="headerlink" title="推迟脚本执行（defer）"></a>推迟脚本执行（defer）</h2><p>HTML 4.01 为 <code>&lt;script&gt;</code> 元素定义了一个叫 <code>defer</code> 的属性。这个属性表示脚本在执行的时候不会改变页面的结构。也就是说，脚本会被延迟到整个页面都解析完毕后再运行。因此，在 <code>&lt;script&gt;</code> 元素上设置 <code>defer</code> 属性，相当于告诉浏览器立即下载，但延迟执行。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">&quot;example11.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">&quot;example12.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 这里是页面内容 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>虽然这个例子中的 <code>&lt;script&gt;</code> 元素包含在页面的 <code>&lt;head&gt;</code> 中，但它们会在浏览器解析到结束的 <code>&lt;/html&gt;</code> 标签后才会执行。HTML5 规范要求脚本应该按照它们出现的顺序执行，因此第一个推迟的脚本会在第二个推迟的脚本之前执行，而且两者会在 DOMContentLoaded 事件之前执行。不过在实际当中，推迟执行的脚本不一定总会按顺序执行或者在 DOMContentLoaded 事件之前执行，因此最好只包含一个这样的脚本。</p><h2 id="异步执行脚本（async）"><a href="#异步执行脚本（async）" class="headerlink" title="异步执行脚本（async）"></a>异步执行脚本（async）</h2><p>HTML5 为 <code>&lt;script&gt;</code> 元素定义了 <code>async</code> 属性。从改变脚本处理方式上看，<code>async</code> 属性与 <code>defer</code> 类似。当然，它们两者也都只适用于外部脚本，都会告诉浏览器立即开始下载。不过，与 <code>defer</code> 不同的是，标记为 <code>async</code> 的脚本并不保证能按照它们出现的次序执行，比如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">&quot;example11.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">&quot;example12.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 这里是页面内容 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在这个例子中，第二个脚本可能先于第一个脚本执行。因此，重点在于它们之间没有依赖关系。给脚本添加 <code>async</code> 属性的目的是告诉浏览器，不必等脚本下载和执行完后再加载页面，同样也不必等到该一步脚本下载和执行后再加载其他脚本。正因为如此，异步脚本不应该在加载期间修改 DOM。</p><p>异步脚本保证会在页面的 load 事件前执行，但可能会在 DOMContentLoaded 之后或之前。</p><h2 id="脚本加载时机对比"><a href="#脚本加载时机对比" class="headerlink" title="脚本加载时机对比"></a>脚本加载时机对比</h2><p><img src="/posts/20210320215035/script%E8%84%9A%E6%9C%AC%E5%8A%A0%E8%BD%BD%E6%97%B6%E6%9C%BA.png" class="lazyload" data-srcset="/posts/20210320215035/script%E8%84%9A%E6%9C%AC%E5%8A%A0%E8%BD%BD%E6%97%B6%E6%9C%BA.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="script脚本加载时机"></p><p>我们上一张图👆</p><blockquote><ul><li><p>绿色 parser：指的是 HTML 引擎的解析，解析 HTML 文本的解析器</p></li><li><p>蓝色 fetch：代表的是获取脚本资源</p></li><li><p>红色 execution：代表的脚本的执行</p></li></ul></blockquote><h3 id="默认情况下"><a href="#默认情况下" class="headerlink" title="默认情况下"></a>默认情况下</h3><p>默认情况下，脚本的加载和解析执行，会中断 HTML 文本的解析。</p><p>这是由于，由于 JS 解析引擎 和 浏览器渲染引擎，是互斥的，JS 在解析执行过程中，GUI渲染线程会被挂起（渲染的当前状态会被保存）。当 JS 执行结束后，渲染线程才会继续。</p><h3 id="使用-defer-属性时"><a href="#使用-defer-属性时" class="headerlink" title="使用 defer 属性时"></a>使用 defer 属性时</h3><p>使用 <code>defer</code> 属性，脚本的获取加载过程不会中断 HTML 文本的解析，而是通过异步的方式获取脚本。但是，此时脚本的解析执行，仍然要等到 HTML 文本的解析结束后。</p><h3 id="使用-async-属性时"><a href="#使用-async-属性时" class="headerlink" title="使用 async 属性时"></a>使用 async 属性时</h3><p>使用 <code>async</code> 属性时，与 <code>defer</code> 相似的是，脚本的加载同样是异步的方式，不同的是，脚本的解析执行不依赖 HTML 文档的解析结束，脚本会在加载完成后立即解析执行，且这时候会中断 HTML 文本的解析。</p><h3 id="针对-type-”module”-的加载执行"><a href="#针对-type-”module”-的加载执行" class="headerlink" title="针对 type=”module” 的加载执行"></a>针对 type=”module” 的加载执行</h3><p>上面的基础知识部分提到，使用 <code>type=&quot;module&quot;</code> 标记的 <code>&lt;script&gt;</code> 元素，代码会被当成 ES6 模块。</p><p>这时候脚本的加载和执行逻辑默认和 <code>defer</code> 属性标记时的规则是一致的，当遇到 <code>&lt;script&gt;</code> 标签元素时，脚本会从模块入口异步开始加载，过程中可能会分叉去加载引用的其他脚本，最后回到入口模块，整个加载过程不会中断 HTML 文本的解析。而脚本的解析执行则像加了 <code>defer</code> 属性一样，需要等待 HTML 文本解析结束后才能开始。</p><p>若 使用 <code>type=&quot;module&quot;</code> 时，同时使用 <code>async</code> 属性，那么脚本的解析执行会在加载完成后立即进行，且解析执行过程会中断 HTML 文本的解析。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们知道 <code>&lt;script&gt;</code> 标签是在网页中使用 JavaScript 的最根本的机制，所以，对这些加载时机和各种属性的理解，对我们将来做性能优化和提升脚本的安全性是非常重要的。</p>]]></content>
      
      
      <categories>
          
          <category> 未分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无标签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一种适合小团队的Git协作流程</title>
      <link href="/posts/20210313223731/"/>
      <url>/posts/20210313223731/</url>
      
        <content type="html"><![CDATA[<blockquote><p>团队开发中，遵循一个合理、清晰的Git使用流程，是非常重要的</p><p>否则，每个人都提交一堆杂乱无章的commit，项目很快就会变得难以协调和维护</p></blockquote><h3 id="分支介绍"><a href="#分支介绍" class="headerlink" title="分支介绍"></a>分支介绍</h3><ol><li><strong>master - 主分支</strong><ul><li>所有提供给用户使用的正式版本，都在这个主分支上发布</li><li>开发者在此分支 <strong>不可进行 <code>push</code> 操作</strong></li></ul></li><li><strong>dev - 开发分支</strong><ul><li>日常开发所使用的分支，开发者完成的阶段性功能模块将首先被合并到此分支</li><li>此分支亦是团队内部测试、阶段性工作验证所使用的分支</li><li>开发者在此分支 <strong>不可进行 <code>push</code> 操作</strong>，只能通过 <strong>Pull Request</strong> 的方式将个人分支合并到此分支</li><li>开发过程中，要经常与此分支保持同步</li></ul></li><li><strong>feature/xxx - 特性分支</strong><ul><li>用于某个功能模块的开发，例如：张三创建了一个 <code>feature/package-manager</code> 分支负责开发包管理器模块</li><li>当该功能模块开发任务完成后，通过 <strong>Pull Request</strong> 的形式进行请求合并，管理员 <strong>Code Review</strong> 通过后，将该分支合并到 <code>dev</code> 分支；此后，该分支将被删除</li><li>一旦完成开发，它们就会被合并进 <code>dev</code> 分支<strong>（仅能通过 Pull Request 的方式）</strong>，然后被删除</li><li>此类分支由开发者个人管理和使用， <strong>可以进行 <code>push</code> 操作</strong></li><li>开发过程中，此类分支要经常与 <code>dev</code> 分支保持同步</li></ul></li><li><strong>hotfix/xxx - 补丁分支</strong><ul><li>用于紧急修复 Bug 的分支，可以由 <code>master</code> 或 <code>dev</code> 分支创建</li><li>同 <code>feature/xxx</code> 分支一样，一旦修复工作完成，它们就会被合并进 <code>master</code> 或 <code>dev</code> 分支 <strong>（仅能通过 Pull Request 的方式）</strong>，然后就被删除</li></ul></li></ol><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开发前克隆 dev 分支到本地</span></span><br><span class="line">git clone -b dev https://github.com/liangpengyv/vue-mvvm.git</span><br></pre></td></tr></table></figure><h4 id="第一步：新建分支"><a href="#第一步：新建分支" class="headerlink" title="第一步：新建分支"></a>第一步：新建分支</h4><p>首先，每次开发新功能，都应该新建一个单独的分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取 dev 分支最新代码</span></span><br><span class="line">git checkout dev</span><br><span class="line">git pull</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">新建一个特性分支</span></span><br><span class="line">git branch feature/xxx</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切换到该特性分支，进行开发</span></span><br><span class="line">git checkout feature/xxx</span><br></pre></td></tr></table></figure><h4 id="第二部：提交分支"><a href="#第二部：提交分支" class="headerlink" title="第二部：提交分支"></a>第二部：提交分支</h4><p>分支修改后，就可以提交了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">提交代码</span></span><br><span class="line">git add .</span><br><span class="line">git commit</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开发过程中，将本地仓库开发中的特性分支 push 到远程仓库（可选的）</span></span><br><span class="line">git push -u origin feature/xxx</span><br></pre></td></tr></table></figure><p><code>git push</code> 的 <code>-u</code> 参数，表示将远程仓库 <code>origin/feature/xxx</code> 与 本地仓库 <code>feature/xxx</code> 建立关联，下一次执行 <code>push</code> 命令，可省略后面的远程仓库名和分支名，直接输入 <code>git push</code> 即可</p><h4 id="第三步：与-dev-主干同步"><a href="#第三步：与-dev-主干同步" class="headerlink" title="第三步：与 dev 主干同步"></a>第三步：与 dev 主干同步</h4><p>分支的开发过程中，要经常与 <code>dev</code> 主干保持同步</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取 dev 分支最新代码</span></span><br><span class="line">git checkout dev</span><br><span class="line">git pull</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切换回当前开发的特性分支</span></span><br><span class="line">git checkout feature/xxx</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">合并 dev 分支到当前分支</span></span><br><span class="line">git merge dev</span><br></pre></td></tr></table></figure><h4 id="第四步：发出-Pull-Request"><a href="#第四步：发出-Pull-Request" class="headerlink" title="第四步：发出 Pull Request"></a>第四步：发出 Pull Request</h4><p>完成当前特性分支的所有开发任务，进行最后一次 <strong>与 dev 主干同步</strong> 工作，并提交到远程仓库以后，就可以发出 <strong>Pull Request 到 dev 分支</strong>，然后请求管理员进行 <strong>Code Review</strong> ，确认可以合并到 <code>dev</code> 分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">最后进行一次步骤三的同步工作</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">提交到远程仓库</span></span><br><span class="line">git checkout feature/xxx</span><br><span class="line">git push origin feature/xxx</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在 GitHub 管理界面创建 Pull Request，等待管理员进行 Code Review</span></span><br></pre></td></tr></table></figure><h4 id="第五步：清理无用的分支"><a href="#第五步：清理无用的分支" class="headerlink" title="第五步：清理无用的分支"></a>第五步：清理无用的分支</h4><p>某个特性分支开发任务全部完成后，应删除它</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">首先，切换回 dev 分支</span></span><br><span class="line">git checkout dev</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">先删除远程特性分支</span></span><br><span class="line">git push origin -d feature/xxx</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">再删除本地特性分支</span></span><br><span class="line">git branch -d feature/xxx</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 未分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无标签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue的双向绑定原理及简单实现</title>
      <link href="/posts/20210306094502/"/>
      <url>/posts/20210306094502/</url>
      
        <content type="html"><![CDATA[<h2 id="Vue-数据双向绑定原理"><a href="#Vue-数据双向绑定原理" class="headerlink" title="Vue 数据双向绑定原理"></a>Vue 数据双向绑定原理</h2><p>Vue 数据双向绑定是通过 <strong>数据劫持</strong> 结合 <strong>发布者-订阅者模式</strong> 的方式来实现的。</p><p>我们先来看下定义在 Vue 初始化数据上的对象是什么样的</p><p><strong>代码：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">obj</span>: &#123;</span><br><span class="line">      <span class="attr">foo</span>: <span class="number">1</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">obj</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><p><img src="/posts/20210306094502/Vue-data%E7%BB%93%E6%9E%84.png" class="lazyload" data-srcset="/posts/20210306094502/Vue-data%E7%BB%93%E6%9E%84.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="Vue-data结构"></p><p>可以看到属性 <code>foo</code> 有两个对应的 <code>get</code> 和 <code>set</code> 方法，这两个方法是如何出现的呢？这是因为 Vue 通过 <code>Object.defineProperty()</code> 来实现数据劫持的，它可以控制对象属性的一些特有操作，如读写权限、是否可枚举等，这里着重关注 <code>get</code> 和 <code>set</code> 两个函数。（有关 <code>Object.defineProperty()</code> 的更多内容，请点击 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">👆MDN-Object.defineProperty</a>）</p><p>首先，我们使用字面量形式初始化一个对象属性</p><p><strong>代码：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> book = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;JavaScript高级程序设计&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(book.<span class="property">name</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(book)</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><p><img src="/posts/20210306094502/JavaScript%E5%AF%B9%E8%B1%A1.png" class="lazyload" data-srcset="/posts/20210306094502/JavaScript%E5%AF%B9%E8%B1%A1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="JavaScript对象"></p><p>我们重新使用 <code>Object.defineProperty()</code> 的方式来定义对象属性，并对其 <code>get</code> 和 <code>set</code> 方法进行重写操作</p><p><strong>代码：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> book = &#123;&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(book, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">get</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;《&#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&#x27;》&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">set</span>: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = value</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;设置 name 属性值为：&#x27;</span> + value)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">book.<span class="property">name</span> = <span class="string">&#x27;JavaScript高级程序设计&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(book.<span class="property">name</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(book)</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><p><img src="/posts/20210306094502/%E7%9B%91%E5%90%AC%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7.png" class="lazyload" data-srcset="/posts/20210306094502/%E7%9B%91%E5%90%AC%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="监听对象属性"></p><p>可以看到，这次打印出来的数据，和通过 Vue 初始化的数据结构比较像了吧，它也有了 <code>get</code> 和 <code>set</code> 函数，这正是 Vue 实现 <strong>数据劫持</strong> 的实现原理。</p><h2 id="MVVM-实现思路分析"><a href="#MVVM-实现思路分析" class="headerlink" title="MVVM 实现思路分析"></a>MVVM 实现思路分析</h2><p>实现 MVVM 主要包含两个方面：</p><ul><li>数据变化更新视图</li><li>视图变化更新数据</li></ul><p><img src="/posts/20210306094502/MVVM.png" class="lazyload" data-srcset="/posts/20210306094502/MVVM.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="MVVM"></p><p>其中，view 更新 data 只需要通过事件监听即可，重点是 data 更新 view 是如何做到的呢？</p><p>其实，上文 <strong>数据劫持</strong> 的示例已经给出了答案。通过 <code>Object.defineProperty()</code> 对属性设置一个 set 函数，当数据改变时，set 函数就会被触发，所以我们只需要将更新 view 的方法写到这里，就可以实现 data 更新 view 了。</p><p><img src="/posts/20210306094502/%E6%95%B0%E6%8D%AE%E7%9B%91%E5%90%AC.png" class="lazyload" data-srcset="/posts/20210306094502/%E6%95%B0%E6%8D%AE%E7%9B%91%E5%90%AC.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="数据监听"></p><h2 id="实现一个监听器-Observer"><a href="#实现一个监听器-Observer" class="headerlink" title="实现一个监听器 Observer"></a>实现一个监听器 Observer</h2><p><strong>监听器</strong> 的作用就是去监听数据的每一个属性，通过上面的例子，我们知道可以用 <code>Object.defineProperty()</code> 方法实现。</p><p>当监听到属性值发生变化时，通知 <strong>订阅者 Watcher</strong> 执行更新函数去更新视图。</p><p>这个过程中，会有许多订阅者，所以我们还需要创建一个 <strong>订阅器 Dep</strong> 来统一管理，订阅器 Dep 有一个容器 subs，负责收集订阅者。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">defineReactive</span>(<span class="params">data, key, value</span>) &#123;</span><br><span class="line">    <span class="comment">// 递归遍历所有子属性</span></span><br><span class="line">    <span class="title function_">observe</span>(value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> dep = <span class="keyword">new</span> <span class="title class_">Dep</span>()</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(data, key, &#123;</span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">get</span>: <span class="keyword">function</span> <span class="title function_">reactiveGetter</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="title class_">Dep</span>.<span class="property">target</span>) &#123;</span><br><span class="line">                dep.<span class="title function_">addSub</span>(<span class="title class_">Dep</span>.<span class="property">target</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> value</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">set</span>: <span class="keyword">function</span> <span class="title function_">reactiveSetter</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (value === newValue) &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            value = newValue</span><br><span class="line">            dep.<span class="title function_">notify</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">observe</span>(<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!data || <span class="keyword">typeof</span> data !== <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">keys</span>(data).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">defineReactive</span>(data, key, data[key])</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Dep</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subs</span> = []</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Dep</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">    <span class="title function_">addSub</span>(<span class="params">sub</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">subs</span>.<span class="title function_">push</span>(sub)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">notify</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">subs</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">sub</span> =&gt;</span> &#123;</span><br><span class="line">            sub.<span class="title function_">update</span>()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Dep</span>.<span class="property">target</span> = <span class="literal">null</span></span><br></pre></td></tr></table></figure><h2 id="实现一个订阅者-Watcher"><a href="#实现一个订阅者-Watcher" class="headerlink" title="实现一个订阅者 Watcher"></a>实现一个订阅者 Watcher</h2><p><strong>订阅者 Watcher</strong> 的作用主要是接收属性变化的通知，然后去执行视图更新函数。</p><p>订阅者 Watcher 初始化时，需要将自己添加到订阅器 Dep 中。我们已经知道在监听器 Observer 的 get 函数中通过订阅器 Dep 执行了添加订阅者 Wather 的操作，所以只需要在 Watcher 初始化时触发 Observer 的 get 函数即可。而要触发 get 函数，只要获取对应的属性值便可触发了，这正是因为我们使用了 <code>Object.defineProperty()</code> 进行数据监听。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Watcher</span>(<span class="params">vm, exp, cb</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">vm</span> = vm</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">exp</span> = exp</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cb</span> = cb</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = <span class="variable language_">this</span>.<span class="title function_">get</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Watcher</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">    <span class="title function_">update</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> value = <span class="variable language_">this</span>.<span class="property">vm</span>.<span class="property">$data</span>[<span class="variable language_">this</span>.<span class="property">exp</span>]</span><br><span class="line">        <span class="keyword">const</span> oldValue = <span class="variable language_">this</span>.<span class="property">value</span></span><br><span class="line">        <span class="keyword">if</span> (value !== oldValue) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">value</span> = value</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">cb</span>(value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title class_">Dep</span>.<span class="property">target</span> = <span class="variable language_">this</span></span><br><span class="line">        <span class="keyword">const</span> value = <span class="variable language_">this</span>.<span class="property">vm</span>.<span class="property">$data</span>[<span class="variable language_">this</span>.<span class="property">exp</span>]</span><br><span class="line">        <span class="title class_">Dep</span>.<span class="property">target</span> = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现一个解析器-Compile"><a href="#实现一个解析器-Compile" class="headerlink" title="实现一个解析器 Compile"></a>实现一个解析器 Compile</h2><p><strong>解析器 Compile</strong> 的作用主要有两个方面：</p><ol><li>解析 DOM 节点，识别出模板指令，替换模板数据</li><li>对模板指令的节点添加订阅者，绑定更新函数</li></ol><p>为实现这两点功能，我们有如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Compile</span>(<span class="params">vm</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">vm</span> = vm</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">el</span> = vm.<span class="property">$el</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">fragment</span> = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">init</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Compile</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">    <span class="title function_">init</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">fragment</span> = <span class="variable language_">this</span>.<span class="title function_">nodeToFragment</span>(<span class="variable language_">this</span>.<span class="property">el</span>)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">compileNode</span>(<span class="variable language_">this</span>.<span class="property">fragment</span>)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">el</span>.<span class="title function_">appendChild</span>(<span class="variable language_">this</span>.<span class="property">fragment</span>)</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="title function_">nodeToFragment</span>(<span class="params">el</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> fragment = <span class="variable language_">document</span>.<span class="title function_">createDocumentFragment</span>()</span><br><span class="line">        <span class="keyword">let</span> child = el.<span class="property">firstChild</span></span><br><span class="line">        <span class="keyword">while</span> (child) &#123;</span><br><span class="line">            fragment.<span class="title function_">appendChild</span>(child)</span><br><span class="line">            child = el.<span class="property">firstChild</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fragment</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">compileNode</span>(<span class="params">fragment</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> childNodes = fragment.<span class="property">childNodes</span></span><br><span class="line">        <span class="keyword">const</span> childNodesArray = [...childNodes]</span><br><span class="line">        childNodesArray.<span class="title function_">forEach</span>(<span class="function"><span class="params">node</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">isElementNode</span>(node)) &#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="title function_">compile</span>(node)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> reg = <span class="regexp">/\&#123;\&#123;(.*)\&#125;\&#125;/</span></span><br><span class="line">            <span class="keyword">let</span> text = node.<span class="property">textContent</span></span><br><span class="line">            <span class="keyword">if</span> (reg.<span class="title function_">test</span>(text)) &#123;</span><br><span class="line">                <span class="keyword">let</span> prop = reg.<span class="title function_">exec</span>(text)[<span class="number">1</span>]</span><br><span class="line">                <span class="variable language_">this</span>.<span class="title function_">compileText</span>(node, prop)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (node.<span class="property">childNodes</span> &amp;&amp; node.<span class="property">childNodes</span>.<span class="property">length</span>) &#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="title function_">compileNode</span>(node)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">compile</span>(<span class="params">node</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> nodeAttrs = node.<span class="property">attributes</span></span><br><span class="line">        <span class="keyword">const</span> nodeAttrsArray = [...nodeAttrs]</span><br><span class="line">        nodeAttrsArray.<span class="title function_">forEach</span>(<span class="function"><span class="params">attr</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> name = attr.<span class="property">name</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">isDirective</span>(name)) &#123;</span><br><span class="line">                <span class="keyword">let</span> value = attr.<span class="property">value</span></span><br><span class="line">                <span class="keyword">if</span> (name === <span class="string">&#x27;v-model&#x27;</span>) &#123;</span><br><span class="line">                    <span class="variable language_">this</span>.<span class="title function_">compileModel</span>(node, value)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">compileModel</span>(<span class="params">node, prop</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> val = <span class="variable language_">this</span>.<span class="property">vm</span>.<span class="property">$data</span>[prop]</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">updateModel</span>(node, val)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Watcher</span>(<span class="variable language_">this</span>.<span class="property">vm</span>, prop, <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">updateModel</span>(node, value)</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        node.<span class="title function_">addEventListener</span>(<span class="string">&#x27;input&#x27;</span>, <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> newValue = event.<span class="property">target</span>.<span class="property">value</span></span><br><span class="line">            <span class="keyword">if</span> (val === newValue) &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">vm</span>.<span class="property">$data</span>[prop] = newValue</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">compileText</span>(<span class="params">node, prop</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> text = <span class="variable language_">this</span>.<span class="property">vm</span>.<span class="property">$data</span>[prop]</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">updateView</span>(node, text)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Watcher</span>(<span class="variable language_">this</span>.<span class="property">vm</span>, prop, <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">updateView</span>(node, value)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="title function_">updateModel</span>(<span class="params">node, value</span>) &#123;</span><br><span class="line">        node.<span class="property">value</span> = <span class="keyword">typeof</span> value === <span class="string">&#x27;undefined&#x27;</span> ? <span class="string">&#x27;&#x27;</span> : value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">updateView</span>(<span class="params">node, value</span>) &#123;</span><br><span class="line">        node.<span class="property">textContent</span> = <span class="keyword">typeof</span> value === <span class="string">&#x27;undefined&#x27;</span> ? <span class="string">&#x27;&#x27;</span> : value</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="title function_">isDirective</span>(<span class="params">attr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> attr.<span class="title function_">indexOf</span>(<span class="string">&#x27;v-&#x27;</span>) !== -<span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">isElementNode</span>(<span class="params">node</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> node.<span class="property">nodeType</span> === <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">isTextNode</span>(<span class="params">node</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> node.<span class="property">nodeType</span> === <span class="number">3</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段较长的代码，其核心目的就是实现上面说的 2 点功能。</p><p>其中，在解析 DOM 过程中，因为会频繁操作 DOM，所以这里先将其缓存到一个 fragment 中，然后再进行解析，解析编译完成后，再把 fragment 添加到页面中。</p><p>这里我们只是简单的实现了差值表达式 <code>&#123;&#123;&#125;&#125;</code> 和 <code>v-model</code> 的识别。</p><h2 id="创建-MyVue"><a href="#创建-MyVue" class="headerlink" title="创建 MyVue"></a>创建 MyVue</h2><p>这里我们创建一个 MyVue 类，来连接 Observer、Watcher、Compile。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">MyVue</span>(<span class="params">options</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$el</span> = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(options.<span class="property">el</span>)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$data</span> = options.<span class="property">data</span></span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">init</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">MyVue</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">    <span class="title function_">init</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">proxyData</span>(<span class="variable language_">this</span>)</span><br><span class="line">        <span class="title function_">observe</span>(<span class="variable language_">this</span>.<span class="property">$data</span>)</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Compile</span>(<span class="variable language_">this</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">proxyData</span>(<span class="params">vm</span>) &#123;</span><br><span class="line">        <span class="title class_">Object</span>.<span class="title function_">keys</span>(vm.<span class="property">$data</span>).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(vm, key, &#123;</span><br><span class="line">                <span class="attr">get</span>: <span class="keyword">function</span> <span class="title function_">proxyGetter</span>(<span class="params"></span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> vm.<span class="property">$data</span>[key]</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">set</span>: <span class="keyword">function</span> <span class="title function_">proxySetter</span>(<span class="params">value</span>) &#123;</span><br><span class="line">                    vm.<span class="property">$data</span>[key] = value</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用-MyVue-替换-Vue"><a href="#使用-MyVue-替换-Vue" class="headerlink" title="使用 MyVue 替换 Vue"></a>使用 MyVue 替换 Vue</h2><p>现在，我们使用 MyVue 来替换 Vue 接管我们的视图。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&#x27;name&#x27;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- &lt;script src=&quot;vender/vue.js&quot;&gt;&lt;/script&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/observer.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/watcher.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/compile.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/index.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// let app = new Vue(&#123;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//     el: &#x27;#app&#x27;,</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//     data: &#123;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//         name: &#x27;JavaScript&#x27;,</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//     &#125;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// &#125;)</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// console.log(app)</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> myApp = <span class="keyword">new</span> <span class="title class_">MyVue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">name</span>: <span class="string">&#x27;JavaScript&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(myApp)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/posts/20210306094502/MyVue%E6%BC%94%E7%A4%BA.gif" class="lazyload" data-srcset="/posts/20210306094502/MyVue%E6%BC%94%E7%A4%BA.gif" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="MyVue演示"></p><p>到这里，我们便实现了一个简单的数据双向绑定。</p><h2 id="完整源码"><a href="#完整源码" class="headerlink" title="完整源码"></a>完整源码</h2><p>完整源码请点击 <a href="https://github.com/liangpengyv/vue-mvvm">👆GitHub-vue-mvvm</a> 查看</p>]]></content>
      
      
      <categories>
          
          <category> 未分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无标签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git stash 命令详解</title>
      <link href="/posts/20200912201432/"/>
      <url>/posts/20200912201432/</url>
      
        <content type="html"><![CDATA[<h2 id="1-开篇：啥子是-git-stash？"><a href="#1-开篇：啥子是-git-stash？" class="headerlink" title="1. 开篇：啥子是 git stash？"></a>1. 开篇：啥子是 git stash？</h2><p>你在开发时是不是遇到过这种情况：代码改了一半，突然有个紧急任务来了，比如老板喊你切换到另一个分支修个 Bug。问题来了，你这没提交的代码咋办？提交了怕污染代码库，不提交又不想丢掉。<br>这时候，git stash 就派上用场了！它就像一个临时储物柜，帮你把当前的修改存起来，等你忙完了再拿出来继续干活。</p><h2 id="2-基础用法：怎么存？怎么拿？"><a href="#2-基础用法：怎么存？怎么拿？" class="headerlink" title="2. 基础用法：怎么存？怎么拿？"></a>2. 基础用法：怎么存？怎么拿？</h2><h3 id="（1）存起来：git-stash"><a href="#（1）存起来：git-stash" class="headerlink" title="（1）存起来：git stash"></a>（1）存起来：git stash</h3><p>执行以下命令，就能把当前工作区的修改存到”储物柜”里：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure><p>效果：你的工作区会变得干干净净，就像啥子都没改过一样。</p><h3 id="（2）取出来：git-stash-pop"><a href="#（2）取出来：git-stash-pop" class="headerlink" title="（2）取出来：git stash pop"></a>（2）取出来：git stash pop</h3><p>等你忙完了，回到原来的分支，可以用下面的命令把改动拿回来：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash pop</span><br></pre></td></tr></table></figure><p>效果：储物柜里的东西回来了，而且这条存档就自动删掉了。</p><h3 id="（3）只想看一眼：git-stash-apply"><a href="#（3）只想看一眼：git-stash-apply" class="headerlink" title="（3）只想看一眼：git stash apply"></a>（3）只想看一眼：git stash apply</h3><p>有时候你只是想把改动拿回来看看，但不想删掉储物柜里的存档：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash apply</span><br></pre></td></tr></table></figure><p>区别：存档还在，你可以多次 apply。</p><h2 id="3-深入探索：stash-的更多玩法"><a href="#3-深入探索：stash-的更多玩法" class="headerlink" title="3. 深入探索：stash 的更多玩法"></a>3. 深入探索：stash 的更多玩法</h2><h3 id="（1）查看所有存档：git-stash-list"><a href="#（1）查看所有存档：git-stash-list" class="headerlink" title="（1）查看所有存档：git stash list"></a>（1）查看所有存档：git stash list</h3><p>你可能不止一次用 stash，用这个命令可以列出所有的存档：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash list</span><br></pre></td></tr></table></figure><p>输出可能像这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stash@&#123;0&#125;: WIP on main: 123abc4 修复样式问题</span><br><span class="line">stash@&#123;1&#125;: WIP on feature: 添加用户登录功能</span><br></pre></td></tr></table></figure><p>stash@{0} 是最新的存档，数字越大，说明存的时间越久。</p><h3 id="（2）恢复指定存档：git-stash-apply-stash-n"><a href="#（2）恢复指定存档：git-stash-apply-stash-n" class="headerlink" title="（2）恢复指定存档：git stash apply stash@{n}"></a>（2）恢复指定存档：git stash apply stash@{n}</h3><p>如果你想恢复某个特定的存档，比如 stash@{1}：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash apply stash@&#123;1&#125;</span><br></pre></td></tr></table></figure><h3 id="（3）删掉存档：git-stash-drop"><a href="#（3）删掉存档：git-stash-drop" class="headerlink" title="（3）删掉存档：git stash drop"></a>（3）删掉存档：git stash drop</h3><p>存档用完了或者不需要了，可以用下面的命令删除：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash drop stash@&#123;0&#125;</span><br></pre></td></tr></table></figure><h3 id="（4）全部清理：git-stash-clear"><a href="#（4）全部清理：git-stash-clear" class="headerlink" title="（4）全部清理：git stash clear"></a>（4）全部清理：git stash clear</h3><p>不想一个个删？直接全部清掉：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash clear</span><br></pre></td></tr></table></figure><h2 id="4-进阶用法：部分保存与冲突处理"><a href="#4-进阶用法：部分保存与冲突处理" class="headerlink" title="4. 进阶用法：部分保存与冲突处理"></a>4. 进阶用法：部分保存与冲突处理</h2><h3 id="（1）只保存未跟踪的文件：git-stash-u"><a href="#（1）只保存未跟踪的文件：git-stash-u" class="headerlink" title="（1）只保存未跟踪的文件：git stash -u"></a>（1）只保存未跟踪的文件：git stash -u</h3><p>默认情况下，stash 只保存已跟踪的文件。如果你有些新文件还没 git add，可以用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash -u</span><br></pre></td></tr></table></figure><p>这样连没跟踪的文件也一块存起来。</p><h3 id="（2）解决冲突：stash-pop-也会出问题？"><a href="#（2）解决冲突：stash-pop-也会出问题？" class="headerlink" title="（2）解决冲突：stash pop 也会出问题？"></a>（2）解决冲突：stash pop 也会出问题？</h3><p>如果你在 stash pop 的时候，和当前分支代码有冲突，那 Git 会提示冲突，和 git merge 的冲突处理一样，需要手动修改完再提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改冲突文件后</span></span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;解决冲突&quot;</span></span><br></pre></td></tr></table></figure><h2 id="5-总结：git-stash-的正确姿势"><a href="#5-总结：git-stash-的正确姿势" class="headerlink" title="5. 总结：git stash 的正确姿势"></a>5. 总结：git stash 的正确姿势</h2><ol><li>救急神器：适合临时切换任务、不想提交一半改动的时候用。</li><li>谨慎使用：如果你 stash 太多次而不清理，容易忘记存了啥子。</li><li>配合 pop 和 apply：合理选择是直接删掉存档（pop），还是保留存档（apply）。</li></ol><h2 id="6-结语：工具虽小，管用就行"><a href="#6-结语：工具虽小，管用就行" class="headerlink" title="6. 结语：工具虽小，管用就行"></a>6. 结语：工具虽小，管用就行</h2><p>git stash 这个命令看起简单，但在开发工作中真是个大救星！它让你不再因为各种紧急情况而打乱手头的代码节奏。只要掌握好 stash 的基本用法和一些进阶技巧，你就能更从容地在多个任务之间切换，再也不怕自己的代码乱七八糟了。</p>]]></content>
      
      
      <categories>
          
          <category> 未分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无标签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模拟实现 JavaScript 的 apply call 及 bind 函数</title>
      <link href="/posts/20200604105236/"/>
      <url>/posts/20200604105236/</url>
      
        <content type="html"><![CDATA[<p>在 JavaScript 中，<code>apply</code>、<code>call</code> 和 <code>bind</code> 方法都是为了改变某个函数运行时的上下文（context）而存在的，换句话说，就是为了改变函数体内部 <code>this</code> 的指向。</p><h2 id="改变-this-指向"><a href="#改变-this-指向" class="headerlink" title="改变 this 指向"></a>改变 this 指向</h2><p>我们看下面一段代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;GlobalName&#x27;</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;ObjName&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getName</span>(<span class="params">arg1, arg2</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>, arg1, arg2)  <span class="comment">// 函数内部调用 this</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// this 指向全局对象</span></span><br><span class="line"><span class="title function_">getName</span>(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// 预期输出：GlobalName 1 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 改变 this 指向为 obj</span></span><br><span class="line">getName.<span class="title function_">apply</span>(obj, [<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">getName.<span class="title function_">call</span>(obj, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">getName.<span class="title function_">bind</span>(obj, <span class="number">1</span>, <span class="number">2</span>)()</span><br><span class="line"><span class="comment">// 预期输出：</span></span><br><span class="line"><span class="comment">// ObjName 1 2</span></span><br><span class="line"><span class="comment">// ObjName 1 2</span></span><br><span class="line"><span class="comment">// ObjName 1 2</span></span><br></pre></td></tr></table></figure><p>通过上面一段代码可以看出，我们可以通过 <code>apply</code>、<code>call</code> 和 <code>bind</code> 方法，改变调用 <code>getName()</code> 函数的 <strong>运行时上下文</strong>，从而改变运行时函数内部的 <code>this</code> 指向。</p><h2 id="三个方法的功能区别"><a href="#三个方法的功能区别" class="headerlink" title="三个方法的功能区别"></a>三个方法的功能区别</h2><h3 id="Function-prototype-apply"><a href="#Function-prototype-apply" class="headerlink" title="Function.prototype.apply()"></a>Function.prototype.apply()</h3><p><strong><code>apply()</code></strong> 方法调用一个具有给定<code>this</code>值的函数，以及以一个数组（或<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Indexed_collections#working_with_array-like_objects">类数组对象</a>）的形式提供的参数。</p><h3 id="Function-prototype-call"><a href="#Function-prototype-call" class="headerlink" title="Function.prototype.call()"></a>Function.prototype.call()</h3><p><strong><code>call()</code></strong> 方法使用一个指定的 <code>this</code> 值和单独给出的一个或多个参数来调用一个函数。</p><blockquote><p><strong>注意：</strong>call() 方法的作用和 apply() 方法类似，区别就是 <code>call()</code> 方法接受的是 <strong>参数列表</strong>，而 <code>apply()</code> 方法接受的是 <strong>一个参数数组</strong>。</p></blockquote><h3 id="Function-prototype-bind"><a href="#Function-prototype-bind" class="headerlink" title="Function.prototype.bind()"></a>Function.prototype.bind()</h3><p><strong><code>bind()</code></strong> 方法创建一个新的函数，在 <code>bind()</code> 被调用时，这个新函数的 <code>this</code> 被指定为 <code>bind()</code> 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。</p><blockquote><p><strong>注意：</strong><code>bind()</code> 是返回对应函数，便于稍后调用，<code>apply()</code> 、<code>call()</code> 则是立即调用。</p></blockquote><h2 id="模拟实现-apply、call-及-bind"><a href="#模拟实现-apply、call-及-bind" class="headerlink" title="模拟实现 apply、call 及 bind"></a>模拟实现 apply、call 及 bind</h2><h3 id="实现-myApply"><a href="#实现-myApply" class="headerlink" title="实现 myApply()"></a>实现 myApply()</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现 apply 函数</span></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myApply</span> = <span class="keyword">function</span> (<span class="params">context</span>) &#123;</span><br><span class="line">    <span class="comment">// 判断调用 myApply 的是 function 吗</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;type error&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取参数</span></span><br><span class="line">    <span class="keyword">let</span> args = <span class="variable language_">arguments</span>[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将调用函数设置为对象的方法</span></span><br><span class="line">    context.<span class="property">fn</span> = <span class="variable language_">this</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用函数</span></span><br><span class="line">    <span class="keyword">let</span> result = context.<span class="title function_">fn</span>(...args)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除属性</span></span><br><span class="line">    <span class="keyword">delete</span> context.<span class="property">fn</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line">getName.<span class="title function_">myApply</span>(obj, [<span class="number">1</span>, <span class="number">2</span>])  <span class="comment">// 预期输出：ObjName 1 2</span></span><br></pre></td></tr></table></figure><h3 id="实现-myCall"><a href="#实现-myCall" class="headerlink" title="实现 myCall()"></a>实现 myCall()</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现 call 函数</span></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myCall</span> = <span class="keyword">function</span> (<span class="params">context</span>) &#123;</span><br><span class="line">    <span class="comment">// 判断调用 myCall 的是 function 吗</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;type error&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取参数</span></span><br><span class="line">    <span class="keyword">let</span> args = [...<span class="variable language_">arguments</span>].<span class="title function_">slice</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将调用函数设置为对象的方法</span></span><br><span class="line">    context.<span class="property">fn</span> = <span class="variable language_">this</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用函数</span></span><br><span class="line">    <span class="keyword">let</span> result = context.<span class="title function_">fn</span>(...args)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除属性</span></span><br><span class="line">    <span class="keyword">delete</span> context.<span class="property">fn</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line">getName.<span class="title function_">myCall</span>(obj, <span class="number">1</span>, <span class="number">2</span>)  <span class="comment">// 预期输出：ObjName 1 2</span></span><br></pre></td></tr></table></figure><h3 id="实现-myBind"><a href="#实现-myBind" class="headerlink" title="实现 myBind()"></a>实现 myBind()</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现 bind 函数</span></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myBind</span> = <span class="keyword">function</span> (<span class="params">context</span>) &#123;</span><br><span class="line">    <span class="comment">// 判断 myBind 的是 function 吗</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;type error&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取参数</span></span><br><span class="line">    <span class="keyword">let</span> args = [...<span class="variable language_">arguments</span>].<span class="title function_">slice</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将调用函数暂存</span></span><br><span class="line">    <span class="keyword">let</span> fn = <span class="variable language_">this</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> fn.<span class="title function_">myApply</span>(context, args)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">getName.<span class="title function_">myBind</span>(obj, <span class="number">1</span>, <span class="number">2</span>)()  <span class="comment">// 预期输出：ObjName 1 2</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 未分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无标签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 创建对象，从古至今</title>
      <link href="/posts/20200602153118/"/>
      <url>/posts/20200602153118/</url>
      
        <content type="html"><![CDATA[<p>JavaScript 的对象系统是这个语言的基石之一。随着 JavaScript 的不断演进，对象创建的方式也在逐步丰富。本篇将带你回顾 JavaScript 中创建对象的多种方式，从早期的经典用法到现代的高级特性。</p><h2 id="1-最基础的对象字面量"><a href="#1-最基础的对象字面量" class="headerlink" title="1. 最基础的对象字面量"></a>1. 最基础的对象字面量</h2><p>JavaScript 最简单、最直观的对象创建方式就是使用对象字面量。这是一种简洁的语法，非常适合用来创建简单对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Alice&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">25</span>,</span><br><span class="line">  <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hi, I&#x27;m <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person.<span class="title function_">greet</span>(); <span class="comment">// 输出: Hi, I&#x27;m Alice</span></span><br></pre></td></tr></table></figure><p>优点：</p><ul><li>   简单易懂，语法直观</li><li>   适合创建静态数据结构</li></ul><p>缺点：</p><ul><li>   适用于简单对象，复杂逻辑难以复用</li></ul><h2 id="2-构造函数：带来可复用性"><a href="#2-构造函数：带来可复用性" class="headerlink" title="2. 构造函数：带来可复用性"></a>2. 构造函数：带来可复用性</h2><p>JavaScript 在早期版本（ES5 之前）没有类的概念，但通过构造函数模拟类的功能。构造函数是用 function 定义的，并与 new 关键字一起使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">greet</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hi, I&#x27;m <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bob = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Bob&quot;</span>, <span class="number">30</span>);</span><br><span class="line">bob.<span class="title function_">greet</span>(); <span class="comment">// 输出: Hi, I&#x27;m Bob</span></span><br></pre></td></tr></table></figure><p>优点：</p><ul><li>   实现了简单的面向对象编程</li><li>   通过 prototype 共享方法，节省内存</li></ul><p>缺点：</p><ul><li>   语法不够直观，相比其他语言的类显得笨拙</li></ul><h2 id="3-ES6-类：语法糖的出现"><a href="#3-ES6-类：语法糖的出现" class="headerlink" title="3. ES6 类：语法糖的出现"></a>3. ES6 类：语法糖的出现</h2><p>在 ES6（2015）中，JavaScript 引入了类（class）关键字，进一步优化了面向对象编程的体验。类本质上是对构造函数的封装，但语法更加清晰。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hi, I&#x27;m <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> charlie = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Charlie&quot;</span>, <span class="number">35</span>);</span><br><span class="line">charlie.<span class="title function_">greet</span>(); <span class="comment">// 输出: Hi, I&#x27;m Charlie</span></span><br></pre></td></tr></table></figure><p>优点：</p><ul><li>   更符合面向对象语言的习惯</li><li>   支持继承和静态方法</li></ul><p>缺点：</p><ul><li>   只是语法糖，本质上还是基于 prototype</li></ul><h2 id="4-工厂函数：灵活的对象创建"><a href="#4-工厂函数：灵活的对象创建" class="headerlink" title="4. 工厂函数：灵活的对象创建"></a>4. 工厂函数：灵活的对象创建</h2><p>有时候，我们希望避免 new 关键字的使用，并灵活控制对象的创建逻辑。这时，工厂函数是一种很好的选择。工厂函数是返回对象的普通函数，不依赖类和构造函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createPerson</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    name,</span><br><span class="line">    age,</span><br><span class="line">    <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hi, I&#x27;m <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dave = <span class="title function_">createPerson</span>(<span class="string">&quot;Dave&quot;</span>, <span class="number">28</span>);</span><br><span class="line">dave.<span class="title function_">greet</span>(); <span class="comment">// 输出: Hi, I&#x27;m Dave</span></span><br></pre></td></tr></table></figure><p>优点：</p><ul><li>   不需要 new 关键字，避免 this 绑定问题</li><li>   适合复杂对象创建逻辑和闭包</li></ul><p>缺点：</p><ul><li>   不具备类的继承特性，需要手动管理方法共享</li></ul><h2 id="5-对象的动态扩展与-Object-create"><a href="#5-对象的动态扩展与-Object-create" class="headerlink" title="5. 对象的动态扩展与 Object.create()"></a>5. 对象的动态扩展与 Object.create()</h2><p>JavaScript 允许动态扩展对象，也可以通过 Object.create() 创建基于某个原型的对象。这种方法提供了更灵活的继承方式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> protoPerson = &#123;</span><br><span class="line">  <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hi, I&#x27;m <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> emily = <span class="title class_">Object</span>.<span class="title function_">create</span>(protoPerson);</span><br><span class="line">emily.<span class="property">name</span> = <span class="string">&quot;Emily&quot;</span>;</span><br><span class="line">emily.<span class="title function_">greet</span>(); <span class="comment">// 输出: Hi, I&#x27;m Emily</span></span><br></pre></td></tr></table></figure><p>优点：</p><ul><li>   直接创建继承关系，避免类的复杂性</li><li>   非常适合需要原型链操作的场景</li></ul><p>缺点：</p><ul><li>   不如 class 语法直观</li></ul><h2 id="6-ES2020-的私有属性：更加完善的类支持"><a href="#6-ES2020-的私有属性：更加完善的类支持" class="headerlink" title="6. ES2020 的私有属性：更加完善的类支持"></a>6. ES2020 的私有属性：更加完善的类支持</h2><p>在 ES2020 中，引入了私有属性（# 开头），让 JavaScript 的类系统更接近传统面向对象语言。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  #secret; <span class="comment">// 私有属性</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, age, secret</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">    <span class="variable language_">this</span>.#secret = secret;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">revealSecret</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`My secret is: <span class="subst">$&#123;<span class="variable language_">this</span>.#secret&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> frank = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Frank&quot;</span>, <span class="number">40</span>, <span class="string">&quot;I love coding&quot;</span>);</span><br><span class="line">frank.<span class="title function_">revealSecret</span>(); <span class="comment">// 输出: My secret is: I love coding</span></span><br></pre></td></tr></table></figure><p>优点：</p><ul><li>   提供真正的私有属性，提升数据封装性</li><li>   避免意外访问和修改</li></ul><p>缺点：</p><ul><li>   旧版浏览器不支持，需要 Babel 等工具转译</li></ul><h2 id="7-总结：百花齐放的对象创建方式"><a href="#7-总结：百花齐放的对象创建方式" class="headerlink" title="7. 总结：百花齐放的对象创建方式"></a>7. 总结：百花齐放的对象创建方式</h2><p>JavaScript 对象的创建方式，从最简单的字面量，到构造函数模拟类，再到现代的class 和 私有属性，每一种方式都有其特定的应用场景和优劣。</p><ul><li>   字面量：快速创建简单对象</li><li>   构造函数：模拟类，支持原型共享</li><li>   class：语法更优雅，适合复杂对象</li><li>   工厂函数：灵活控制对象逻辑</li><li>   Object.create()：灵活操作原型链</li><li>   私有属性：提高封装性</li></ul><p>未来，随着 JavaScript 的持续发展，我们可能会看到更多对象相关的新特性被引入。希望这篇博客能帮助你理清思路，选择最适合的方式来创建和管理对象。</p>]]></content>
      
      
      <categories>
          
          <category> 未分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无标签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 中 forEach 的不可中断性</title>
      <link href="/posts/20200601094427/"/>
      <url>/posts/20200601094427/</url>
      
        <content type="html"><![CDATA[<p>在 JavaScript 的数组操作中，forEach 是我们经常使用的遍历方法。然而，当我们需要在遍历过程中 提前退出（如遇到特定条件时停止迭代）时，forEach 却无法像 for 循环那样通过 break 或 return 来中断。这种不可中断性经常会给开发者带来困惑。本文将详细介绍 forEach 的特性、工作机制，并给出一些替代方案，帮助你在合适的场景下做出更优的选择。</p><h2 id="1-forEach-的基本使用"><a href="#1-forEach-的基本使用" class="headerlink" title="1. forEach 的基本使用"></a>1. forEach 的基本使用</h2><p>forEach 是 JavaScript 中数组对象的原型方法，用于对数组中的每个元素执行一次指定的回调函数。其典型用法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">numbers.<span class="title function_">forEach</span>(<span class="function">(<span class="params">num</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(num);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p>回调函数会按照顺序依次执行，但无法通过 break、continue 或 return 来提前终止这次遍历。即使回调函数内部显式使用 return，也只是结束当前回调函数的执行，并不会跳过或中断整个遍历。</p><h2 id="2-forEach-不可中断性的表现"><a href="#2-forEach-不可中断性的表现" class="headerlink" title="2. forEach 不可中断性的表现"></a>2. forEach 不可中断性的表现</h2><p>官方文档中的描述：</p><p>“除非抛出异常，否则没有办法停止或中断 forEach() 循环。如果有这样的需求，则不应该使用 forEach() 方法。”</p><p>这句话直接点明了 forEach 的局限性：如果在遍历过程中需要满足某个条件时提前停止，则不应使用 forEach。如果强行使用，可能会导致程序逻辑不符合预期。</p><p>示例：</p><p>我们来看一个例子，尝试在回调函数中使用 return 结束遍历：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">numbers.<span class="title function_">forEach</span>(<span class="function">(<span class="params">num</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (num === <span class="number">3</span>) <span class="keyword">return</span>; <span class="comment">// 期望在遇到 3 时跳过</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(num);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>实际输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p>分析：<br>上例中的 return 只结束了当前回调函数的执行，相当于 continue 的效果，而不是跳过或终止整个遍历。为了实现完全停止遍历的需求，我们需要使用其他工具。</p><h2 id="3-forEach-与-for-循环的对比"><a href="#3-forEach-与-for-循环的对比" class="headerlink" title="3. forEach 与 for 循环的对比"></a>3. forEach 与 for 循环的对比</h2><p>如果你希望在遇到某个元素时 停止遍历，for 循环是一种更合适的选择。以下是同样逻辑的 for 循环实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> num <span class="keyword">of</span> numbers) &#123;</span><br><span class="line">  <span class="keyword">if</span> (num === <span class="number">3</span>) <span class="keyword">break</span>; <span class="comment">// 遇到 3 时停止遍历</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>在这种情况下，for 循环允许我们使用 break 直接退出。</p><h2 id="4-如何在复杂逻辑中替代-forEach"><a href="#4-如何在复杂逻辑中替代-forEach" class="headerlink" title="4. 如何在复杂逻辑中替代 forEach"></a>4. 如何在复杂逻辑中替代 forEach</h2><p>尽管 forEach 无法中断，但你可以根据需求选择其他遍历方法：</p><h3 id="4-1-使用-some-或-every"><a href="#4-1-使用-some-或-every" class="headerlink" title="4.1 使用 some 或 every"></a>4.1 使用 some 或 every</h3><pre><code>•    some：只要回调函数返回 true，就会停止遍历。•    every：只要回调函数返回 false，就会停止遍历。</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">numbers.<span class="title function_">some</span>(<span class="function">(<span class="params">num</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (num === <span class="number">3</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 遇到 3 时停止遍历</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(num);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h3 id="4-2-使用-for…of"><a href="#4-2-使用-for…of" class="headerlink" title="4.2 使用 for…of"></a>4.2 使用 for…of</h3><p>for…of 是一种支持 break 和 continue 的遍历方式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> num <span class="keyword">of</span> numbers) &#123;</span><br><span class="line">  <span class="keyword">if</span> (num === <span class="number">3</span>) <span class="keyword">break</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-forEach-的应用场景"><a href="#5-forEach-的应用场景" class="headerlink" title="5. forEach 的应用场景"></a>5. forEach 的应用场景</h2><p>尽管 forEach 存在不可中断的限制，但在某些场景下，它依然非常适用：</p><h3 id="5-1-对所有元素执行副作用操作："><a href="#5-1-对所有元素执行副作用操作：" class="headerlink" title="5.1 对所有元素执行副作用操作："></a>5.1 对所有元素执行副作用操作：</h3><p>如打印日志、发送 API 请求等不需要中断的任务。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> logs = [<span class="string">&#x27;登录成功&#x27;</span>, <span class="string">&#x27;查询数据&#x27;</span>, <span class="string">&#x27;操作失败&#x27;</span>];</span><br><span class="line">logs.<span class="title function_">forEach</span>(<span class="function">(<span class="params">log</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(log));</span><br></pre></td></tr></table></figure><h3 id="5-2-需要对数组中的所有元素逐一操作且不考虑中断："><a href="#5-2-需要对数组中的所有元素逐一操作且不考虑中断：" class="headerlink" title="5.2 需要对数组中的所有元素逐一操作且不考虑中断："></a>5.2 需要对数组中的所有元素逐一操作且不考虑中断：</h3><p>如果逻辑上无条件处理所有元素，forEach 使代码更加简洁。</p><h2 id="6-总结与思考"><a href="#6-总结与思考" class="headerlink" title="6. 总结与思考"></a>6. 总结与思考</h2><p>forEach 是一个简洁的遍历工具，但它的不可中断性让它在某些情况下显得不够灵活。如果你需要在遍历过程中提前退出或跳过某些元素，请考虑使用其他遍历方式，如 for、for…of、some 或 every。</p><p>在选择工具时，请记住 MDN 的建议：“如果有中断遍历的需求，不应该使用 forEach()。” 了解并合理使用 JavaScript 的不同遍历方式，能够帮助你写出更加高效、清晰的代码。</p><p>想了解更多细节，请参考 MDN 的官方文档：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach">Array.prototype.forEach()</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 未分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无标签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用反向代理解决前端开发环境下的 CORS 问题</title>
      <link href="/posts/20200423162419/"/>
      <url>/posts/20200423162419/</url>
      
        <content type="html"><![CDATA[<p>要解决前端开发环境下的 CORS（跨域资源共享） 问题，常见的解决方案是使用反向代理。以下是几种常见的实现方式：</p><h2 id="1-使用-Nginx-反向代理"><a href="#1-使用-Nginx-反向代理" class="headerlink" title="1. 使用 Nginx 反向代理"></a>1. 使用 Nginx 反向代理</h2><p>Nginx 是一个轻量级、高性能的 Web 服务器，用于在开发或生产环境下处理跨域问题。</p><p><strong>配置示例：</strong></p><p>在 Nginx 的配置文件中添加一段反向代理规则：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> localhost;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> /api/ &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://backend-service:8080/;  <span class="comment"># 转发请求到后端服务</span></span><br><span class="line">        <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 处理CORS</span></span><br><span class="line">        <span class="attribute">add_header</span> Access-Control-Allow-Origin *;</span><br><span class="line">        <span class="attribute">add_header</span> Access-Control-Allow-Methods GET, POST, OPTIONS;</span><br><span class="line">        <span class="attribute">add_header</span> Access-Control-Allow-Headers Authorization, Content-Type;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点：</strong></p><ul><li>   稳定、可用于生产环境。</li><li>   高度可配置，适合复杂场景。</li></ul><p><strong>缺点：</strong></p><ul><li>   需要安装并配置 Nginx。</li></ul><h2 id="2-使用-Node-js-Express-反向代理"><a href="#2-使用-Node-js-Express-反向代理" class="headerlink" title="2. 使用 Node.js + Express 反向代理"></a>2. 使用 Node.js + Express 反向代理</h2><p>Express 是常见的 Node.js Web 框架，可以简单实现反向代理。</p><p><strong>实现示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; createProxyMiddleware &#125; = <span class="built_in">require</span>(<span class="string">&#x27;http-proxy-middleware&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="string">&#x27;/api&#x27;</span>, <span class="title function_">createProxyMiddleware</span>(&#123;</span><br><span class="line">  <span class="attr">target</span>: <span class="string">&#x27;http://backend-service:8080&#x27;</span>, <span class="comment">// 后端服务地址</span></span><br><span class="line">  <span class="attr">changeOrigin</span>: <span class="literal">true</span>, <span class="comment">// 修改请求头中的 Host</span></span><br><span class="line">  <span class="attr">pathRewrite</span>: &#123; <span class="string">&#x27;^/api&#x27;</span>: <span class="string">&#x27;&#x27;</span> &#125;, <span class="comment">// 重写路径</span></span><br><span class="line">  <span class="attr">onProxyReq</span>: <span class="function">(<span class="params">proxyReq, req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;*&#x27;</span>); <span class="comment">// 处理CORS</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Proxy server is running on http://localhost:3000&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>优点：</strong></p><ul><li>   适合前端开发者，方便集成到 Node.js 项目中。</li><li>   易于修改和扩展。</li></ul><p><strong>缺点：</strong></p><ul><li>   性能较 Nginx 稍弱，不建议直接用于高并发生产环境。</li></ul><h2 id="3-使用-Webpack-Dev-Server-内置代理"><a href="#3-使用-Webpack-Dev-Server-内置代理" class="headerlink" title="3. 使用 Webpack Dev Server 内置代理"></a>3. 使用 Webpack Dev Server 内置代理</h2><p>在前端项目开发阶段，webpack-dev-server 提供内置的反向代理功能，非常适合用于本地开发调试。</p><p><strong>配置示例：</strong></p><p>在 webpack.config.js 中添加如下配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="attr">proxy</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;/api&#x27;</span>: &#123;</span><br><span class="line">        <span class="attr">target</span>: <span class="string">&#x27;http://backend-service:8080&#x27;</span>, <span class="comment">// 后端服务地址</span></span><br><span class="line">        <span class="attr">changeOrigin</span>: <span class="literal">true</span>, <span class="comment">// 修改 Host 头</span></span><br><span class="line">        <span class="attr">pathRewrite</span>: &#123; <span class="string">&#x27;^/api&#x27;</span>: <span class="string">&#x27;&#x27;</span> &#125;, <span class="comment">// 重写路径</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>优点：</strong></p><ul><li>   开箱即用，专为前端开发环境设计。</li><li>   配置简单，不需要额外安装其他服务。</li></ul><p><strong>缺点：</strong></p><ul><li>   仅适用于开发环境，不能用于生产。</li></ul><h2 id="4-使用-Vite-代理（适合-Vue、React-等）"><a href="#4-使用-Vite-代理（适合-Vue、React-等）" class="headerlink" title="4. 使用 Vite 代理（适合 Vue、React 等）"></a>4. 使用 Vite 代理（适合 Vue、React 等）</h2><p>Vite 是一种快速构建工具，也提供内置的代理功能。</p><p><strong>配置示例：</strong></p><p>在 vite.config.js 中配置代理：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">server</span>: &#123;</span><br><span class="line">    <span class="attr">proxy</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;/api&#x27;</span>: &#123;</span><br><span class="line">        <span class="attr">target</span>: <span class="string">&#x27;http://backend-service:8080&#x27;</span>,</span><br><span class="line">        <span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">rewrite</span>: <span class="function"><span class="params">path</span> =&gt;</span> path.<span class="title function_">replace</span>(<span class="regexp">/^\/api/</span>, <span class="string">&#x27;&#x27;</span>), <span class="comment">// 重写路径</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>优点：</strong></p><ul><li>   适用于现代前端开发框架（如 Vue、React）。</li><li>   内置开发服务器集成，配置简单。</li></ul><p><strong>缺点：</strong></p><ul><li>   仅用于开发环境。</li></ul><h2 id="5-使用-Apache-反向代理"><a href="#5-使用-Apache-反向代理" class="headerlink" title="5. 使用 Apache 反向代理"></a>5. 使用 Apache 反向代理</h2><p>类似于 Nginx，Apache 也是一种常用的 Web 服务器，并支持反向代理。</p><p><strong>配置示例：</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">&lt;VirtualHost *<span class="number">:80</span>&gt;</span></span><br><span class="line">    <span class="attribute">ServerName</span> localhost</span><br><span class="line"></span><br><span class="line">    <span class="attribute">ProxyRequests</span> <span class="literal">Off</span></span><br><span class="line">    <span class="section">&lt;Proxy *&gt;</span></span><br><span class="line">        <span class="attribute">Order</span> <span class="literal">deny</span>,<span class="literal">allow</span></span><br><span class="line">        <span class="attribute">Allow</span> from <span class="literal">all</span></span><br><span class="line">    <span class="section">&lt;/Proxy&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">ProxyPass</span> /api/ http://backend-service:<span class="number">8080</span>/</span><br><span class="line">    <span class="attribute">ProxyPassReverse</span> /api/ http://backend-service:<span class="number">8080</span>/</span><br><span class="line"></span><br><span class="line">    <span class="attribute">Header</span> set Access-Control-<span class="literal">Allow</span>-Origin <span class="string">&quot;*&quot;</span></span><br><span class="line">    <span class="attribute">Header</span> set Access-Control-<span class="literal">Allow</span>-Methods <span class="string">&quot;GET,POST,OPTIONS&quot;</span></span><br><span class="line"><span class="section">&lt;/VirtualHost&gt;</span></span><br></pre></td></tr></table></figure><p><strong>优点：</strong></p><ul><li>   稳定且功能丰富，适合生产环境。</li><li>   支持大量模块，可实现复杂的需求。</li></ul><p><strong>缺点：</strong></p><ul><li>   相比 Nginx 配置略复杂。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>不同反向代理方式的适用场景如下：</p><table><thead><tr><th align="center">方式</th><th align="center">适用场景</th><th align="center">优缺点</th></tr></thead><tbody><tr><td align="center">Nginx</td><td align="center">生产环境</td><td align="center">性能优异，配置灵活</td></tr><tr><td align="center">Express(Node.js)</td><td align="center">开发/测试环境</td><td align="center">适合前端项目开发</td></tr><tr><td align="center">Webpack Dev Server</td><td align="center">前端开发环境</td><td align="center">易配置，快速上手</td></tr><tr><td align="center">Vite</td><td align="center">前端开发环境</td><td align="center">快速开发</td></tr><tr><td align="center">Apache</td><td align="center">生产环境</td><td align="center">稳定，但配置较复杂</td></tr></tbody></table><p>根据你的项目需求和开发环境，可以选择合适的反向代理方式。如果是前端开发阶段，webpack-dev-server 或 Vite 是首选。如果是生产环境，更推荐 Nginx 或 Apache。</p>]]></content>
      
      
      <categories>
          
          <category> 未分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无标签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件测试的分类</title>
      <link href="/posts/20190408175829/"/>
      <url>/posts/20190408175829/</url>
      
        <content type="html"><![CDATA[<h2 id="按测试阶段分类"><a href="#按测试阶段分类" class="headerlink" title="按测试阶段分类"></a>按测试阶段分类</h2><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><blockquote><p>对软件中最小可充实单元进行检查和验证</p></blockquote><h4 id="单元测试的原则"><a href="#单元测试的原则" class="headerlink" title="单元测试的原则"></a>单元测试的原则</h4><ol><li>尽可能保证各个测试用例是相互独立的</li><li>一般由代码的开发人员来实施，用以检验所开发的代码功能符合自己的设计要求</li></ol><h4 id="单元测试的益处"><a href="#单元测试的益处" class="headerlink" title="单元测试的益处"></a>单元测试的益处</h4><ol><li>能尽早发现缺陷</li><li>有利于重构</li><li>简化集成</li><li>单元测试一定程度替代文档</li><li>用于设计，单元测试体验设计思路，设计本身可以用来验证设计</li></ol><h4 id="单元测试的限制"><a href="#单元测试的限制" class="headerlink" title="单元测试的限制"></a>单元测试的限制</h4><ol><li>不可能覆盖所有的执行路径，所以不可能保证捕捉到所有路径的错误</li><li>每一行代码，一般需要 3-5 行测试代码才能完成单元测试，所以存在投入和产出的一个平衡</li></ol><h4 id="单元测试框架"><a href="#单元测试框架" class="headerlink" title="单元测试框架"></a>单元测试框架</h4><ul><li>JUnit</li><li>NUnit</li><li>PHPUnit</li><li>CppUnit</li></ul><h3 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h3><blockquote><p>是在单元测试的基础上，测试在将所有的软件单元按照概要设计规格说明的要求组装成模块、子系统或系统的过程中各部分工作是否达到或实现相应技术指标及要求的活动</p></blockquote><h4 id="集成测试的主要实施方案"><a href="#集成测试的主要实施方案" class="headerlink" title="集成测试的主要实施方案"></a>集成测试的主要实施方案</h4><ol><li><p>Big Bang</p><blockquote><p>所有的东西都组装好，然后在进行测试</p></blockquote></li><li><p>自顶向下</p><blockquote><p>递增组装软件结构的方法，一般来说从主程序开始，沿控制层逐层向下来集成</p></blockquote></li><li><p>自底向上</p><blockquote><p>最常用的集成方法，从程序模块最底层的模块开始，逐层向上组装，并逐层的测试；好处是，针对我们已经集成的测试，不需要再针对上一层编写装模块</p></blockquote></li><li><p>核心系统集成</p><blockquote><p>先把核心的部分挑选出来，并对这些部分进行集成测试，在测试通过的基础上，在向外围拓展进行测试</p></blockquote></li><li><p>高频集成</p><blockquote><p>同步软件开发过程，每过一段时间，就对软件进行集成测试，常说的持续集成</p></blockquote></li></ol><h3 id="系统测试"><a href="#系统测试" class="headerlink" title="系统测试"></a>系统测试</h3><blockquote><p>是将经过集成测试的软件，作为计算机系统的一个部分，与系统中其他部分结合起来，在实际运行环境下对计算机系统进行的一系列严格有效的测试，已发现软件潜在的问题，保证系统正常运行</p></blockquote><h4 id="关注点"><a href="#关注点" class="headerlink" title="关注点"></a>关注点</h4><ul><li>关注系统本身的使用</li><li>关注系统与其他相关系统间的连通</li><li>关注系统在不同使用压力下的表现</li><li>关注系统在真实使用环境下的表现</li></ul><h3 id="验收测试"><a href="#验收测试" class="headerlink" title="验收测试"></a>验收测试</h3><blockquote><p>也称交付测试，针对用户需求、业务流程的正式的测试，确定系统是否满足验收标准，由用户、客户或其他授权机构决定是否接受系统</p></blockquote><h4 id="细分"><a href="#细分" class="headerlink" title="细分"></a>细分</h4><ul><li>用户验收测试 - 一般由开发方交付前自己做的测试</li><li>运行验收测试 - 从运维层面看系统是否能够正常运行，比如系统上线后备份、容灾</li><li>合同和规范验收测试</li><li>alpha 测试 - 开发者提供的环境进行的测试，一般由用户来执行</li><li>beta 测试 - 完全脱离开发环境，由用户提供的环境进行测试</li></ul><h2 id="按测试手段分类"><a href="#按测试手段分类" class="headerlink" title="按测试手段分类"></a>按测试手段分类</h2><blockquote><ul><li>黑盒测试、白盒测试</li><li>静态测试、动态测试</li><li>手工测试、自动化测试</li></ul></blockquote><h3 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h3><blockquote><p>着眼于外部结构，不考虑内部逻辑，一般针对于软件外部的界面、可见的功能来测试，一般是从用户的视角通过不同的数据和事件来驱动系统，通过输出结果来进行判断</p></blockquote><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li>容易实施，不需要关注内部的实现</li><li>更贴近用户的使用角度</li></ol><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol><li>测试覆盖率比较低，一般只能覆盖到代码量的不到 40%</li><li>针对黑盒的自动化测试，复用率较低，维护成本较高</li></ol><h4 id="黑盒测试主要测试什么"><a href="#黑盒测试主要测试什么" class="headerlink" title="黑盒测试主要测试什么"></a>黑盒测试主要测试什么</h4><blockquote><p>主要（更多）应用于 <strong>系统测试</strong> 阶段</p></blockquote><ol><li>是否有不正确或遗漏的功能</li><li>在接口上，输入是否能正确的接受，能否输出正确的结果</li><li>是否有数据结构错误或外部信息（例如数据文件）访问错误</li><li>性能上是否能够满足要求</li></ol><h4 id="黑盒测试的主要设计方法"><a href="#黑盒测试的主要设计方法" class="headerlink" title="黑盒测试的主要设计方法"></a>黑盒测试的主要设计方法</h4><ul><li>等价类划分法</li><li>边界值分析法</li><li>错误推测法</li><li>因果图法</li><li>正交实验分析法</li><li>状态迁移图法</li><li>流程分析法</li></ul><h3 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a>白盒测试</h3><blockquote><p>测试人员对内部结构是非常了解的，又称为结构化测试或透明盒测试；</p><p>白盒测试是通过程序的逻辑结构设计测试用例，用逻辑的覆盖率来衡量测试的完整性</p></blockquote><h4 id="主要的逻辑单位"><a href="#主要的逻辑单位" class="headerlink" title="主要的逻辑单位"></a>主要的逻辑单位</h4><ul><li>语句</li><li>条件</li><li>条件组合</li><li>分支</li><li>路径</li></ul><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ol><li>迫使测试人员去仔细思考软件的实现，理解原理</li><li>可以检测到代码中的每条分支和路径</li><li>可以揭示隐藏在代码中的错误</li><li>对代码的测试比较彻底</li></ol><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ol><li>昂贵 - 因为要做到较高的覆盖率，所以成本高</li><li>无法检测代码中遗漏的路径和数据敏感性错误</li><li>不能直接验证需求的正确性</li></ol><h4 id="白盒测试的主要测试方法"><a href="#白盒测试的主要测试方法" class="headerlink" title="白盒测试的主要测试方法"></a>白盒测试的主要测试方法</h4><ul><li>代码检测法</li><li>静态结构分析法</li><li>静态质量度量法</li><li>逻辑覆盖法</li><li>基本路径测试法</li></ul><h3 id="灰盒测试"><a href="#灰盒测试" class="headerlink" title="灰盒测试"></a>灰盒测试</h3><blockquote><p>介于黑、白盒测试之间的，关注输出对于输入的正确性，同时也关注内部表现</p></blockquote><h3 id="静态测试"><a href="#静态测试" class="headerlink" title="静态测试"></a>静态测试</h3><blockquote><p>静态测试是指 <strong>无需执行</strong> 被测程序，而是通过评审软件文档或代码，度量程序，度量程序静态复杂度，检查软件是否符合编程标准，借以发现编写的程序的不足之处，减少错误出现的概率</p><p>特点就是，程序是不被运行的，直接看我们的文档或者代码，可以人工也可以通过自动化工具来做，通过静态的检查代码或者文档的测试手段</p></blockquote><h4 id="测试方式"><a href="#测试方式" class="headerlink" title="测试方式"></a>测试方式</h4><ul><li>互审 - 程序员相互检查相互的代码</li><li>走查 - 一个小组集体走查程序或文档</li><li>会议 - 召开会议</li></ul><h3 id="动态测试"><a href="#动态测试" class="headerlink" title="动态测试"></a>动态测试</h3><blockquote><p>是指通过运行被测程序，检查运行结果与预期结果的差异，并分析运行效率、正确性和健壮性等</p></blockquote><h3 id="手工测试"><a href="#手工测试" class="headerlink" title="手工测试"></a>手工测试</h3><blockquote><p>由专门的测试人员从用户视角来验证软件是否满足设计要求的行为。更适用针对深度的测试和强调主观判断的测试</p><p>常见的：众包测试、探索式测试，都是用手工测试完成的</p></blockquote><h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><ul><li>容易发现缺陷</li><li>容易实施</li><li>创造性、灵活性</li></ul><h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><ul><li>覆盖量化难</li><li>重复测试效率低</li><li>不一致性、可靠性低</li><li>人力资源依赖</li></ul><h3 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h3><blockquote><p>使用单独的测试工具软件控制测试的自动化执行以及对于其和结果进行自动检查</p><p>常见的：单元测试、接口测试、性能测试等，都是用自动化测试完成的</p></blockquote><h4 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h4><ul><li>高效率、速度快</li><li>高复用性</li><li>覆盖率容易度量</li><li>准确、可靠</li><li>不知疲劳</li></ul><h4 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h4><ul><li>机械、发现缺陷率低</li><li>一次性投入较大</li></ul><h2 id="按测试模式分类"><a href="#按测试模式分类" class="headerlink" title="按测试模式分类"></a>按测试模式分类</h2><h3 id="传统的瀑布模型"><a href="#传统的瀑布模型" class="headerlink" title="传统的瀑布模型"></a>传统的瀑布模型</h3><blockquote><p>最早出现的软件开发模型，每一个阶段都是按顺序的向下，到下一个阶段，就像瀑布下落一样</p><p>瀑布模型每一个阶段都是以上一个阶段的输出作为下一个阶段的输入</p><ul><li>项目计划 ——&gt; 需求分析 ——&gt; 软件设计 ——&gt; 程序开发 ——&gt; 软件测试 ——&gt; 集成维护</li></ul></blockquote><h4 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h4><ul><li>强调需求、设计的作用</li><li>前一阶段完成后，只需要关注后续阶段</li><li>为项目提供了按阶段划分的检查点，里程碑清晰</li><li>文档规范</li></ul><h4 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h4><ul><li>难以适应需求的频繁变化</li><li>项目周期后段才能看到成果</li><li>强制的里程碑、完成时间点</li><li>文档工作量大</li></ul><h3 id="V-模型"><a href="#V-模型" class="headerlink" title="V 模型"></a>V 模型</h3><blockquote><ul><li>需求分析 ——&gt; 概要设计 ——&gt; 详细设计 ——&gt; 软件编码 -&gt;</li><li>验收测试 &lt;—— 系统测试 &lt;—— 集成测试 &lt;—— 单元测试 &lt;-</li></ul><p>是瀑布模型的变种，是目前使用最广泛的一种模型，在 V 模型中，明确表明了测试过程的不同级别或者不同阶段，并且描述了这些阶段和开发过程各个阶段的对应关系</p><p>局限性是：仅仅把测试过程作为需求分析和编码之后的阶段，所以对于需求分析的测试只有到最后的验收测试才会发现问题</p></blockquote><h3 id="W-模型"><a href="#W-模型" class="headerlink" title="W 模型"></a>W 模型</h3><blockquote><p>也称为 双 V 模型，是对 V 模型的改进模型</p><p>增加了软件开发各个阶段同步进行验证和确认的活动，测试时伴随整个开发周期进行，测试的对象也不仅仅是程序，他要对需求和设计都要进行相应的测试，开发和测试是两个并行的流程</p><p>W 模型 有利于及时了解项目的测试风险，及早确定应对方案</p><p>W 模型 也有其局限性，该模型中，需求、编码、测试仍然是串行的，测试和开发保持着一个线性的关系，只有在上一阶段完成之后才能进入下一阶段</p></blockquote><h3 id="X-模型"><a href="#X-模型" class="headerlink" title="X 模型"></a>X 模型</h3><blockquote><p>针对 V 模型 提出的改进</p><p>主要解决交接和频繁集成的周期的问题</p></blockquote><h3 id="敏捷测试"><a href="#敏捷测试" class="headerlink" title="敏捷测试"></a>敏捷测试</h3><blockquote><p>Agile Testing —— 遵循 <strong>敏捷宣言</strong> 的一种测试实践</p><p><strong>敏捷宣言</strong>：</p><p>个体与交互 重于 过程和工具</p><p>可用的软件 重于 完备的文档</p><p>客户合作 重于 合同谈判</p><p>响应变化 重于 遵循计划</p><ul><li>在以上每对比较中，后者并非完全无价值，但我们更看重前者</li></ul></blockquote><h4 id="敏捷测试的特点"><a href="#敏捷测试的特点" class="headerlink" title="敏捷测试的特点"></a>敏捷测试的特点</h4><ul><li>强调从客户角度进行测试</li><li>重点关注迭代测试新功能，不再强调测试阶段</li><li>尽早测试，不间断的测试，具备条件即测试</li><li>强调持续反馈</li><li>预防缺陷重于发现缺陷</li></ul><h4 id="敏捷测试-VS-传统测试"><a href="#敏捷测试-VS-传统测试" class="headerlink" title="敏捷测试 VS 传统测试"></a>敏捷测试 VS 传统测试</h4><table><thead><tr><th>传统测试</th><th>敏捷测试</th></tr></thead><tbody><tr><td>- 测试时质量的最后保护者</td><td>- 开发和测试人员是紧密合作，大家都有责任对软件负责</td></tr><tr><td>- 严格的变更管理</td><td>- 变更是可接受的，拥抱变更</td></tr><tr><td>- 预先的计划和细节的准备</td><td>- 计划随着进展时常调整</td></tr><tr><td>- 重量级文档</td><td>- 只需要绝对必要的文档</td></tr><tr><td>- 各阶段测试严格的入口和出口标准</td><td>- 各迭代之间已经没有明显的入口和出口标准</td></tr><tr><td>- 更多在回归测试是进行重量级的自动化测试</td><td>- 所有阶段都需要自动测试，每个人都需要做，是项目集成的一部分</td></tr><tr><td>- 严格依赖流程执行</td><td>- 流程不再需要严格执行</td></tr><tr><td>- 测试团队和开发团队是相对独立的</td><td>- 团队合作是无缝隙合作的</td></tr></tbody></table><h3 id="基于脚本的测试"><a href="#基于脚本的测试" class="headerlink" title="基于脚本的测试"></a>基于脚本的测试</h3><blockquote><p>Script-based Testing</p><p>Scripted Testing (ST)</p><p>Exploratory Testing (ET)</p></blockquote><h3 id="基于风险的测试-RBT"><a href="#基于风险的测试-RBT" class="headerlink" title="基于风险的测试 - RBT"></a>基于风险的测试 - RBT</h3><blockquote><p>Risk-based Testing</p><p>一种基于对软件失效的风险评估并以此指导测试计划、设计、执行、结果评价的软件测试类型</p></blockquote><h4 id="哪些是风险？"><a href="#哪些是风险？" class="headerlink" title="哪些是风险？"></a>哪些是风险？</h4><ul><li>质量风险</li><li>管理风险</li><li>风险级别 = 风险可能性 x 风险严重度</li></ul><h4 id="识别风险"><a href="#识别风险" class="headerlink" title="识别风险"></a>识别风险</h4><blockquote><p>风险要素分 = Sum（单项权重 * 得分）</p></blockquote><h5 id="可能性"><a href="#可能性" class="headerlink" title="可能性"></a>可能性</h5><ul><li>复杂性</li><li>时间压力</li><li>高变更率</li><li>技能水平</li><li>地理分散度</li></ul><h5 id="严重程度"><a href="#严重程度" class="headerlink" title="严重程度"></a>严重程度</h5><ul><li>使用频率</li><li>失效可视性</li><li>商业损失</li><li>组织负面影响和损害</li><li>社会损失和法律责任</li></ul><h3 id="基于探索式的测试-ST"><a href="#基于探索式的测试-ST" class="headerlink" title="基于探索式的测试 - ST"></a>基于探索式的测试 - ST</h3><blockquote><p>完全抛开测试脚本的测试</p><p>它是一种测试风格、思维，而不是一种测试技术</p></blockquote><h4 id="ET-和-ST-使用"><a href="#ET-和-ST-使用" class="headerlink" title="ET 和 ST 使用"></a>ET 和 ST 使用</h4><ul><li>Pure Scripted</li><li>Vague Scripted</li><li>Fragmentary test cases</li><li>Charters</li><li>Roles</li><li>Freestyle ET</li></ul><h4 id="ST-vs-ET"><a href="#ST-vs-ET" class="headerlink" title="ST vs ET"></a>ST vs ET</h4><table><thead><tr><th>ST</th><th>ET</th></tr></thead><tbody><tr><td>- 系统性强</td><td>- 自由灵活</td></tr><tr><td>- 容易管理、控制</td><td>- 和 ST 是互补的</td></tr><tr><td>- 设计在先，执行在后</td><td>- 执行和设计（思考）并行</td></tr><tr><td>- 主要是验证自己的思路</td><td>- 不断和系统交互，带着问题测试</td></tr><tr><td>- 可预见性</td><td>- 学习的过程</td></tr></tbody></table><h4 id="探索式测试的优点"><a href="#探索式测试的优点" class="headerlink" title="探索式测试的优点"></a>探索式测试的优点</h4><ul><li>更能激发测试人员的创造性和工作乐趣</li><li>增加了发现新的或者较深入 Bug 的可能性</li><li>可以在较短时间内找到更多 Bug 以及对 SUT 做出一个快速的评估</li><li>有利于更加有效地实施自动化</li><li>更加适用于敏捷项目</li><li>减少了再简单、繁复上用例的无谓编写时间</li></ul><h4 id="探索式测试的缺点"><a href="#探索式测试的缺点" class="headerlink" title="探索式测试的缺点"></a>探索式测试的缺点</h4><ul><li>测试管理上有局限性，较难协调和控制</li><li>对于 Bug 的重复利用和重现上作用有限</li><li>对测试人员的测试技能和业务知识深度依赖较大</li><li>只有在 SUT 已完全可用的前提下才更有作用</li><li>ET 的生产率很难定义</li><li>ET 本身较难进行自动化</li></ul><h4 id="执行探索式测试"><a href="#执行探索式测试" class="headerlink" title="执行探索式测试"></a>执行探索式测试</h4><ol><li>Know You Mession</li><li>Learning Session</li><li>Coverage Session</li><li>Deep Session</li><li>Close Session</li></ol><h3 id="基于模型的测试-MBT"><a href="#基于模型的测试-MBT" class="headerlink" title="基于模型的测试 - MBT"></a>基于模型的测试 - MBT</h3><blockquote><p>Model-based testing is software testing in which test cases are derived in whole or in part from a model that describes some (usually functional) aspects of the system under test (SUT).</p></blockquote><h2 id="按测试类型分类"><a href="#按测试类型分类" class="headerlink" title="按测试类型分类"></a>按测试类型分类</h2><h3 id="功能测试"><a href="#功能测试" class="headerlink" title="功能测试"></a>功能测试</h3><blockquote><p>根据产品特性、操作描述和用户反感，测试一个产品的特性和可操作性为已确定他们满足设计需求</p></blockquote><h4 id="针对的问题"><a href="#针对的问题" class="headerlink" title="针对的问题"></a>针对的问题</h4><ul><li>功能错误或遗漏</li><li>界面问题</li><li>性能错误</li><li>数据及访问错误</li><li>初始化及终止错误</li></ul><h4 id="功能测试工具"><a href="#功能测试工具" class="headerlink" title="功能测试工具"></a>功能测试工具</h4><ul><li>QTP winrunner</li><li>silkTest</li><li>Rational robot</li><li>selenium</li><li>Watir</li><li>Sikuli</li></ul><h3 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h3><blockquote><p><strong>衍生出：</strong></p><ul><li>负载测试</li><li>压力测试</li><li>稳定性测试</li></ul></blockquote><h4 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h4><ul><li>并发用户数 VU</li><li>每秒事务数 TPS</li><li>系统响应时间</li><li>设备性能</li></ul><h4 id="性能测试工具"><a href="#性能测试工具" class="headerlink" title="性能测试工具"></a>性能测试工具</h4><ul><li>LoadRunner</li><li>Silkperformer</li><li>Jmeter</li><li>WebLoad</li><li>Apache Bench</li><li>LoadUI</li></ul><h4 id="静态性能评估"><a href="#静态性能评估" class="headerlink" title="静态性能评估"></a>静态性能评估</h4><blockquote><p>开发 Web 应用时，基于一系列 Web 应用页面性能优化的最佳实践对 Web 应用的页面进行静态分析，并给出评估结果的性能分析方法</p></blockquote><ul><li>YSlow - 雅虎</li><li>PageSpeed - 谷歌</li></ul><h4 id="应用性能管理（APM）"><a href="#应用性能管理（APM）" class="headerlink" title="应用性能管理（APM）"></a>应用性能管理（APM）</h4><blockquote><p>Application performance Management，提供对系统的实时监控以实现性能管理、故障管理的解决方案</p><p>国内产品举例：<strong>听云</strong></p></blockquote><h3 id="安全测试"><a href="#安全测试" class="headerlink" title="安全测试"></a>安全测试</h3><blockquote><p>对软件产品进行测试以确保其符合 <strong>产品安全需求</strong> 和 <strong>质量标准</strong></p><p>通常相提并论提到的测试：<strong>渗透测试</strong></p><p>通过模拟对软件系统的恶意攻击行为来评估系统安全性的一种测试</p></blockquote><h4 id="渗透测试-VS-安全测试"><a href="#渗透测试-VS-安全测试" class="headerlink" title="渗透测试 VS 安全测试"></a>渗透测试 VS 安全测试</h4><table><thead><tr><th>渗透测试</th><th>安全测试</th></tr></thead><tbody><tr><td>攻</td><td>防</td></tr><tr><td>点</td><td>面</td></tr><tr><td>易</td><td>难</td></tr></tbody></table><h4 id="OWASP"><a href="#OWASP" class="headerlink" title="OWASP"></a>OWASP</h4><blockquote><p><a href="https://www.owasp.org/index.php/Main_Page">Open Web Application Security Project</a></p><ul><li>OWASP Top 10</li><li>Test Guide</li></ul></blockquote><h4 id="安全测试工具"><a href="#安全测试工具" class="headerlink" title="安全测试工具"></a>安全测试工具</h4><ul><li>Appscan</li><li>Webinspect</li><li>Nessus</li><li>Nmap</li><li>MetaSploit</li><li>WebScarab</li><li>Fortify</li><li>W3AF</li></ul><h3 id="兼容性测试"><a href="#兼容性测试" class="headerlink" title="兼容性测试"></a>兼容性测试</h3><blockquote><ul><li>软件本身的兼容性 - 向后兼容</li><li>不同平台下的兼容性 - 运行在多个平台</li><li>软件对运行设备的兼容性 - 32位、64位、手机、电视盒子</li><li>软件互操作性 - 软件之间的联动</li></ul></blockquote><h4 id="浏览器内核"><a href="#浏览器内核" class="headerlink" title="浏览器内核"></a>浏览器内核</h4><ul><li>Trident 4 - 6 —— IE 6 - 8 ，9，10</li><li>Gecko —— FireFox</li><li>WebKit —— Safari、Chrome</li><li>presto —— Opera</li></ul><h4 id="浏览器兼容性测试工具"><a href="#浏览器兼容性测试工具" class="headerlink" title="浏览器兼容性测试工具"></a>浏览器兼容性测试工具</h4><ul><li>BrowserShots</li><li>Browser Sandbox</li><li>Google 浏览器兼容测试插件</li></ul><h3 id="文档测试"><a href="#文档测试" class="headerlink" title="文档测试"></a>文档测试</h3><blockquote><p>针对软件产品的交付品，配套的文档类部件的测试</p><p>如：用户手册、使用说明、用户帮助文档等</p></blockquote><h4 id="文档测试关注要点"><a href="#文档测试关注要点" class="headerlink" title="文档测试关注要点"></a>文档测试关注要点</h4><ul><li>完整性</li><li>正确性</li><li>一致性</li><li>易理解性</li><li>易浏览性</li></ul><h3 id="可靠性测试"><a href="#可靠性测试" class="headerlink" title="可靠性测试"></a>可靠性测试</h3><ul><li>软件可靠性</li><li>硬件可靠性</li></ul><h3 id="易用性测试"><a href="#易用性测试" class="headerlink" title="易用性测试"></a>易用性测试</h3><blockquote><p>易用性测试是指测试用户使用软件时是否感觉方便，能否保证用户使用体验的测试类型</p><p>一般针对：用户界面、用户交互、网站布局</p></blockquote><h3 id="本地化测试"><a href="#本地化测试" class="headerlink" title="本地化测试"></a>本地化测试</h3><blockquote><p>针对软件的本地化版本实施的针对性测试</p></blockquote><h4 id="主要测试内容"><a href="#主要测试内容" class="headerlink" title="主要测试内容"></a>主要测试内容</h4><ul><li>语言、书写习惯</li><li>时区、日期格式、货币</li><li>当地风俗、法律法规</li><li>政治敏感内容</li></ul><h3 id="部署测试"><a href="#部署测试" class="headerlink" title="部署测试"></a>部署测试</h3><blockquote><p>也称为安装测试，主要验证系统部署过程，并确保软件经过安装测试后可以正常使用</p></blockquote><h4 id="主要测试内容-1"><a href="#主要测试内容-1" class="headerlink" title="主要测试内容"></a>主要测试内容</h4><ul><li>在不同环境下的部署验证</li><li>参照部署文档执行，过程的合理、正确性</li><li>基础数据</li></ul><h3 id="无障碍测试"><a href="#无障碍测试" class="headerlink" title="无障碍测试"></a>无障碍测试</h3><blockquote><p>Accessibility Test 也称为访问性测试</p><p>是指软件需要提供便于特殊人群使用的功能，包括视障、听障、老年人、身体残疾用户等，无障碍测试则是针对这部分功能的测试</p></blockquote><h2 id="其他的一些测试类型概念"><a href="#其他的一些测试类型概念" class="headerlink" title="其他的一些测试类型概念"></a>其他的一些测试类型概念</h2><h3 id="回归测试"><a href="#回归测试" class="headerlink" title="回归测试"></a>回归测试</h3><blockquote><p>软件功能修改后，对软件进行重新测试以确认修改没有引入新的错误或导致其他部分产生错误</p><p>回归测试的重心在 <strong>关键模块</strong> 和 <strong>重点功能</strong> 组件</p><p>软件研发周期中会进行多次回归测试，且尽量实现自动化</p></blockquote><h3 id="Monkey-测试"><a href="#Monkey-测试" class="headerlink" title="Monkey 测试"></a>Monkey 测试</h3><blockquote><p>Monkey 测试，也称搞怪测试</p><p>就是用一些随机、稀奇古怪的方式来操作软件，以测试系统的健壮性和稳定性</p></blockquote><h3 id="冒烟测试"><a href="#冒烟测试" class="headerlink" title="冒烟测试"></a>冒烟测试</h3><blockquote><p>来自于硬件板卡验证术语</p><p>软件上则用于确认代码中的更改会按照预期运行，且不会破坏整个版本的稳定性</p><p>“每日构建”中用冒烟测试来确认合入的代码没有影响主要功能的正常</p></blockquote><h3 id="A-B-测试"><a href="#A-B-测试" class="headerlink" title="A/B 测试"></a>A/B 测试</h3><blockquote><p>多用于互联网行业，通过为页面提供 2个版本给用户使用并记录相关的用户行为数据，来确定优化设计的一种测试方案</p></blockquote><h4 id="A-B-测试实施要点"><a href="#A-B-测试实施要点" class="headerlink" title="A/B 测试实施要点"></a>A/B 测试实施要点</h4><ul><li>多个方案并行</li><li>每次测试仅改动一个变量</li><li>按照某种规则进行优胜劣汰</li></ul><h4 id="A-B-测试工具"><a href="#A-B-测试工具" class="headerlink" title="A/B 测试工具"></a>A/B 测试工具</h4><ul><li>Google Analytics Content Experiments</li><li>Visual Website Optimizer</li></ul>]]></content>
      
      
      <categories>
          
          <category> 未分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无标签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面试-基础知识笔记</title>
      <link href="/posts/20190311133421/"/>
      <url>/posts/20190311133421/</url>
      
        <content type="html"><![CDATA[<h2 id="Synchronized-（Java-关键字）"><a href="#Synchronized-（Java-关键字）" class="headerlink" title="Synchronized （Java 关键字）"></a>Synchronized （Java 关键字）</h2><blockquote><p><strong>作用：</strong> 能够保证在<strong>同一时刻</strong>最多只有<strong>一个线程</strong>执行该段代码，以达到保证并发安全的效果。</p></blockquote><h3 id="两个用法"><a href="#两个用法" class="headerlink" title="两个用法"></a>两个用法</h3><h4 id="对象锁"><a href="#对象锁" class="headerlink" title="对象锁"></a>对象锁</h4><ul><li>方法锁：默认锁对象为 this 当前实例对象</li><li>同步代码块锁：自己指定锁对象</li></ul><h4 id="类锁"><a href="#类锁" class="headerlink" title="类锁"></a>类锁</h4><ul><li>synchronized 修饰 <strong>静态</strong> 的方法</li><li>synchronized 指定锁为<strong>Class对象</strong></li></ul><h3 id="多线程访问同步方法的-7-种情况（面试常考）"><a href="#多线程访问同步方法的-7-种情况（面试常考）" class="headerlink" title="多线程访问同步方法的 7 种情况（面试常考）"></a>多线程访问同步方法的 7 种情况（面试常考）</h3><ol><li>两个线程同时访问 <strong>一个对象</strong> 的同步方法</li><li>两个线程访问的是 <strong>两个对象</strong> 的同步方法</li><li>两个线程访问的是 synchronized 的 <strong>静态</strong> 方法</li><li>同时访问 <strong>同步</strong> 方法与 <strong>非同步</strong> 方法</li><li>访问同一个对象的 <strong>不同的</strong> 普通同步方法</li><li>同时访问 <strong>静态</strong> synchronized 和 <strong>非静态</strong> synchronized 方法</li><li>方法 <strong>抛异常</strong> 后，会 <strong>释放锁</strong></li></ol><h3 id="7-种情况总结：3-点核心思想"><a href="#7-种情况总结：3-点核心思想" class="headerlink" title="7 种情况总结：3 点核心思想"></a>7 种情况总结：3 点核心思想</h3><ol><li>一个锁只能同时被一个线程获取，没有拿到锁的线程必须等待（对应 1、 5 中情况）；</li><li>每个实例都对应有自己的一把锁，不同实例之间互不影响；例外：锁对象是 *.class 以及 synchronized 修饰的是 static 方式的时候，所有对象共用一把 <strong>类锁</strong> （对应 2、 3、 4、 6 种情况）；</li><li>无论是方法正常执行完毕或者方法抛出异常，虚拟机都会帮助我们自动释放锁（对应第 7 种情况）</li></ol><h3 id="Synchronized-缺陷"><a href="#Synchronized-缺陷" class="headerlink" title="Synchronized 缺陷"></a>Synchronized 缺陷</h3><blockquote><p>对比 Lock 接口、读写锁等</p></blockquote><ul><li>效率低：锁的释放情况少、试图获得锁时不能设定超时、不能中断一个正在试图获得锁的线程</li><li>不够灵活（读写锁更灵活）：加锁和释放的时机单一，每个锁仅有单一的条件（某个对象），可能是不够的</li><li>无法知道是否成功获取到锁</li></ul><h3 id="Synchronized-常见面试问题"><a href="#Synchronized-常见面试问题" class="headerlink" title="Synchronized 常见面试问题"></a>Synchronized 常见面试问题</h3><ol><li><p>使用注意点：</p><blockquote><ul><li>锁对象不能为空</li><li>作用域不宜过大，提高效率</li><li>避免死锁，比如遇到 A 持锁1要 锁2 的同时 B 持锁2 要锁1</li></ul></blockquote></li><li><p>如何选择 Lock 和 Synchronized 关键字？</p><blockquote><ul><li>有现成的工具包，就用现成的</li><li>非要用，优先选用 Synchronized ，减少代码量</li></ul></blockquote></li></ol><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h3 id="Redis-在-Java-Web-中的主要应用场景"><a href="#Redis-在-Java-Web-中的主要应用场景" class="headerlink" title="Redis 在 Java Web 中的主要应用场景"></a>Redis 在 Java Web 中的主要应用场景</h3><ul><li>存储 <strong>缓存</strong> 用的数据</li><li>需要高速读/写的场合 <strong>使用它快速读/写</strong></li><li>数量控制器</li><li>消息队列</li></ul><h2 id="消息队列的概念与应用"><a href="#消息队列的概念与应用" class="headerlink" title="消息队列的概念与应用"></a>消息队列的概念与应用</h2><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li>冗余：比如数据排队处理并持久化后，删除原数据</li><li>解耦：分离两套系统</li><li>流量消峰：秒杀抢购</li><li>异步通信：队列使请求直接返回，后面慢慢处理</li><li>扩展性：</li><li>排序保证：</li></ul><h3 id="队列介质"><a href="#队列介质" class="headerlink" title="队列介质"></a>队列介质</h3><ul><li>MySQL：可靠性高、易于实现、速度慢</li><li>Redis：速度快，单条大消息包时候效率低</li><li>消息系统（RabbitMQ等）：专业性强、可靠、学习成本高</li></ul><h3 id="消息处理触发机制"><a href="#消息处理触发机制" class="headerlink" title="消息处理触发机制"></a>消息处理触发机制</h3><ul><li>死循环方式读取：易实现，故障时无法及时恢复</li><li>定时任务：压力均分，有处理量上限</li><li>守护进程：类似于 PHP-FPM 和 PHP-GG，需要 Shell 基础</li></ul><h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><h3 id="ER-图例说明"><a href="#ER-图例说明" class="headerlink" title="ER 图例说明"></a>ER 图例说明</h3><ul><li>矩形：表示实体集，矩形内写实体集的名字</li><li>菱形：表示联系集</li><li>椭圆：表示实体的属性</li><li>线段：将属性连接到实体集，或将实体集连接到联系集</li></ul><h3 id="设计范式"><a href="#设计范式" class="headerlink" title="设计范式"></a>设计范式</h3><ul><li><p>第一范式</p><blockquote><p><strong>定义：</strong> 数据库表中的所有字段都是单一属性，不可再分，这个单一属性是由基本的数据类型所构成的</p><p><strong>换句话说</strong> ，第一范式要求数据库中的表都是二维表</p></blockquote></li><li><p>第二范式</p><blockquote><p><strong>定义：</strong> 数据库的表中不存在非关键字段对任一候选关键字段的部分函数依赖</p><p><strong>部分函数依赖</strong> 是指存在着组合关键字中的某一关键字决定非关键字的情况</p><p><strong>换句话说：</strong> 所有单关键字段的表都符合第二范式</p></blockquote></li><li><p>第三范式</p><blockquote><p>第三范式是在第二范式的基础之上定义的，</p><p>如果数据表中不存在非关键字段，</p><p>对任意候选关键字段的传递函数依赖，</p><p>则符合第三范式</p></blockquote></li><li><p>BC 范式（Boyce.Codd 范式）</p><blockquote><p><strong>定义：</strong> 在第三范式的基础之上，数据库表中如果不存在任何字段对任一候选关键字段的传递函数依赖，则符合 BC 范式</p><p><strong>也就是说</strong>，如果是复合关键字，则复合关键字之间也不能存在函数依赖关系</p></blockquote></li></ul><h3 id="物理设计"><a href="#物理设计" class="headerlink" title="物理设计"></a>物理设计</h3><ol><li>选择合适的数据管理系统（Orale、MySQL、PgSQL）</li><li>定义数据库、表及字段的命名规范</li><li>根据所选的 DBMS 系统选择合适的字段类型（char、vachar）</li><li>反范式化设计（如：出于读写效率考量，增加数据冗余）</li></ol><h3 id="MySQL-常见的存储引擎"><a href="#MySQL-常见的存储引擎" class="headerlink" title="MySQL 常见的存储引擎"></a>MySQL 常见的存储引擎</h3><table><thead><tr><th>存储引擎</th><th>事务</th><th>锁粒度</th><th>主要应用</th><th>忌用</th></tr></thead><tbody><tr><td>MyISAM</td><td>不支持</td><td>支持并发插入的表级锁</td><td>select，insert</td><td>读写操作频繁</td></tr><tr><td>MRG_MyISAM</td><td>不支持</td><td>支持并发插入的表级锁</td><td>分段归档，数据仓库</td><td>全局查找过多的场景</td></tr><tr><td>Innodb</td><td>支持</td><td>支持 MVCC 的行级锁</td><td>事务处理</td><td>无</td></tr><tr><td>Archive</td><td>不支持</td><td>行级锁</td><td>日志记录，只支持insert，select</td><td>需要随机读取，更新，删除</td></tr><tr><td>Ndb cluster</td><td>支持</td><td>行级锁</td><td>高可用性</td><td>大部分应用</td></tr></tbody></table><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h3><h4 id="区别与联系"><a href="#区别与联系" class="headerlink" title="区别与联系"></a>区别与联系</h4><ul><li>进程是系统资源分配的最小单位</li><li>线程是程序执行的最小单位</li><li>进程使用独立的数据空间</li><li>线程共享同一线程的数据空间</li></ul><h4 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h4><ul><li>时间片轮转调度</li><li>先来先服务调度</li><li>优先级调度</li><li>多级反馈队列调度</li><li>高响应比优先调度</li></ul><h2 id="网络知识"><a href="#网络知识" class="headerlink" title="网络知识"></a>网络知识</h2><h3 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h3><ul><li>建立连接：三次握手</li><li>管理连接：四次挥手</li><li>报文状态标志与连接状态</li><li>Nagel 算法与 ACK 延迟</li><li>KeepALive - 是在长时间没有数据发送的情况下保持连接可用的机制，需要了解开启和设置方式</li><li>滑动窗口与流量控制</li></ul><h3 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h3><h4 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h4><ul><li>Method</li><li>Header</li><li>Cookies</li></ul><h4 id="UrlEncode"><a href="#UrlEncode" class="headerlink" title="UrlEncode"></a>UrlEncode</h4><h4 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h4><h4 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h4><h4 id="HTTP2"><a href="#HTTP2" class="headerlink" title="HTTP2"></a>HTTP2</h4><ul><li>多路复用</li><li>Stream</li><li>流量控制</li><li>服务端推送</li><li>头部压缩</li></ul><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><ul><li>非连接</li><li>非可靠传输</li><li>效率高</li></ul><h3 id="QUIC"><a href="#QUIC" class="headerlink" title="QUIC"></a>QUIC</h3><ul><li>避免前序包阻塞（HOL阻塞）</li><li>零 RTT 建连</li><li>FEC 前向纠错</li></ul><h3 id="OSI-模型"><a href="#OSI-模型" class="headerlink" title="OSI 模型"></a>OSI 模型</h3><ol><li><p>应用层</p></li><li><p>表示层</p></li><li><p>会话层</p></li><li><p>传输层</p></li><li><p>网络层</p></li><li><p>数据链路层</p></li><li><p>物理层</p><p>（物联网输会示用）</p></li></ol><h3 id="TCP-IP-模型"><a href="#TCP-IP-模型" class="headerlink" title="TCP/IP 模型"></a>TCP/IP 模型</h3><h4 id="1-应用层"><a href="#1-应用层" class="headerlink" title="1. 应用层"></a>1. 应用层</h4><blockquote><p>对应 OSI 的应用层、表示层、会话层</p></blockquote><ul><li>Telnet 协议能提供远程登录服务</li><li>FTP（File Transfer Protocol）文件传输协议</li><li>SMTP（Simple Mail Transaction Protocol）简单邮件传输协议</li><li>SNMP（Simple Network Management Protocol）简单网络管理协议</li><li>HTTP（HyperText Transfer Protocol）超文本传输协议</li><li>RPC（Remote Procedure Call）远程过程调用</li></ul><h4 id="2-传输层"><a href="#2-传输层" class="headerlink" title="2. 传输层"></a>2. 传输层</h4><ul><li>TCP（Transmission Control Protocol）传输控制协议</li><li>UDP（User Datagram Protocol）用户数据包协议</li><li>QUIC（Quick UDP Internet Connection）快速 UDP 网络连接 - 基于 UDP 实现原 HTTP 功能，现已被标准化为 HTTP3 协议</li></ul><h4 id="3-网络层"><a href="#3-网络层" class="headerlink" title="3. 网络层"></a>3. 网络层</h4><ul><li>IP（Internet Protocol）网络协议</li><li>ICMP（Internet Control Message Protocol）网络控制信息协议</li><li>IGMP（Internet Group Management Protocol）网络组群管理协议</li></ul><h4 id="4-网络接口层"><a href="#4-网络接口层" class="headerlink" title="4. 网络接口层"></a>4. 网络接口层</h4><blockquote><p>对应 OSI 的数据链路层、物理层</p></blockquote><ul><li>ARP（Address Resolution Protocol）地址解析协议</li><li>RARP（Reverse Address Resolution Protocol）反向地址转换协议</li></ul><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="创建型"><a href="#创建型" class="headerlink" title="创建型"></a>创建型</h3><h4 id="工厂方法模式（常用）"><a href="#工厂方法模式（常用）" class="headerlink" title="工厂方法模式（常用）"></a>工厂方法模式（常用）</h4><blockquote><p>在实际业务中经常用到，也是面试的主要考察点，是创建不同类型实例常用的方式</p></blockquote><ul><li>spring 中的 bean 都是有不同工厂类创建的</li></ul><h4 id="抽象工程模式"><a href="#抽象工程模式" class="headerlink" title="抽象工程模式"></a>抽象工程模式</h4><h4 id="单例模式（常用）"><a href="#单例模式（常用）" class="headerlink" title="单例模式（常用）"></a>单例模式（常用）</h4><blockquote><p>线程安全实现的常用三种方法</p></blockquote><ul><li>静态初始化（饿汉），不管是否使用都会创建</li><li>双检锁（懒汉），单例变量必须要用 <code>volatile</code> 修饰</li><li>单例注册表，spring 中 bean 的单例模式就是用该方法实现</li></ul><h4 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h4><blockquote><p>适用于一个对象拥有很多复杂的属性，需要根据不同情况创建不同的具体对象</p></blockquote><ul><li>创建 Protocol Buffer 对象时，需要用到 Builder</li></ul><h4 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h4><h3 id="结构型"><a href="#结构型" class="headerlink" title="结构型"></a>结构型</h3><h4 id="适配器模式（常用）"><a href="#适配器模式（常用）" class="headerlink" title="适配器模式（常用）"></a>适配器模式（常用）</h4><blockquote><p>类似于转接头，将两种不匹配的对象进行适配，也可以起到对两个不同的对象进行解耦的作用</p></blockquote><ul><li>SLF4J 可使项目 Log4、Logback 等具体日志实现框架进行解耦，其通过不同适配器与不同框架进行适配，完成日志功能的使用</li></ul><h4 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h4><h4 id="代理模式（常用）"><a href="#代理模式（常用）" class="headerlink" title="代理模式（常用）"></a>代理模式（常用）</h4><blockquote><p>在不适合或不能直接引用另一个对象的场景，可以用代理模式对被代理的队形进行访问行为的控制，Java的代理模式分为静态代理和动态代理，静态代理是指在编译时就创建好的代理类，例如在源代码中编写的类，动态代理指在 JVM 运行过程中动态创建的代理类， 如 JDK 动态代理，CDLIB，Javaasist 等</p></blockquote><ul><li>例如：在 MyBatis 中 getMapper 时会通知 MapperProxyFactory 及配置文件动态生成的 Mapper 代理对象，代理对象会拦截 Mapper 接口的方法调用，创建对应方法的 MapperMethod 类并执行 execute 方法，然后返回结果</li></ul><h4 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h4><h4 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h4><h4 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h4><h4 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h4><h3 id="行为型"><a href="#行为型" class="headerlink" title="行为型"></a>行为型</h3><h4 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h4><h4 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h4><h4 id="观察者模式（常用）"><a href="#观察者模式（常用）" class="headerlink" title="观察者模式（常用）"></a>观察者模式（常用）</h4><blockquote><p>也可称为发布订阅模式，适用于一个对象某个行为需要出发一系列操作的场景</p></blockquote><ul><li>GRPC 中 Stream 流式请求的处理</li></ul><h4 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h4><h4 id="责任链模式（常用）"><a href="#责任链模式（常用）" class="headerlink" title="责任链模式（常用）"></a>责任链模式（常用）</h4><blockquote><p>类似工厂流水线，其中的每个节点完成对对象的某一种处理</p></blockquote><ul><li>Netty 框架的处理消息的 Pipeline 就是采用的责任链模式</li></ul><h4 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h4><h4 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h4><h4 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h4><h4 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h4><h4 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h4><h4 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h4><h2 id="Java-语言"><a href="#Java-语言" class="headerlink" title="Java 语言"></a>Java 语言</h2><h3 id="Java-语言特性"><a href="#Java-语言特性" class="headerlink" title="Java 语言特性"></a>Java 语言特性</h3><h4 id="集合类"><a href="#集合类" class="headerlink" title="集合类"></a>集合类</h4><blockquote><p>主要掌握如何实现</p></blockquote><h4 id="动态代理与反射"><a href="#动态代理与反射" class="headerlink" title="动态代理与反射"></a>动态代理与反射</h4><blockquote><p>是 Java 语言的特色，需要掌握动态代理与反射的使用场景</p></blockquote><ul><li>ORM 框架中会大量使用代理类，RPC 调用时使用反射机制调用实现类的方法</li></ul><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><blockquote><p>也是面试的常见问题，如每种数据类型占用多大空间，数据类型的自动转换与强制转换，基础数据类型与 Wrapper 数据类型的自动装箱与拆箱等</p></blockquote><h4 id="对象引用"><a href="#对象引用" class="headerlink" title="对象引用"></a>对象引用</h4><blockquote><p>（可自行搜索）</p></blockquote><h3 id="Java基础常考点-Map"><a href="#Java基础常考点-Map" class="headerlink" title="Java基础常考点 - Map"></a>Java基础常考点 - Map</h3><h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><ul><li><p>通过数组加链表实现</p><blockquote><p>数组中的元素为一个链表，通过计算存入对象的 hashcode，确认存入位置，用链表解决散列冲突，链表的节点存入的是键值对</p></blockquote></li><li><p>填充因子的作用</p></li><li><p>Map 扩容的 rehash 机制</p></li><li><p>容量是二的幂次方</p><blockquote><p>是为了方便按位与操作计算余数，比求模更快</p></blockquote></li><li><p>多线程风险的原因</p><blockquote><p>对线程 put 时，会在超过填充因子的情况下 rehash.HashMap 为避免尾部遍历，链表插入采用头插法，多线程场景下可能产生死循环</p></blockquote></li></ul><h4 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4><ul><li><p>分段锁思想</p><blockquote><p>1.7 中采用 segment 分段加锁，降低并发锁定程度</p></blockquote></li><li><p>CAS 自旋锁</p><blockquote><p>1.8 中采用 CAS 自旋锁（一种乐观锁实现模式）提高性能，但在并发度较高时，性能一般</p></blockquote></li><li><p>红黑树</p><blockquote><p>1.8 引入红黑树解决 hash 冲突时的链表查找问题，在链表长度大于 8 且总容量大于 64 时启用，扩容后链表长度小于 6 时重新转为一般链表（8,6,64为默认参数）</p></blockquote></li></ul><h3 id="Java-版本特性"><a href="#Java-版本特性" class="headerlink" title="Java 版本特性"></a>Java 版本特性</h3><h4 id="1-8"><a href="#1-8" class="headerlink" title="1.8"></a>1.8</h4><ol><li>Lambda 表达式</li><li>StreamAPI</li><li>方法引用</li><li>接口默认方法</li><li>Metaspace 替换 PremGen</li></ol><h4 id="1-9-1-10"><a href="#1-9-1-10" class="headerlink" title="1.9 - 1.10"></a>1.9 - 1.10</h4><ol><li>模块系统</li><li>默认 G1 回收器</li><li>接口私有方法</li><li>局部变量判断</li><li>Graal 编译器</li></ol><h4 id="1-11"><a href="#1-11" class="headerlink" title="1.11"></a>1.11</h4><ol><li>ZGC</li><li>字符串 API 增强</li><li>内建 HTTP Client</li></ol><h3 id="面试考察点"><a href="#面试考察点" class="headerlink" title="面试考察点"></a>面试考察点</h3><h4 id="基本概念和基本原理"><a href="#基本概念和基本原理" class="headerlink" title="基本概念和基本原理"></a>基本概念和基本原理</h4><ol><li>理解正确清晰</li><li>网络协议 4/7 层模型的概念</li><li>TCP 协议流量控制的实现原理</li><li>……</li></ol><h4 id="实现方法和使用方法"><a href="#实现方法和使用方法" class="headerlink" title="实现方法和使用方法"></a>实现方法和使用方法</h4><ol><li>HashMap 在 JDK 1.8 中的实现方式</li><li>单例模式有哪几种实现方式，什么场景该使用静态方法实现，什么场景该使用双检锁实现</li><li>……</li></ol><h4 id="经常用到的知识点"><a href="#经常用到的知识点" class="headerlink" title="经常用到的知识点"></a>经常用到的知识点</h4><ol><li>常用的 Linux 命令有哪些，用来解决什么样的问题</li><li>……</li></ol><h4 id="实际应用中容易犯错的点"><a href="#实际应用中容易犯错的点" class="headerlink" title="实际应用中容易犯错的点"></a>实际应用中容易犯错的点</h4><ol><li>== 与 equals 区别是什么</li><li>对象强引用使用不当会导致内存泄露，考察不同引用方式和作用的理解</li><li>……</li></ol><h4 id="与面试方向相关的知识点"><a href="#与面试方向相关的知识点" class="headerlink" title="与面试方向相关的知识点"></a>与面试方向相关的知识点</h4><ol><li>中间件、存储、网络相关的考察</li><li>……</li></ol><h3 id="加分项"><a href="#加分项" class="headerlink" title="加分项"></a>加分项</h3><ul><li><p>知识点与典型的业务场景关联</p><blockquote><p>如：谈到设计模式时，可以讲 XX 框架在解决 XX 问题时使用了那种设计模式</p></blockquote></li><li><p>以反例来描述实际场景中误用的危害</p><blockquote><p>如：大量使用反射会影响性能</p></blockquote></li><li><p>与知识点相关的优化点</p><blockquote><p>如：讲到 TCP 建连和断连时，如遇到洪水攻击或大量 TIME_WAIT 时，可以调整系统参数预防</p></blockquote></li><li><p>与知识点相关的最新技术趋势</p><blockquote><ul><li>如：讲到 ConcurrentHashMap，可以介绍 1.8 的改进细节</li><li>或：讲到 HTTP 时，能说出 HTTP2 和 QUIC 的特点和实现</li></ul></blockquote></li><li><p>在了解的前提下，尽量增加回答内容的深度</p><blockquote><p>如：讲到 TCP 的滑动窗口时，能讲到流量与拥塞控制，进一步能指出解决拥塞的不同算法</p></blockquote></li></ul><h3 id="真题汇总"><a href="#真题汇总" class="headerlink" title="真题汇总"></a>真题汇总</h3><h4 id="1-进程和线程的区别和联系"><a href="#1-进程和线程的区别和联系" class="headerlink" title="1. 进程和线程的区别和联系"></a>1. 进程和线程的区别和联系</h4><blockquote><p>从资源占用，切换效率，通信方式等方面回答</p></blockquote><h4 id="2-简单介绍一下进程的切换过程"><a href="#2-简单介绍一下进程的切换过程" class="headerlink" title="2. 简单介绍一下进程的切换过程"></a>2. 简单介绍一下进程的切换过程</h4><blockquote><p>线程上下文的切换代价，要回答，切换会保存寄存器、栈等线程相关的现场，需要由用户态切换到内核态，可以用 vmstat 命令查看线程上下文的切换情况</p></blockquote><h4 id="3-你经常使用哪些-Linux-命令，主要用来解决哪些问题"><a href="#3-你经常使用哪些-Linux-命令，主要用来解决哪些问题" class="headerlink" title="3. 你经常使用哪些 Linux 命令，主要用来解决哪些问题"></a>3. 你经常使用哪些 Linux 命令，主要用来解决哪些问题</h4><h4 id="4-为什么-TCP-建连需要-3-次握手，而断连需要-4-次"><a href="#4-为什么-TCP-建连需要-3-次握手，而断连需要-4-次" class="headerlink" title="4. 为什么 TCP 建连需要 3 次握手，而断连需要 4 次"></a>4. 为什么 TCP 建连需要 3 次握手，而断连需要 4 次</h4><h4 id="5-为什么-TCP-关闭连接时需要-TIME-WAIT-状态，为什么要等-2MSL"><a href="#5-为什么-TCP-关闭连接时需要-TIME-WAIT-状态，为什么要等-2MSL" class="headerlink" title="5. 为什么 TCP 关闭连接时需要 TIME_WAIT 状态，为什么要等 2MSL"></a>5. 为什么 TCP 关闭连接时需要 TIME_WAIT 状态，为什么要等 2MSL</h4><h4 id="6-一次完整的-HTTP-请求过程是怎样的"><a href="#6-一次完整的-HTTP-请求过程是怎样的" class="headerlink" title="6. 一次完整的 HTTP 请求过程是怎样的"></a>6. 一次完整的 HTTP 请求过程是怎样的</h4><blockquote><p>DNS 解析，TCP 建连，HTTP 请求，HTTP 响应等</p></blockquote><h4 id="7-HTTP2-和-HTTP-的区别有哪些"><a href="#7-HTTP2-和-HTTP-的区别有哪些" class="headerlink" title="7. HTTP2 和 HTTP 的区别有哪些"></a>7. HTTP2 和 HTTP 的区别有哪些</h4><h4 id="8-在你的项目中你使用过哪些设计模式，主要用来解决哪些问题"><a href="#8-在你的项目中你使用过哪些设计模式，主要用来解决哪些问题" class="headerlink" title="8. 在你的项目中你使用过哪些设计模式，主要用来解决哪些问题"></a>8. 在你的项目中你使用过哪些设计模式，主要用来解决哪些问题</h4><h4 id="9-Object-中的-equals-和-hashcode-的作用分别是什么"><a href="#9-Object-中的-equals-和-hashcode-的作用分别是什么" class="headerlink" title="9. Object 中的 equals 和 hashcode 的作用分别是什么"></a>9. Object 中的 equals 和 hashcode 的作用分别是什么</h4><h4 id="10-final，-finally，-finalize-的区别于使用场景"><a href="#10-final，-finally，-finalize-的区别于使用场景" class="headerlink" title="10. final， finally， finalize 的区别于使用场景"></a>10. final， finally， finalize 的区别于使用场景</h4><h4 id="11-简单表述一下-Java-的异常机制"><a href="#11-简单表述一下-Java-的异常机制" class="headerlink" title="11. 简单表述一下 Java 的异常机制"></a>11. 简单表述一下 Java 的异常机制</h4><h4 id="12-线上使用的哪个版本-JDK，-为什么使用这个版本（有什么特色）"><a href="#12-线上使用的哪个版本-JDK，-为什么使用这个版本（有什么特色）" class="headerlink" title="12. 线上使用的哪个版本 JDK， 为什么使用这个版本（有什么特色）"></a>12. 线上使用的哪个版本 JDK， 为什么使用这个版本（有什么特色）</h4>]]></content>
      
      
      <categories>
          
          <category> 未分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无标签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>年轻人何以成为“隐形贫困人口”？</title>
      <link href="/posts/20180503161755/"/>
      <url>/posts/20180503161755/</url>
      
        <content type="html"><![CDATA[<blockquote><p>长的是磨难，短的是人生，在惘惘莫名的威胁感下，“人们受不了这个，急于攀住一点踏实的东西”，于是“从柴米油盐、肥皂、水与太阳之中去找寻实际的人生”</p></blockquote><p>“佛系青年”还言犹在耳，同龄人“抛弃”你也没过多久，“隐形贫困人口”这个词火了。根据网络定义，隐形贫困人口是指“那些看起来每天有吃有喝，但实际上非常穷的人”。</p><p><img src="/posts/20180503161755/%E9%9A%90%E5%BD%A2%E8%B4%AB%E5%9B%B0%E4%BA%BA%E5%8F%A3.png" class="lazyload" data-srcset="/posts/20180503161755/%E9%9A%90%E5%BD%A2%E8%B4%AB%E5%9B%B0%E4%BA%BA%E5%8F%A3.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="隐形贫困人口"></p><p>“能买戴森吸尘器就不用扫帚了；吃完牛油果又要吃藜麦了；100块钱一张的‘前男友面膜’用起来也不心疼；一有健身冲动，就非得去办张年卡。总之，朋友圈光鲜靓丽，口袋空空如也，‘吃土’是常态，在精致道路上拿出十八般武艺、拼尽全力。”在“隐形贫困人口”的相关评析文章中，“隐形贫困人口”被认定是“自我消费不节制所造成的”，正是因为想过得富一点，所以把日过得穷了。甚至有人认为，“隐形贫困人口”与之前流行的“月光族”“啃老族”没有太大区别。</p><p>不过将年轻人的“贫困”归咎于消费主义和消费的不节制，是否会遮蔽了一些什么？比如许多年轻人“非常穷”，倒不是因为他们将钱花费在吃好喝好上了，而是因为他们真的穷。即便有年轻人将大部分的金钱花在吃好喝好上，仅仅是因为他们热衷消费，还是背后有什么更深层次的原因？比如究竟是热衷消费导致了贫困，还是因为贫困所以热衷消费？</p><p>总之，一个热词背后往往蕴藏着重要的社会心理信息，“隐形贫困人口”的理论景深值得细究。</p><h2 id="大众传媒时代的“贫困感”"><a href="#大众传媒时代的“贫困感”" class="headerlink" title="大众传媒时代的“贫困感”"></a><strong>大众传媒时代的“贫困感”</strong></h2><p>身边一位50后的长辈学者，对现在年轻人老是说自己“贫困”“丧”很是不屑。在他看来，物质生活好了，年轻人都是蜜罐中长大，身在福中不知福，还养了一身矫情的本领。他说，他们那一辈人的成长岁月里，物质短缺、缺衣少食，饥饿是家常便饭，现在年轻人所能享受到的丰富和便捷的物质生活，是他们那个时代的人从来都不敢想的事。怎么现在的80后、90后、00后，动不动就觉得自己那一代人是“最不幸的”？</p><p>长辈的质疑，纵然有代际隔阂的因素，却也提出了一个重要的问题，即怎么物质生活越来越好，自称“贫困”的人却越来越多了？这与其说是这一代年轻人矫情，毋宁说，老一辈与年轻人对于“贫困”的认定和感知是不一样的。在老一辈那里，贫困更多意味着最基本的生存需求无法满足，但在新一代年轻人这里，不贫困不仅仅意味着有吃有喝，还意味着吃好喝好，甚至更多。那么，年轻人的贫困阈值，是如何不断提高的？</p><p>这里不得不着重强调的是，高度发达的大众传媒对年轻人观念的影响。我们已经进入了一个大众传媒时代，传媒榫入日常生活的方方面面，并不断塑造着人们的认知。文化学者南帆指出，“现代社会的标志是我们被抛入了大众传媒组织起来的社会，大众传媒就是我们的文化感官。几张报纸、几个电视频道或者几个网站就布置出了一个大千世界的幻象。”而这个幻象的核心是，种种幸福生活的神话。阿兰·德波顿在《身份的焦虑》一书中写道，“报刊和社会舆论没完没了的鼓噪，让每个生活在底层的人都相信他们总有机会攀上社会金字塔的塔尖，有机会成为实业家、大法官、科学家，甚至是总统。这种无限机遇的论调在一开始也许能给人一种盲目的乐观，对那些底层的年轻人尤甚。”</p><p><img src="/posts/20180503161755/%E5%8F%97%E4%BC%97%E5%8A%B3%E5%8A%A8.png" class="lazyload" data-srcset="/posts/20180503161755/%E5%8F%97%E4%BC%97%E5%8A%B3%E5%8A%A8.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="受众劳动"></p><blockquote><p>▲ “受众劳动”，英文Audience Labour，由Smythe在1977年提出，他认为在闲暇时间收看电视、阅读报纸的“受众”实际是为广告商工作，是广告支持下的传播业所生产的一种特殊商品。传统的马克思主义研究没有对传播体系的经济作用给予足够的关注，生产这种学习消费的受众是大众</p></blockquote><p>我们每时每刻都在被成功人士的故事包围，哪个年轻人月薪5万，哪个年轻人创业成功一跃成为亿万富翁；即便是电视里的广告，不断宣扬的也是一种中产阶层的生活样本：一栋别墅，阳光照射进来，漂亮的妻子在做家务，小孩在快乐地玩耍……</p><p><strong>身边的幸福神话太多，其结果就是知名作家韩少功所说的，“每个人都可以找到足够根据，来发现自己的贫困”。跟胡玮炜相比，年薪30万的码农是贫困的；跟北京三环有一套房的人相比，三线城市有一套房的人是贫困的……“人们从现代文化工业那里获取了太多的感受能力及其知识装备，也从文化工业那里接受了太多有关人类幸福的神话，于是特别容易产生自我感觉的模拟演习，直至在心理上自伤”。</strong></p><p>也即，许多年轻人自嘲“隐形贫困”，倒不见得他们是真的贫困，他们的“贫困感”有可能是来自于传媒时代的文本感染和广告后遗症，来自于与幸福神话的对照和攀比。“这个社会的传媒技术已经市场化或者权力化，受控于资本化的权力或者权力化的资本”（韩少功语），权力和资本媾和打造幸福神话，才能源源不断激发受众的“贫困感”，激发他们的消费冲动，并让他们心甘情愿成为消费的“顺民”。</p><p>从这个角度看，某些人自嘲“隐形贫困人口”，倒真有可能是一种矫情，是不断夸大的心理自伤。</p><h2 id="不断壮大的“穷忙族”"><a href="#不断壮大的“穷忙族”" class="headerlink" title="不断壮大的“穷忙族”"></a><strong>不断壮大的“穷忙族”</strong></h2><p>不过，时代不断进步的标志本来就是，人们对贫困标准的认定在不断提高。以前吃好喝好就是不贫困，但如果几十年过去了，人们的需求依旧停留在马斯洛需求层次的最低阶段，那么这绝对称不上一个好的时代。虽然攀比逻辑值得检讨，但比烂逻辑更是要不得。</p><p>应该看到，“隐形贫困人口”的自嘲，固然不乏大众传媒时代滋生的“贫困感”，但更多可能是出于一种贫困实感。这种贫困实感，或来自于生存和发展的需求得不到满足，或来自于安全、尊重以及自我实现的需求得不到满足。比如纵向对比，现在年轻人的物质生活的确比上世纪五六十年代好多了，但与当下时代的生活成本、发展前景等横向比较，这一代年轻人的处境就不见得比老一辈更好。</p><p>在“隐形贫困人口”这个词走红之前，另一个与贫困有关的词汇，就长久地成为不少年轻人对自我生存状态的概括，即“穷忙族”（working poor）。该词源于欧美国家，欧盟对其定义是“在工作却入不敷出，甚至沦落到贫穷线以下的受雇者”。按照常理，付出跟收入应该呈正相关，但如今越来越多的年轻人却是越穷越忙，越忙越穷；他们一直在努力工作，生活状态却不见根本性的改善。</p><p><img src="/posts/20180503161755/%E7%A9%B7%E5%BF%99%E6%97%8F.png" class="lazyload" data-srcset="/posts/20180503161755/%E7%A9%B7%E5%BF%99%E6%97%8F.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="穷忙族"></p><blockquote><p>▲ NHK纪录片《穷忙族》。 © 知乎</p></blockquote><p>2017年12月，中山大学社会科学调查中心发布《中国劳动力动态调查：2017年报告》显示，中国劳动力每周工作时间在50或50小时以上的分别为43.90%、42.57%，比例均超过四成。“996”（工作日早9点上班，晚上9点下班，中午和晚上休息1小时甚至更少，并且一周工作6天的工作制度）成为许多年轻人的工作常态，越是大的、节奏快的城市越是如此，他们在办公室的时间甚至比跟家人在一起的时间更多。曾有深受加班困扰的白领说，“如果不是大楼高层的窗户不能打开，很多人都可能已经跳下去了。”</p><p>但不少年轻人努力付出，他们却变得“越来越穷”，他们的收入增速远低于国民收入的增速。腾讯·今日话题在一篇文章中指出，对比应届毕业生平均薪资增速和居民人均可支配收入增速可发现，在2012-2015年，刚毕业大学生工资的整体增速赶不上社会平均水平。在很大程度上，毕业生就是年轻人的代表。不去考虑大学毕业生起薪低的问题，这个群体的工资增速没有和社会整体同步，年轻人存在“相对贫困”的问题，他们正成为“失落的阶层”。</p><p>除了工作强度大、工资低，更令年轻人困扰和焦虑的，还在于他们未来前景的“不稳定”，即便他们勤勤恳恳地工作，也随时可能有失业的风险。土逗公社在一篇文章中，讨论了Alex Foti在《“不稳定无产者”的一般性理论》（General Theory of thePrecariat）一书中提出的“不稳定的无产者”（Precariat）这一概念。Precariat来自于precarious（不稳定的）和proletariat（无产阶级）两个词的组合，它指涉的是处于不稳定雇佣关系中的无产者：低工资、缺乏劳动保护、没有社会保障、随时需要工作也随时可能被解雇；而90后、00后正在成为precariat中最重要的部分。</p><p>一边是“穷忙族”的生活和工作状态，一边是高不可攀的房价、高昂的生活成本、看不到预期的未来——许多年轻人何止是“隐形贫困人口”，他们是实实在在的贫困。</p><h2 id="用消费来安慰苦难的人生"><a href="#用消费来安慰苦难的人生" class="headerlink" title="用消费来安慰苦难的人生"></a><strong>用消费来安慰苦难的人生</strong></h2><p>矛盾的地方就在于，如果很多年轻人是真的贫困，可他们为何如此热衷于消费主义？不少社会学家都留意到这样一个现象，月收入不高的流水线年轻工人，所使用的手机常常是价格最为昂贵的iphone系列。究竟是消费导致他们沦为贫困，还是因为贫困所以他们更热衷于消费？</p><p>按照文化学者王晓明先生的分析，今天的中国人“同时受制于三个社会系统”：“第一个是国家机器主导的政治系统，它以‘维稳’为宗旨，竭力加固那种‘除了适应现实，我们别无选择’普遍意识。第二个是中国特色的市场经济系统，它通过各种具体的成文和不成文法，持续训练人接受这样的自我定位，‘现代人，就是如下两面的结合：合乎市场需求的劳动力，和具有不可控制的消费冲动的消费者’。第三个日常生活系统，它安排人以‘居家’为中心，组织自己的大部分人生内容，从儿童时代接受学校教育开始，一直到老。这个系统持续地发展一种具有极宽的包含力的‘居家文化’，对人潜移默化，要将他造得除了‘居家’的舒适，别的什么都不在意。”</p><p><img src="/posts/20180503161755/%E6%B6%88%E8%B4%B9%E5%8D%87%E7%BA%A7.png" class="lazyload" data-srcset="/posts/20180503161755/%E6%B6%88%E8%B4%B9%E5%8D%87%E7%BA%A7.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="消费升级"></p><blockquote><p>▲ 近年来，消费金额持续上涨，形成消费升级的浪潮。 © 国务院</p></blockquote><p>埃里克·霍弗在《狂热分子》中也分析道，“当我们的生活朝不保夕，完全无力控制我们的生存环境时，就会执着于熟悉的生活方式。我们通过把生活模式固定化去对抗深深的不安全感。借此我们给自己制造了一种幻象：不可预测性已为我们所驯服。”也即，在艰难的生存现实面前，中国年轻人只能愈发投入于可预测、可掌控的消费与居家文化中，对日常生活系统的消费和呵护成为一种潮流。</p><p><strong>这颇像张爱玲说的，长的是磨难，短的是人生，在惘惘莫名的威胁感下，“人们受不了这个，急于攀住一点踏实的东西”，于是“从柴米油盐、肥皂、水与太阳之中去找寻实际的人生”。年轻人买不起房子，却买得起一些让自己感受更好的居家用品，诚如学者严锋分析的，“人是渴望改变的，生活是很难改变的，生活中只有电子产品最容易改变，所以只能从电子产品的更新中获得一种虚幻的改变感，安慰苦难的人生。”</strong></p><p>因此，不少对“隐形贫困人口”的批评颠倒了因果，并非“月光族”让年轻人贫困，而是因为贫困，年轻人只剩下哈维尔所说的那种“自由地选择哪一种牌子的冰箱和洗衣机”的自由了。</p><p>哈维尔深刻地指出，这种只热衷于消费主义的倾向会加剧公众的政治冷漠，贫困的状态将更难改变。“一个人越是彻底放弃任何全面转变的希望，放弃任何超越个人的目标和价值，或任何对一种‘外在’（即指公共事务，笔者注）方面发挥影响的机会，他的能量就转向阻力最小的方面，即‘内在’（指私人的物质生活，笔者注）。今天的人们一心一意地想着自己的家庭和房子，他们在那儿找到安息，忘掉世界的愚蠢……”“<strong>通过将每一个人的注意力集中在他仅仅是消费品的兴趣上，是希望使他没有能力意识到在他精神上、政治上、道德上日益增长的被侵犯的程度。将他缩减成一个初级消费品社会的各种观念的简单容器，是打算将他变成复杂操纵的顺从的材料。</strong>”</p><p>这或许才是“隐形贫困人口”背后的消费主义倾向值得我们高度警惕的地方。以消费安慰困难的人生，获取一点虚幻的改变感，是个人权利，也无可厚非；但我们切勿在权力和资本的鼓动下，全情投入到消费主义的怀抱中，尝到一点消费主义的甜头后，便心甘情愿地忍受贫困和剥削。要打破贫困，根本上应该打破“除了适应现实，我们别无选择”的政治意识，走出政治冷漠，积极参与每一次公共事务，积极维护个人的权益不受侵犯。</p><p>这很难，但想改变被剥夺和不公制造的贫困状态，就得从现在做起。</p><p>——首发<strong>南都观察</strong>——</p><blockquote><p>版权归作者所有，任何形式转载请联系作者。<br>作者：曾于里（来自豆瓣）<br>来源：<a href="https://www.douban.com/note/667467299/">https://www.douban.com/note/667467299/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 未分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无标签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多元思维模型</title>
      <link href="/posts/20171023184559/"/>
      <url>/posts/20171023184559/</url>
      
        <content type="html"><![CDATA[<p><img src="/posts/20171023184559/%E9%87%87%E9%93%9C-%E5%A5%BD%E4%B9%A6%E7%B2%BE%E8%AF%BB.jpg" class="lazyload" data-srcset="/posts/20171023184559/%E9%87%87%E9%93%9C-%E5%A5%BD%E4%B9%A6%E7%B2%BE%E8%AF%BB.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="采铜-好书精读"></p><p>查理芒格认为，现实世界的种种问题，很少是正好落在某一个学科的界限里面的，而往往是横跨多个学科的。但是我们传统的教育又是以学科和专业划界来培养人才。你是哪个专业的，你就只了解这个专业的知识，对别的学科知识一窍不通。一个心理学专业的人，一般不会懂经济学，而一个经济学专业的人，一般也不会懂心理学。但是当你在现实世界中要解决问题的时候，就发现这种狭窄的知识结构很成问题。</p><h3 id="多元思维模型帮助你正确进行【价值投资】"><a href="#多元思维模型帮助你正确进行【价值投资】" class="headerlink" title="多元思维模型帮助你正确进行【价值投资】"></a><strong>多元思维模型帮助你正确进行【价值投资】</strong></h3><p>我们可能只是简单地认为，价值投资就是不投机，做长线，找有成长性的股票长期持有。道理很多人都懂，但是做不到。为什么？因为你不具备巴菲特和芒格这样的多元知识结构。说白点，就是没有像他们那样懂那么多。所以，价值投资的精华不在于长期持有这样的一种理念，而是你用什么样的知识来挑选出哪家公司是值得长期持有的，这才是特别显功力的地方。</p><h3 id="我们应该掌握什么样的【普世智慧】"><a href="#我们应该掌握什么样的【普世智慧】" class="headerlink" title="我们应该掌握什么样的【普世智慧】"></a><strong>我们应该掌握什么样的【普世智慧】</strong></h3><p>按照芒格的说法，首先我们并不需要了解所有的学科，我们只要了解最重要的那几个学科就可以了，比如 <strong>数学、物理学、化学、工程学、生物学、心理学、经济学、统计学</strong> 等；其次，对于每一个学科，我们也只需要了解它其中最基本的那几个模型就可以了。掌握了这些基本模型，实际上就掌握了这些学科最主要的智慧。这些基本模型大概有一百个左右，其中最重要的模型，有 <strong>数学中的复利原理，排列组合原理，物理学中的临界点、倾覆力矩，化学中的自我催化模型，生物学中的现代达尔文模型，工程学中的冗余备份模型，</strong> 还有 <strong>心理学中的认知误判模型</strong> 等。</p><p>这些模型就组成了芒格所说的“多元思维模型”。这些模型正是我们每个人都应该掌握的“普世价值”。</p><blockquote><p>以上内容摘自：【采铜-好书精读】——《穷查理宝典》：三个核心思维方法，吸收巴菲特搭档的人生智慧</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 未分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无标签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL子查询总结：相关子查询与非相关子查询有什么区别</title>
      <link href="/posts/20161126103127/"/>
      <url>/posts/20161126103127/</url>
      
        <content type="html"><![CDATA[<blockquote><p>如果一个select语句能够返回单个值或者一列值，且该select语句嵌套在另一个SQL语句（例如select语句、insert语句、update语句或者delete语句）中，那么该select语句成为“子查询”（也叫内层查询），包含子查询的SQL语句称为“主查询”（也叫外层查询）。为了标记子查询与主查询之间的关系，通常将子查询写在小括号内。子查询一般用在主查询的where子句或having子句中，与比较运算符或者逻辑运算符一起构成where筛选条件或having筛选条件。子查询分为“相关子查询”（Dependent Subquery）与“非相关子查询”。</p></blockquote><h2 id="非相关子查询"><a href="#非相关子查询" class="headerlink" title="非相关子查询"></a><strong>非相关子查询</strong></h2><p>如果子查询返回单个值，则可以讲一个表达式的值与子查询的结果进行比较。<br>例如，检索成绩比学生张三平均分高的所有学生及课程的信息， 可以使用下面的SQL语句， 执行结果如下图。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> class_name, student.student_no, student_name, course_name, score</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">from</span> classes <span class="keyword">join</span> student <span class="keyword">on</span> student.class_no <span class="operator">=</span> classes.class_no</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">join</span> choose <span class="keyword">on</span> choose.student_no <span class="operator">=</span> student.student_no</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">join</span> course <span class="keyword">on</span> choose.course_no <span class="operator">=</span> course.course_no</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">where</span> score <span class="operator">&gt;</span> (</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">select</span> <span class="built_in">avg</span>(score)</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">from</span> student, choose</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">where</span> student.student_no <span class="operator">=</span> choose.student_no <span class="keyword">and</span> student_name <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> );</span><br></pre></td></tr></table></figure><p><img src="/posts/20161126103127/%E9%9D%9E%E7%9B%B8%E5%85%B3%E5%AD%90%E6%9F%A5%E8%AF%A2.png" class="lazyload" data-srcset="/posts/20161126103127/%E9%9D%9E%E7%9B%B8%E5%85%B3%E5%AD%90%E6%9F%A5%E8%AF%A2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="非相关子查询"></p><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a><strong>说明</strong></h3><p>该示例中的子查询是一个单独的select语句，可以不依赖主查询单独运行。这种不依靠主查询，能够独立运行的子查询称为<strong>“非相关子查询”</strong>。</p><h3 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a><strong>执行过程</strong></h3><ol><li>执行子查询，其结果不被显示，而是传递给外部查询，作为外部查询的条件使用。</li><li>执行外部查询，并显示整个结果。</li></ol><h2 id="相关子查询"><a href="#相关子查询" class="headerlink" title="相关子查询"></a><strong>相关子查询</strong></h2><p>下面的示例演示了相关子查询，代码<strong>第七行</strong>标记了两条子查询语句之间的区别（其他SQl代码完全相同），执行结果如下图。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> class_name, student.student_no, student_name, course_name, score</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">from</span> classes <span class="keyword">join</span> student <span class="keyword">on</span> student.class_no <span class="operator">=</span> classes.class_no</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">join</span> choose <span class="keyword">on</span> choose.student_no <span class="operator">=</span> student.student_no</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">join</span> course <span class="keyword">on</span> choose.course_no <span class="operator">=</span> course.course_no</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">where</span> score <span class="operator">&gt;</span> (</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">select</span> <span class="built_in">avg</span>(score)</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">from</span> choose</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">where</span> student.student_no <span class="operator">=</span> choose.student_no <span class="keyword">and</span> student_name <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> );</span><br></pre></td></tr></table></figure><p><img src="/posts/20161126103127/%E7%9B%B8%E5%85%B3%E5%AD%90%E6%9F%A5%E8%AF%A2.png" class="lazyload" data-srcset="/posts/20161126103127/%E7%9B%B8%E5%85%B3%E5%AD%90%E6%9F%A5%E8%AF%A2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="相关子查询"></p><h3 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a><strong>说明</strong></h3><p>从执行结果可以看到，子查询可以仅仅使用自己定义的数据源，也可以“直接引用”主查询中的数据源，但两者意义完全不同。</p><ol><li>如果子查询中仅仅使用了自己定义的数据源， 这种查询是<strong>非相关子查询</strong>。 非相关子查询是独立于外部查询的子查询， 子查询总共执行一次， 执行完毕后将值传递给主查询。</li><li>如果子查询中使用了主查询的数据源， 这种查询是<strong>相关子查询</strong>， 此时主查询的执行与相关子查询的执行<strong>相互依赖</strong>。</li></ol><h3 id="执行过程-1"><a href="#执行过程-1" class="headerlink" title="执行过程"></a><strong>执行过程</strong></h3><ol><li>从外层查询中取出一个元组，将元组相关列的值传递给内层查询。</li><li>执行内层查询，得到子查询操作的值。</li><li>外查询根据子查询返回的结果或结果集得到满足条件的行。</li><li>然后外层查询取出下一个元组重复做步骤1-3，直到外层的元组全部处理完毕。</li></ol><h2 id="如何区分"><a href="#如何区分" class="headerlink" title="如何区分"></a><strong>如何区分</strong></h2><p>说了这么多，那我们该如何快速区分非相关子查询和相关子查询呢？</p><p><strong>最简单</strong>的办法的就是直接看子查询本身能否执行。比如执行上面的例子中的子查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="built_in">avg</span>(score)</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">from</span> choose</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">where</span> student.student_no <span class="operator">=</span> choose.student_no <span class="keyword">and</span> student_name <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="/posts/20161126103127/%E5%AD%90%E6%9F%A5%E8%AF%A2.png" class="lazyload" data-srcset="/posts/20161126103127/%E5%AD%90%E6%9F%A5%E8%AF%A2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="子查询"></p><p>会报错：<code>1054 - Unknown column &#39;student.student_no&#39; in &#39;where clause&#39;</code><br>这样的查询语句构成的子查询便为<strong>相关子查询</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 未分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无标签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解Java中的向上转型</title>
      <link href="/posts/20161125205723/"/>
      <url>/posts/20161125205723/</url>
      
        <content type="html"><![CDATA[<p>“为新的类提供方法”并不是继承技术中最重要的方面，其最重要的方面是用来表现新类和基类之间的关系。这种关系可以用“<strong>新类是现有类的一种类型</strong>”这句话加以概括。</p><p>这个描述并非只是一种解释继承的华丽的方式，这直接是由语言所支撑的。例如，假设有一个<code>Instrument</code>的代表乐器的基类和一个称谓<code>Wind</code>的导出类。由于继承可以确保基类中所有的方法在导出类中也同样有效，所以能够向基类发送的所有信息同样也可以向导出类发送。如果<code>Instrument</code>类具有一个<code>play()</code>方法，那么<code>Wind</code>乐器也将同样具备。这意味着我们可以准确地说<code>Wind</code>对象也是一种类型的<code>Instrument</code>。下面这个例子说明了编译器是怎样支持这一概念的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Instrument</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">tune</span><span class="params">(Instrument i)</span> &#123;</span><br><span class="line"><span class="comment">/* --- */</span></span><br><span class="line">i.play();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Wind</span> <span class="keyword">extends</span> <span class="title class_">Instrument</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Wind</span> <span class="variable">flute</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Wind</span>();</span><br><span class="line">Instrument.tune(flute); <span class="comment">// 向上转型</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此例中，<code>tune()</code>方法可以接受<code>Instrument</code>引用，这实在太有趣了。但在<code>Wind.main()</code>中，传递给<code>tune()</code>方法的是一个<code>Wind</code>引用。鉴于Java对类型的检查十分严格，接受某种类型的方法同样可以接受另外一种类型就会显得很奇怪，除非你认识到<code>Wind</code>对象同样也是一种<code>Instrument</code>对象，而且也不存在任何<code>tune()</code>方法是可以通过<code>Instrument</code>来调用，同时又不存在于<code>Wind</code>之中。在<code>tune()</code>中，程序代码可以对<code>Instrument</code>和它所有的导出类起作用，这种将<code>Wind</code>引用转换为<code>Instrument</code>引用的动作，我们称之为<strong>向上转型</strong>。</p><h3 id="为什么称为向上转型"><a href="#为什么称为向上转型" class="headerlink" title="为什么称为向上转型"></a><strong>为什么称为向上转型</strong></h3><p>该术语的使用有其历史原因，并且是以传统的类继承图的绘制方法为基础的：将根置于页面的顶端，然后逐渐向下。（当然也可以以任何你认为有效的方法进行绘制。）于是，<strong>Wind.java</strong>的继承图就是：</p><p><img src="/posts/20161125205723/%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B.png" class="lazyload" data-srcset="/posts/20161125205723/%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="向上转型"></p><p>由于导出类转型成基类，在继承图上是向上移动的，因此一般称为<strong>向上转型</strong>。由于向上转型是从一个较专用类型向较通用类型转换，所以总是很安全的。也就是说，导出类是基类的一个超集。它可能比基类含有更多的方法，但它必须至少具备基类中所含有的方法。在向上转型的过程中，类接口唯一可能发生的事情是丢失方法，而不是获取它们。这就是为什么编译器在“未曾明确表示转型”或“未曾指定特殊标记”的情况下，仍然允许向上转型的原因。</p><h3 id="再论组合与继承"><a href="#再论组合与继承" class="headerlink" title="再论组合与继承"></a><strong>再论组合与继承</strong></h3><p>在面向对象编程中，生成和使用程序代码最有可能采用的方法就是直接将数据和方法包装进一个类中，并使用该类的对象。也可以运用组合技术使用现有类来开发新的类；而继承技术其实是不太常用的。因此尽管在教授OOP的过程中我们多次强调继承，但这并不意味着要尽可能使用它。相反应当慎用这一技术，其使用场合仅限于你确信使用该技术确实有效的情况。<strong>到底是该用组合还是用继承，一个最清晰的判断方法就是问一问自己是否需要从新类向基类进行向上转型。</strong>如果必须向上转型，则继承是必要的；但如果不需要，则应当好好考虑自己是否需要继承。</p>]]></content>
      
      
      <categories>
          
          <category> 未分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无标签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java赋值操作符注意事项及方法调用中的别名问题</title>
      <link href="/posts/20161118161622/"/>
      <url>/posts/20161118161622/</url>
      
        <content type="html"><![CDATA[<p>让我们先来回顾一下Java中的一些特性 ~~</p><h2 id="一切都是对象"><a href="#一切都是对象" class="headerlink" title="一切都是对象"></a><strong>一切都是对象</strong></h2><p><strong>“如果我们说另一种不同的语言，那么我们就会发觉一个有些不同的世界。”</strong><br><strong><center>——Luduing Wittgerstein(1889-1951)</center></strong></p><p><strong>尽管Java是基于C++的，但是相比之下，Java是一种更“纯粹”的面向对象程序设计语言。</strong></p><p>Java语言假设我们只是进行面向对象的程序设计。也就是说，在开始用Java进行设计之前，必须将思想转化到面向对象的世界中来。这个入门基本功，可以使你具备使用这样一门编程语言编程的能力，这种语言学习起来更简单，也比许多其他OOP语言更易用。</p><h2 id="用引用操作对象"><a href="#用引用操作对象" class="headerlink" title="用引用操作对象"></a><strong>用引用操作对象</strong></h2><p>每种编程语言都有自己的操作内存中元素的方式。有时候，程序员必须注意将要处理的数据是什么类型。你是直接操作元素， 还是用某种给予特殊语法的间接表示（例如C和C++里的指针）来操作对象？</p><p>所有这一切在Java里都得到了简化。一切都被视为对象，因此可采用单一固定的语法。尽管一切都看做对象，但操作的标识符实际上是对象的一个“引用”（reference）。</p><h2 id="特例（基本类型）"><a href="#特例（基本类型）" class="headerlink" title="特例（基本类型）"></a><strong>特例（基本类型）</strong></h2><p>在程序设计中经常用到一系列类型，他们需要特殊对待。可以把它们想象成“基本”类型。之所以特殊对待，是因为new将对象存储在“堆”里，故用new创建一个对象——特别是小的、简单的变量，往往不是很有效。因此，对于这些类型，Java采用与C和c++相同的方法。也就是说，不用new来创建变量，而是创建一个并非是引用的“自动”变量。这个变量直接存储“值”，并置于堆栈中，因此更加高效。</p><h2 id="举例（有关赋值操作）"><a href="#举例（有关赋值操作）" class="headerlink" title="举例（有关赋值操作）"></a><strong>举例（有关赋值操作）</strong></h2><p><strong>在开始问题之前我们先来看这样一段代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Tank</span> &#123;</span><br><span class="line"><span class="type">int</span> level;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Assignment</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Tank</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tank</span>();</span><br><span class="line"><span class="type">Tank</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tank</span>();</span><br><span class="line">t1.level = <span class="number">9</span>;</span><br><span class="line">t2.level = <span class="number">47</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;No.1: t1.level:&quot;</span> + t1.level + <span class="string">&quot;, t2.level:&quot;</span></span><br><span class="line">+ t2.level);</span><br><span class="line">t1 = t2;</span><br><span class="line">System.out.println(<span class="string">&quot;No.2: t1.level:&quot;</span> + t1.level + <span class="string">&quot;, t2.level:&quot;</span></span><br><span class="line">+ t2.level);</span><br><span class="line">t1.level = <span class="number">27</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;No.3: t1.level:&quot;</span> + t1.level + <span class="string">&quot;, t2.level:&quot;</span></span><br><span class="line">+ t2.level);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">No.1: t1.level:9, t2.level:47</span><br><span class="line">No.2: t1.level:47, t2.level:47</span><br><span class="line">No.3: t1.level:27, t2.level:27</span><br></pre></td></tr></table></figure><p><strong>为什么是这样一个结果呢？</strong></p><p><strong>其实</strong> Tank类非常简单，它的两个实例（t1和t2）是在main()里创建的。对每个Tank类对象的level域都赋予了一个不同的值，然后，将t2赋给t1， 接着又修改了t1。在许多编程语言中，我们可能会期望t1和t2总是相互独立的。但由于赋值操作的是一个对象的引用，所以修改t1的同时也改变了t2！这是由于t1和t2包含的是相同的引用，它们指向相同的对象。（原本t1包含的对对象的引用，是指向一个值为9的对象。在对t1赋值的时候，这个引用被覆盖了，也就是丢失了；而那个不再被引用的对象会由“垃圾回收器”自动清理。）</p><p>这种特殊的现象通常称作“别名现象”，是Java操作对象的一种基本方式。在这个例子中，如果想避免别名问题应该怎么办呢？可以这样写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t1.level = t2.level;</span><br></pre></td></tr></table></figure><p>这样便可以保持两个对象彼此独立，而不是将t1和t2绑定到相同的对象。但你很快就会意识到，直接操作对象内的域容易导致混乱，并且，违背了良好的面向对象程序设计的原则。这可不是一个小问题，所以从现在开始大家就应该留意，为对象赋值可能会产生意想不到的结果。</p><h2 id="方法调用中的别名问题"><a href="#方法调用中的别名问题" class="headerlink" title="方法调用中的别名问题"></a><strong>方法调用中的别名问题</strong></h2><p><strong>将一个对象传递给方法时，也会产生别名问题：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Letter</span>&#123;</span><br><span class="line"><span class="type">char</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PassObject</span> &#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f</span> <span class="params">(Letter y)</span>&#123;</span><br><span class="line">y.c = <span class="string">&#x27;z&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="type">Letter</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Letter</span>();</span><br><span class="line">x.c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;1: x.c: &quot;</span> + x.c);</span><br><span class="line">f(x);</span><br><span class="line">System.out.println(<span class="string">&quot;2: x.c: &quot;</span> + x.c);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1: x.c: a</span><br><span class="line">2: x.c: z</span><br></pre></td></tr></table></figure><p>在很多编程语言中，方法f()似乎要在他的作用域内复制其参数Letter的一个副本；但实际上只是传递了一个引用。所以代码行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y.c = &#x27;z&#x27;;</span><br></pre></td></tr></table></figure><p>实际改变的是f()之外的对象。</p><p>别名引起的问题及其解决方法是很复杂的话题，但是你现在就应该知道它的存在，并在使用中注意这个陷阱。</p>]]></content>
      
      
      <categories>
          
          <category> 未分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无标签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实验——48小时丢手机之随手记</title>
      <link href="/posts/20161008082313/"/>
      <url>/posts/20161008082313/</url>
      
        <content type="html"><![CDATA[<p><img src="/posts/20161008082313/%E4%B8%A2%E6%89%8B%E6%9C%BA%E5%AE%9E%E9%AA%8C.jpg" class="lazyload" data-srcset="/posts/20161008082313/%E4%B8%A2%E6%89%8B%E6%9C%BA%E5%AE%9E%E9%AA%8C.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="丢手机实验"></p><p><strong>受一篇文章启发，我也尝试进行了这样一场“48小时彻底离开手机和网络”的实验。下面是我在这个过程中随手记下的感受。</strong></p><p><strong>在这48小时中，我主要做了些：</strong></p><ul><li>阅读完王小波的一本杂文集——《我的精神家园》</li><li>阅读完图灵系列期刊——码农.第2期——Javascript</li><li>阅读了《Thinging in Java》的第一章</li><li>阅读了《Pro Git》的第七章</li><li>完成毛概的小作业+复习了微机原理的功课</li><li>市中逛街购买生活用品+休闲</li><li>洗衣洗鞋以及整理房间……</li></ul><p><strong>☟ 下面是在这过程中的一些随手记</strong></p><blockquote><ul><li>为了模拟常规状态下的真实体验，并未对两天内做具体的安排，具体做什么，看心情好了。</li></ul></blockquote><blockquote><ul><li>为了增加仪式感，特地在12:00整在社交网站发了一条实验启动的状态，然后关闭手机，切断了一切连接网络的设备。</li></ul></blockquote><blockquote><ul><li>让我们开始吧！</li></ul></blockquote><blockquote><ul><li>为了有一个轻松地开始，我选择干的第一件事是阅读，在自己的待读书目里选出一本最期待的开始了一天。</li></ul></blockquote><blockquote><ul><li>图书馆坐得累了， 我想起了手机，平日总会赶着休息的空闲刷一刷朋友圈，看看朋友们的动态，这会儿我也犯了这个痒，心里总在焦虑的想，这会儿朋友中又发生了哪些事儿，但我身上没有手机，更不能上网。</li></ul></blockquote><blockquote><ul><li>我蛮想看看昨天社交平台上的状态有了哪些回复……</li></ul></blockquote><blockquote><ul><li>不能上网，只能听iPad里缓存过的歌，平时放松放首歌，歌声基本只是背景乐，自己一定忙着别的，比如刷手机，而这会儿突感无事可做，便听着歌看着歌词，才感歌词好美，平日并未在意的小调，也特别生动。</li></ul></blockquote><blockquote><ul><li>坐公交去市区，下意识地想拿出手机摆弄，但却发现并没有手机，只好看着满车人民均低着头沉浸在自己的一片天地，只有我独自欣赏窗外闪过的美景，这西南小城，并不繁华但却不落俗气，节奏适宜，的确是宜居的很、巴适得板！生活在一座城，便恋上一座城，明年正也打算拉父母转过来一同生活，共享这安逸。</li></ul></blockquote><blockquote><ul><li>听到一首赵雷的《人家》，好好听，想搜搜吉他谱看难不，但我不能上网啊！啊哈哈……</li></ul></blockquote><blockquote><ul><li>早晨等热水和厕所的这一小段空闲，我翻开了心血来潮买回来的大部头《Thinking in Java》，因为最近忙于琐事，一直未读，今早将目录以前的所有介绍性的章节读了一遍，这是一本可以令人心潮澎湃的书，平日里，这样短小的零碎时间，多数都以手机里的快餐资讯填充了，而现在发现，没有手机和网络也同样可以获得那种快感，而且这种快感更加真实、亲切。</li></ul></blockquote><blockquote><ul><li>也并非在整个过程中不使用智能设备，当然，手机我是没敢打开，只用iPad听过歌，看过吉他谱和课件，但这所有的操作都是在离线状态下，如果联网，我可能会频繁地切换APP，有人说那些电子设备就不是用来学习的，在联网的情况下的确是这样。</li></ul></blockquote><blockquote><ul><li>朋友的手机响了，打断了思绪，想起平日学习过程中，被自己手机消息打断的情形，这并不是说自己多么沉迷学习厌恶被打断，而是自己对这种干扰又爱又恨，因为收到消息可以把自己从苦闷的学习中暂时解脱出来而爱，又因为让自己心意上过不去而恨，并且平日更多时候自己还会主动去查看手机是否有新消息。今后学习过程中，将手机关机是个不错的想法。</li></ul></blockquote><blockquote><ul><li>有时会为关闭手机切断所有网络连接而感到欣喜，我会清晰地知道，在这个时间段内，绝对不会有人来打扰我。</li></ul></blockquote><blockquote><ul><li>我是想查个单词的，没有手机和网络确实这些需求变得不方便，于是我搬出了吃灰许久的牛津双解，虽然笨拙，但却感到蛮有趣，别有一番风味。</li></ul></blockquote><blockquote><ul><li>很需要下载一首歌曲，冒险（之所以说是冒险，是因为担心自己控制不住而网上冲浪）打开了iPad的WiFi连接，先开了勿扰模式的，但还是收到了QQ消息的提醒，还是自己心仪女孩发来的，丫的！太有挑战了，我强忍着好奇和期待清空了通知，下载好歌曲之后，关掉了WiFi连接，真好奇收到的是什么，哈哈，我的心绞痛，心中纠结的原因不是因为不能回复消息的负罪感，而是自身期待查看消息的好奇心不能满足。</li></ul></blockquote><blockquote><ul><li>一想到今晚12点之后就可以重新接入互联网就感到好兴奋，而Now，继续享受这最后一段自在的时光吧！</li></ul></blockquote><blockquote><ul><li>书是看不进去了，于是我选择了去吃饭，平时遇到这样坐不住椅子的情况时，多数情况都是用上网冲浪的方式来填充，因为这个原因而得出“没有网络是件好事儿”的结论确实有些牵强，但不可否认的是：在这即将结束的48小时实验时间里、在我并没有给自己提前指定任务清单并试图调用更多自控力去执行清单任务的情况下，确实比往日做了更多有价值或有意义的事情，或者说明显地减少了毫无意义甚至颓废的时间开销。</li></ul></blockquote><blockquote><ul><li>现在离实验结束还有2小时10分钟，从我内心饱满的状态和充实的感觉以及并未发生的曾预想中的强烈不适反应来看，我得出了下面的结论，或是说实验心得：</li></ul></blockquote><blockquote><p><strong>在今天，网络和智能设备已经成为我们工作、学习和生活不可分割的一部分，但适时、有计划地丢掉智能设备，断开自身与网络的连接，可以让我们生活得更好！</strong></p></blockquote><p>以上就是在这48小时实验当中，随手记下的当时时刻的小心情，仅作分享，同时非常感谢陪伴自己一同践行此次“48小时丢手机”实验的美美哒师妹，没有她的提醒，可能并不会真正实践当初只是在脑海里设想过的这个想法。</p>]]></content>
      
      
      <categories>
          
          <category> 未分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无标签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown简明手册</title>
      <link href="/posts/20160910114617/"/>
      <url>/posts/20160910114617/</url>
      
        <content type="html"><![CDATA[<p><strong>Markdown</strong> 是一种轻量级标记语言，创始人为约翰·格鲁伯（John Gruber）。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的<code>XHTML</code>(或者<code>HTML</code>)文档”。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。</p><p>John Gruber 在 2004 年创造了 Markdown 语言，在语法上有很大一部分是跟亚伦·斯沃茨（Aaron Swartz）共同合作的。这个语言的目的是希望大家使用“易于阅读、易于撰写的纯文字格式，并选择性的转换成有效的 <code>XHTML</code> (或是<code>HTML</code>)”。其中最重要的设计是可读性，也就是说这个语言应该要能直接在字面上的被阅读，而不用被一些格式化指令标记 (像是 <code>RTF</code> 与 <code>HTML</code>)。 因此，它是现行电子邮件标记格式的惯例，虽然它也借鉴了很多早期的标记语言，如：<code>setext</code>、<code>Texile</code>、<code>reStructuredText</code>。 许多网站都使用 Markdown 或是其变种，例如：<code>GitHub</code>、<code>reddit</code>、<code>Diaspora</code>、<code>Stack Exchange</code>、<code>OpenStreetMap</code> 与 <code>SourceForge</code> 让用户更利于讨论。</p><p>Markdown同时还是一个由Gruber编写的<code>Perl</code>脚本：<code>Markdown.pl</code>。它把用markdown语法编写的内容转换成有效的、结构良好的<code>XHTML</code>或<code>HTML</code>内容，并将左尖括号<code>&lt;</code>和<code>&amp;</code>号替换成它们各自的字符实体引用。它可以用作单独的脚本，Blosxom和Movable Type的插件又或者BBEdit的文本过滤器。</p><p>Markdown也已经被其他人用<code>Perl</code>和别的编程语言重新实现，其中一个<code>Perl</code>模块放在了CPAN(Text::Markdown)上。它基于一个BSD风格的许可证分发并可以作为几个内容管理系统的插件。</p><p><em>引自维基百科 <a href="https://zh.wikipedia.org/wiki/Markdown">Markdown</a></em></p><h2 id="1-斜体和粗体"><a href="#1-斜体和粗体" class="headerlink" title="1. 斜体和粗体"></a><strong>1. 斜体和粗体</strong></h2><p>使用 * 和 ** 表示斜体和粗体。</p><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><blockquote><p>这是 *斜体*，这是 *<em>粗体*</em>。</p></blockquote><h3 id="效果："><a href="#效果：" class="headerlink" title="效果："></a>效果：</h3><p>这是 <em>斜体</em>，这是 <strong>粗体</strong>。</p><h2 id="2-分级标题"><a href="#2-分级标题" class="headerlink" title="2. 分级标题"></a><strong>2. 分级标题</strong></h2><p>使用 # 表示一级标题，使用 ## 表示二级标题。</p><h3 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h3><blockquote><p># 这是一个一级标题</p></blockquote><blockquote><p>## 这是一个二级标题</p></blockquote><blockquote><p>### 这是一个三级标题</p></blockquote><h3 id="效果：-1"><a href="#效果：-1" class="headerlink" title="效果："></a>效果：</h3><h1 id="这是一个一级标题"><a href="#这是一个一级标题" class="headerlink" title="这是一个一级标题"></a>这是一个一级标题</h1><h2 id="这是一个二级标题"><a href="#这是一个二级标题" class="headerlink" title="这是一个二级标题"></a>这是一个二级标题</h2><h3 id="这是一个三级标题"><a href="#这是一个三级标题" class="headerlink" title="这是一个三级标题"></a>这是一个三级标题</h3><h2 id="3-外链接"><a href="#3-外链接" class="headerlink" title="3. 外链接"></a><strong>3. 外链接</strong></h2><p>使用 [描述](链接地址) 为文字增加外链接。</p><h3 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h3><blockquote><p>这是去往 [本人博客](<a href="https://www.laoliang.ink/">https://www.laoliang.ink</a>) 的链接。</p></blockquote><h3 id="效果：-2"><a href="#效果：-2" class="headerlink" title="效果："></a>效果：</h3><p>这是去往 <a href="https://www.laoliang.ink/">本人博客</a> 的链接。</p><h2 id="4-无序列表"><a href="#4-无序列表" class="headerlink" title="4. 无序列表"></a><strong>4. 无序列表</strong></h2><p>使用 *，+，- 表示无序列表。</p><h3 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h3><blockquote><p>- 无序列表项 1<br>- 无序列表项 2<br>- 无序列表项 3</p></blockquote><h3 id="效果：-3"><a href="#效果：-3" class="headerlink" title="效果："></a>效果：</h3><ul><li>无序列表项 1</li><li>无序列表项 2</li><li>无序列表项 3</li></ul><h2 id="5-有序列表"><a href="#5-有序列表" class="headerlink" title="5. 有序列表"></a><strong>5. 有序列表</strong></h2><p>使用数字和点表示有序列表。</p><h3 id="示例：-4"><a href="#示例：-4" class="headerlink" title="示例："></a>示例：</h3><blockquote><ol><li>有序列表项 一</li><li>有序列表项 二</li><li>有序列表项 三</li></ol></blockquote><h3 id="效果：-4"><a href="#效果：-4" class="headerlink" title="效果："></a>效果：</h3><ol><li>有序列表项 一</li><li>有序列表项 二</li><li>有序列表项 三</li></ol><h2 id="6-文字引用"><a href="#6-文字引用" class="headerlink" title="6. 文字引用"></a><strong>6. 文字引用</strong></h2><p>使用 &gt; 表示文字引用。</p><h3 id="示例：-5"><a href="#示例：-5" class="headerlink" title="示例："></a>示例：</h3><blockquote><p>&gt; 野火烧不尽，春风吹又生。</p></blockquote><h3 id="效果：-5"><a href="#效果：-5" class="headerlink" title="效果："></a>效果：</h3><blockquote><p>野火烧不尽，春风吹又生。</p></blockquote><h2 id="7-行内代码块"><a href="#7-行内代码块" class="headerlink" title="7. 行内代码块"></a><strong>7. 行内代码块</strong></h2><p>使用 `代码` 表示行内代码块。</p><h3 id="示例：-6"><a href="#示例：-6" class="headerlink" title="示例："></a>示例：</h3><blockquote><p>让我们聊聊 `html`。</p></blockquote><h3 id="效果：-6"><a href="#效果：-6" class="headerlink" title="效果："></a>效果：</h3><p>让我们聊聊 <code>html</code>。</p><h2 id="8-代码块"><a href="#8-代码块" class="headerlink" title="8.  代码块"></a><strong>8.  代码块</strong></h2><p>支持四十一种编程语言的语法高亮的显示，行号显示。</p><h3 id="非代码示例："><a href="#非代码示例：" class="headerlink" title="非代码示例："></a>非代码示例：</h3><blockquote><p>```<br>$ sudo apt-get install vim-gnome<br>```</p></blockquote><h3 id="非代码效果："><a href="#非代码效果：" class="headerlink" title="非代码效果："></a>非代码效果：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install vim-gnome</span><br></pre></td></tr></table></figure><h3 id="Python-示例："><a href="#Python-示例：" class="headerlink" title="Python 示例："></a>Python 示例：</h3><blockquote><p>```python<br>import sys</p></blockquote><blockquote><p>for s in sys.stdin:<br>    a = [int(i) for i in s.split()]<br>    print (a[0] + a[1])<br>```</p></blockquote><h3 id="Python-效果："><a href="#Python-效果：" class="headerlink" title="Python 效果："></a>Python 效果：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> sys.stdin:</span><br><span class="line">    a = [<span class="built_in">int</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> s.split()]</span><br><span class="line">    <span class="built_in">print</span> (a[<span class="number">0</span>] + a[<span class="number">1</span>])</span><br></pre></td></tr></table></figure><h3 id="JavaScript-示例："><a href="#JavaScript-示例：" class="headerlink" title="JavaScript 示例："></a>JavaScript 示例：</h3><blockquote><p>``` javascript<br>function fib(n) {<br>  var a = 1, b = 1;<br>  var tmp;<br>  while (–n &gt;= 0) {<br>    tmp = a;<br>    a += b;<br>    b = tmp;<br>  }<br>  return a;<br>}</p></blockquote><blockquote><p>document.write(fib(10));<br>```</p></blockquote><h3 id="JavaScript-效果："><a href="#JavaScript-效果：" class="headerlink" title="JavaScript 效果："></a>JavaScript 效果：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fib</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>, b = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> tmp;</span><br><span class="line">  <span class="keyword">while</span> (--n &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    tmp = a;</span><br><span class="line">    a += b;</span><br><span class="line">    b = tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="title function_">fib</span>(<span class="number">10</span>));</span><br></pre></td></tr></table></figure><h2 id="9-插入图像"><a href="#9-插入图像" class="headerlink" title="9.  插入图像"></a><strong>9.  插入图像</strong></h2><p>使用 ![描述](图片链接地址) 插入图像。</p><h3 id="示例：-7"><a href="#示例：-7" class="headerlink" title="示例："></a>示例：</h3><blockquote><p>![我的头像](<a href="https://avatars.githubusercontent.com/u/23415234?s=460&amp;u=246c673b3fe369d7146089bce615857f0aaf09a6&amp;v=4">https://avatars.githubusercontent.com/u/23415234?s=460&amp;u=246c673b3fe369d7146089bce615857f0aaf09a6&amp;v=4</a>)</p></blockquote><h3 id="效果：-7"><a href="#效果：-7" class="headerlink" title="效果："></a>效果：</h3><p><img src="https://avatars.githubusercontent.com/u/23415234?s=460&u=246c673b3fe369d7146089bce615857f0aaf09a6&v=4" class="lazyload" data-srcset="https://avatars.githubusercontent.com/u/23415234?s=460&u=246c673b3fe369d7146089bce615857f0aaf09a6&v=4" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="我的头像"></p>]]></content>
      
      
      <categories>
          
          <category> 未分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无标签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git常用命令笔记</title>
      <link href="/posts/20160804131048/"/>
      <url>/posts/20160804131048/</url>
      
        <content type="html"><![CDATA[<p><em>注：本文引自图灵社区系列杂志《码农·进击的Java（总第16期）》，部分有删减，仅用于个人备忘笔记及交流使用</em></p><blockquote><p>作者/颜海镜</p></blockquote><blockquote><p>90后一枚，活跃在各个技术社区，常以歪脖无脸男作为头像，专注于 Web 前端开发已有三个年头，关注 HTML/CSS/JavaScript 等技术，目前就职于北京金山软件，坚信 Web 赢在未来。热爱思考，热爱开源分享，常翻译些外文博客，此外还爱好读书，羽毛球，乒乓球，相声，铁杆钢丝，当然非常热爱写代码了，<a href="http://yanhaijing.com/">http://yanhaijing.com/</a> 是我的个人博客。</p></blockquote><p>起初的时候我使用 github for windows 这个客户端，再切换到多分支的时候被自动转换换行符坑的不浅，后来阅读了 <a href="http://www.open-open.com/lib/view/open1328069609436.html">《git详解》</a>系列文章，对 Git 的了解深入了一步，这篇文章记录个人常用的一些命令，和记不住大一些命令。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a><strong>安装</strong></h2><p>在 Windows 上安装 <code>Git</code> 同样轻松，我们可以到 <a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a> 下载对应操作系统的安装包。</p><p>安装完成之后，就可以使用命令行的 git 工具（已经自带了 ssh 客户端）了，另外还有一个图形界面的 Git 项目管理工具。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a><strong>配置</strong></h2><h3 id="配置账号信息"><a href="#配置账号信息" class="headerlink" title="配置账号信息"></a><strong>配置账号信息</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name yourname</span><br><span class="line">git config --global user.email youname@example.com</span><br><span class="line"></span><br><span class="line">git config --list #查看配置的信息</span><br><span class="line"></span><br><span class="line">git help config #获取帮助信息</span><br></pre></td></tr></table></figure><h3 id="配置自动换行（自动转换坑太大）"><a href="#配置自动换行（自动转换坑太大）" class="headerlink" title="配置自动换行（自动转换坑太大）"></a><strong>配置自动换行（自动转换坑太大）</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.autocrlf input #提交到 git 是自动将换行符转换为lf</span><br></pre></td></tr></table></figure><h3 id="配置密钥"><a href="#配置密钥" class="headerlink" title="配置密钥"></a><strong>配置密钥</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C yourname@example.com #生成密钥</span><br><span class="line"></span><br><span class="line">ssh -T git@github.com #测试是否成功</span><br></pre></td></tr></table></figure><h2 id="新建仓库"><a href="#新建仓库" class="headerlink" title="新建仓库"></a><strong>新建仓库</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git init #初始化</span><br><span class="line">git status #获取状态</span><br><span class="line">git add file #.或*代表全部添加</span><br><span class="line">git commit -m &quot;message&quot; #此处注意乱码</span><br><span class="line">git remote add origin git@github.com:yourname/test.git #添加源</span><br><span class="line">git push -u origin master #push同时设置默认跟踪分支</span><br></pre></td></tr></table></figure><h2 id="从现有仓库克隆"><a href="#从现有仓库克隆" class="headerlink" title="从现有仓库克隆"></a><strong>从现有仓库克隆</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone git://github.com/yourname/data.git</span><br><span class="line">git clone git://github.com/schacon/grit.git mypro #克隆到自定义文件夹</span><br></pre></td></tr></table></figure><h2 id="本地"><a href="#本地" class="headerlink" title="本地"></a><strong>本地</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">git add * #跟踪新文件</span><br><span class="line"></span><br><span class="line">rm * &amp; git rm * #移除文件</span><br><span class="line">git rm -f * #移除文件</span><br><span class="line">git rm --cached * #取消跟踪</span><br><span class="line">git mv file_from file_to #重命名跟踪文件</span><br><span class="line"></span><br><span class="line">git log #查看提交记录</span><br><span class="line"></span><br><span class="line">git commit #提交更新记录</span><br><span class="line">git commit -m &quot;message&quot;</span><br><span class="line">git commit -a #跳过使用暂存区域，把所有已经跟踪过的文件暂存起来一并提交</span><br><span class="line">git commit -amend #修改最后一次提交</span><br><span class="line"></span><br><span class="line">git reset HEAD * #取消已经暂存的文件</span><br><span class="line"></span><br><span class="line">git checkout -- file #取消对文件的修改（从暂存区去除file）</span><br><span class="line">git checkout branch|tag|commit -- file_name #从仓库取出 file 覆盖当前分支</span><br><span class="line">git checkout -- . #从暂存区取出文件覆盖工作区</span><br></pre></td></tr></table></figure><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a><strong>分支</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">git branch #列出本地分支</span><br><span class="line">git branch -r #列出远端分支</span><br><span class="line">git branch -a #列出所有分支</span><br><span class="line">git branch -v #查看各个分支最后一个提交对象的信息</span><br><span class="line">git branch --merge #查看已经合并到当前分支的分支</span><br><span class="line">git branch --no-merge #查看未合并到当前分支的分支</span><br><span class="line"></span><br><span class="line">git branch test #新建 test 分支</span><br><span class="line">git checkout test #切换到 test 分支</span><br><span class="line">git checkout -b test #新建并切换到 test 分支</span><br><span class="line">git checkout -b test dev #基于 dev 新建 test 分支，并切换</span><br><span class="line"></span><br><span class="line">git branch -d test #删除 test 分支</span><br><span class="line">git branch -D test #强制删除 test 分支</span><br><span class="line"></span><br><span class="line">git merge test #将 test 分支合并到当前分支</span><br><span class="line">git rebase master #将 master 分支智商超前的提交，变基到当前分支</span><br></pre></td></tr></table></figure><h2 id="远端"><a href="#远端" class="headerlink" title="远端"></a><strong>远端</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin_name branch_name #拉取远端上指定分支</span><br><span class="line">git merge origin_name branch_name #合并远端上指定分支</span><br><span class="line">git push origin_name branch_name #推送到远端上指定分支</span><br><span class="line">git push origin_name local_branch:server_branch #推送到远端上指定分支</span><br><span class="line"></span><br><span class="line">git checkout -b test origin/dev #基于远端 dev 新建 test 分支</span><br><span class="line"></span><br><span class="line">git push origin :server #删除远端分支</span><br></pre></td></tr></table></figure><h2 id="源"><a href="#源" class="headerlink" title="源"></a><strong>源</strong></h2><p><code>Git</code> 是一个分布式代码管理工具，所以可以支持多个仓库，在 <code>Git</code> 里，服务器上的仓库在本地称之为 <code>remote</code>。</p><p>个人开发时，多源用的可能不多，但多源其实非常有用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin1 git@github.com/yourname/data.git</span><br><span class="line"></span><br><span class="line">git remote #显示全部源</span><br><span class="line">git remote -v #显示全部源+详细信息</span><br><span class="line"></span><br><span class="line">git remote rename origin1 origin2 #重命名</span><br><span class="line"></span><br><span class="line">git remote rm origin1 #删除</span><br><span class="line"></span><br><span class="line">git remote show origin1 #查看指定源的全部信息</span><br></pre></td></tr></table></figure><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a><strong>标签</strong></h2><p>当开发到一定阶段时，给程序打标签是非常棒的习惯。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">git tag #列出现有标签</span><br><span class="line">git tag v0.1 #新建标签</span><br><span class="line">git tag -a v0.1 -m &quot;My version 1.4&quot; #新建带注释标签</span><br><span class="line"></span><br><span class="line">git checkout tag_name #切换到标签</span><br><span class="line"></span><br><span class="line">git push origin v1.5 #推送分支到源上</span><br><span class="line">git push origin --tags #一次性推送所有分支</span><br><span class="line"></span><br><span class="line">git tag -d v0.1 #删除标签</span><br><span class="line">git push origin :refs/tags/v0.1 #删除远程标签</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>啊哈！终于总结完了，以后不会的时候，再也不用到处去找了。</p><p>其实还有两个最有用的命令未提到。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git help * #获取命令的帮助信息</span><br><span class="line">git status #获取当前的状态，非常有用，因为 Git 会提示接下来的能做的事情</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 未分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无标签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git快速入门（三）</title>
      <link href="/posts/20160803131048/"/>
      <url>/posts/20160803131048/</url>
      
        <content type="html"><![CDATA[<p>现在的你对于 Git 应该完全不会感到陌生了吧，通过之前两节内容的学习，你已经掌握了很多 Git 中常用的命令，像提交代码这种简单的操作相信肯定是难不倒你的。</p><p>那么打开 <code>Git Bash</code>，在指定目录创建项目的跟目录，然后执行提交操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;First Commit.&quot;</span><br></pre></td></tr></table></figure><p>这样就将准备工作完成了，下面就让我们开始学习关于 <code>Git</code> 的高级用法。</p><h2 id="分支的用法"><a href="#分支的用法" class="headerlink" title="分支的用法"></a><strong>分支的用法</strong></h2><p>分支是版本控制工具中比较高级且比较重要的一概念，它主要的作用就是在现有代码的基础上开辟一个分叉口，使得代码可以在主干线和分支线上同时进行开发，且相互之间不会影响。</p><p>你也许会有疑惑，为什么需要建立分支呢？只在主干线上进行开发不是挺好的吗？没错，通常情况下，只在主干线上进行开发是完全没有问题的， 不过一旦涉及版本的情况，如果不建立分支的话，你就会非常的头疼。</p><p>举个例子吧比如说你们公司研发了一款不错的软件，最近刚刚完成，并推出了<code>1.0</code>版本。但是领导是不会让你们闲着的，马上提出了新的需求，让你们投入到了<code>1.1</code>版本的开发工作当中。过了几个星期，<code>1.1</code>版本的功能已经完成了一半，但是这个时候用户反馈，之前上线的<code>1.0</code>版本发现了几个重大的bug，严重影响软件的正常的正常使用。领导也相当重视这个问题，要求你们立刻修复这些bug，并重新发布<code>1.0</code>版本，但这个时候你就非常为难了，你会发现根本没法儿去修复这些bug。因为现在<code>1.1</code>版本已经开发到一半了，如果在现有的代码的基础上修复这些bug，那么更新的<code>1.0</code>版本将会带有一半<code>1.1</code>版本的功能！</p><p>进退两难了是不是？但是如果你使用了分支的话，就完全不会存在这个让人头疼的问题。你只需要在发布<code>1.0</code>版本的时候建立一个分支，然后在主线上继续开发<code>1.1</code>版本的功能。当<code>1.0</code>版本上发现任何bug的时候，就在分支上进行修改，然后发布新的<code>1.0</code>版本，并记得将修改后的代码合并到主干线上。这样的话，不仅可以轻松解决掉<code>1.0</code>版本存在的bug，而且保证了主干线上的代码也已经修复了这些bug，当<code>1.1</code>版本发布的时候就不会有同样的bug存在了。</p><p>说了这么多，相信你也已经意识到分支的重要性了，那么我们马上来学习一下如何在<code>Git</code>中操作分支吧。</p><p>分支的英文名是<code>branch</code>，如果想要查看当前的版本库当中有哪些分支，可以使用<code>git branch</code>这个命令。</p><p>创建一个分支：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch version1.0</span><br></pre></td></tr></table></figure><p>这样就创建了一个名为<code>version1.0</code>的分支，我们可以再次输入<code>git branch</code>这个命令来检查一下。</p><p>切换分支：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout version1.0</span><br></pre></td></tr></table></figure><p>这样我们就可以把代码成功切换到<code>version1.0</code>这个分支上了。</p><p>需要注意的是，在<code>version1.0</code>分支上修改并提交的代码将不会影响到<code>master</code>分支。同样的道理，在<code>master</code>分支上修改并提交的代码也不会影响到<code>version1.0</code>分支。因此如果我们在<code>version1.0</code>分支上修复了一个bug，在<code>master</code>分支上这个bug仍然是存在的。这时将修改的代码一行行赋值到<code>master</code>分支显然不是一种聪明的做法，最好的办法就是使用<code>merge</code>命令来完成合并操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git merge version1.0</span><br></pre></td></tr></table></figure><p>仅仅这样简单的两行命令，就可以把在<code>version1.0</code>分支上修改并提交的内容合并到<code>master</code>分支上了。当然，在合并分支的时候还有可能出现代码冲突的情况，这个时候你就需要静下心来慢慢找出并解决这些冲突，<code>Git</code>在这里就无法帮助你了。</p><p>最后，当我们不再需要<code>version1.0</code>这个分支的时候，可以使用如下命令将这个分支删除掉：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -D version1.0</span><br></pre></td></tr></table></figure><h2 id="与远程版本库协作"><a href="#与远程版本库协作" class="headerlink" title="与远程版本库协作"></a><strong>与远程版本库协作</strong></h2><p>可以这样说，如果你是一个人在开发，那么使用版本控制工具救援预案无法发挥出它真正强大的功能。没错，所有版本控制工具最重要的一个特点就是可以使用它来进行团队合作开发。每个人的电脑上都会有一份代码，当团队的某个成员在自己的电脑上编写完成了某个功能之后，就将代码提交到服务器，其他的成员只需要将服务器上的代码同步到本地，就能保证整个团队所有人的代码都相同。这样的话，每个团队成员就可以各司其职，大家共同来完成一个较为庞大的项目。</p><p>那么如何使用<code>Git</code>来进行团队合作开发呢？这就需要有一个远程的版本库，团队的每个成员都从这个版本库中获取到最原始代码，然后各自进行开发，并且以后每次提交的代码都同步到远程版本库上就可以了。另外，团队中的每个成员最好都要养成经常从版本库中获取最新代码的习惯，不然的话，大家的代码就很有可能经常出现冲突。</p><p>比如说现在有一个远程版本库的Git地址是<code>https://github.com/example/test.git</code>，就可以使用如下的命令将代码下载到本地：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/example/test.git</span><br></pre></td></tr></table></figure><p>之后你在这份代码的基础上进行了一些修改和提交，那么怎样才能把本地修改的内容同步到远程版本库上呢？这就需要借助<code>push</code>命令来完成了，用法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p>其中<code>origin</code>部分指定的是远程版本库的<code>Git</code>地址，<code>master</code>部分指定的是同步到哪一个分支上，上述命令就完成了将本地代码同步到<code>https://github.com/example/test.git</code>这个版本库的<code>master</code>分支上的功能。</p><p>知道了将本地的修改同步到远程版本库上的方法，接下来我们看一下如何将远程版本库上的修改同步到本地。<code>Git</code>提供了两种命令来完成此功能，分别是<code>fetch</code>和<code>pull</code>，<code>fetch</code>的语法规则和<code>push</code>是差不多的，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin master</span><br></pre></td></tr></table></figure><p>执行这个命令后，就会将远程本本库上的代码同步到本地，不过同步下来的代码并不会合并到任何分支上去，而是会存放在一个<code>origin/master</code>分支上，这是我们就可以通过<code>diff</code>命令来查看远程版本库上到底修改了哪些东西：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff origin/master</span><br></pre></td></tr></table></figure><p>之后再调用<code>merge</code>命令将<code>origin/master</code>分支上的修改合并到主分支上即可，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge origin/master</span><br></pre></td></tr></table></figure><p>而<code>pull</code>命令则是相当于将<code>fetch</code>和<code>merge</code>这两个命令放在一起执行了，它可以从远程版本库上获取最新的代码并合并到本地，用法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin master</span><br></pre></td></tr></table></figure><p><em>注：<code>Git快速入门</code> 系列文章大部分内容整理自“郭霖”大神的《第一行代码》内容，记录在此仅做备忘笔记及交流使用，切勿用于商业用途</em></p>]]></content>
      
      
      <categories>
          
          <category> 未分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无标签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git快速入门（二）</title>
      <link href="/posts/20160802131048/"/>
      <url>/posts/20160802131048/</url>
      
        <content type="html"><![CDATA[<p>上一次我们介绍了 Git 的环境配置和创建本地版本库本节我们一起来看 Git 的更多使用技巧。</p><h2 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a><strong>忽略文件</strong></h2><p>为什么要忽略文件呢，版本控制工具的初衷之一就是为了能够更多人更好地合作，方便多人维护同一份代码，那么对于常见的程序源代码，我们往往并不是需要把项目目录下所有的文件都加入到版本控制当中，例如，项目构建过程中生成的文件、本地IDE配置文件等，那么如何才能实现这样的效果呢？</p><p>Git 提供了一种可配型很强的机制来允许用户将指定的文件或目录排除在版本控制之外，它会检查代码仓库的目录下是否存在一个名为 <code>.gitignore</code> 的文件，如果存在的话，就去一行行读取这个文件中的内容，并把每一行指定的文件或目录排除在版本控制之外。注意，<code>.gitignore</code> 中指定的文件或目录是可以使用 <code>*</code> 通配符的。</p><p>下面是 GitHub 上面给出的常见工程项目的 <code>.gitignore</code> 模板，仅供参考，实际项目中还要根据自己团队间的具体需求进行增改：</p><p>链接：<a href="https://github.com/github/gitignore">A collection of useful .gitignore templates</a></p><h2 id="查看修改内容"><a href="#查看修改内容" class="headerlink" title="查看修改内容"></a><strong>查看修改内容</strong></h2><p>我们知道可以通过 <code>git status</code>，随时查看版本库工作区当前的文件状态，那么该如何看到更改的内容呢？这就需要借助 <code>diff</code> 命令了，用法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff</span><br></pre></td></tr></table></figure><p>这样可以查看到所有文件的更改内容，如果你只想查看某一个文件的更改内容，可以使用如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff filename</span><br></pre></td></tr></table></figure><h2 id="撤销未提交的更改"><a href="#撤销未提交的更改" class="headerlink" title="撤销未提交的更改"></a><strong>撤销未提交的更改</strong></h2><p>有时候我们的代码可能会写的过于草率，以至于原本正常的功能，结果反倒被我们改出了问题。遇到这种情况时也不用着急，因为只要代码还未提交，所有修改的内容都是可以撤销的。</p><p>比如，继上次提交以后，我们在工作区对文件 <code>a.cpp</code> 做了修改，现在如果想要撤销这个修改就可以使用 <code>checkout</code> 命令，用法如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout a.cpp</span><br></pre></td></tr></table></figure><p>执行了这个命令之后，我们对 <code>a.cpp</code> 这个文件所做的一切修改就应该都被撤销了。我们可以通过 <code>git status</code> 查看该文件的状态。</p><p>不过这种撤销方式只适用于那些还没有执行过 <code>add</code> 命令的文件，如果某个文件已经被添加过了，这种方式就无法撤销其更改的内容。</p><p>此时我们应该先对其取消添加，然后才可以撤回提交。取消添加用的是 <code>reset</code> 命令，用法如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD a.cpp</span><br></pre></td></tr></table></figure><p>然后再运行一遍 <code>git status</code> 命令，我们就会发现 <code>a.cpp</code> 这个文件重新变回了为添加状态，此时就可以使用 <code>checkout</code> 命令来将修改的内容进行撤销了。</p><h2 id="查看提交记录"><a href="#查看提交记录" class="headerlink" title="查看提交记录"></a><strong>查看提交记录</strong></h2><p>当项目开发几个月之后，我们可能已经执行过上百次提交操作了，这时，我们可以使用 <code>log</code> 命令查看历史提交信息，用法如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure><p>如果只想看其中一条记录，可以在命令中指定该记录的 id，并加上 <code>-1</code> 参数表示我们只想看到一行记录，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log 1fa38 -1</span><br></pre></td></tr></table></figure><p>其中提交记录的 id 我们只需要键入开头几个字母就可以了，因为 Git 会帮我们匹配是哪一条提交记录，如果 Git 不能唯一标示，它会提示你。</p><p>而如果想查看这条提交记录具体修改了什么内容，可以在命令中加入 <code>-p</code> 参数，命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log 1fa38 -1 -p</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 未分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无标签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git快速入门（一）</title>
      <link href="/posts/20160801131048/"/>
      <url>/posts/20160801131048/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么要写此系列教程"><a href="#为什么要写此系列教程" class="headerlink" title="为什么要写此系列教程"></a><strong>为什么要写此系列教程</strong></h2><p>我是一个有着严重拖延的人，对于新鲜事物很感兴趣，但是执行力很差。编辑此篇教程既是对自己学习新工具的总结，更是对自己办事执行力上的考验。</p><p>好，下面我们进入正题。</p><h2 id="关于版本控制"><a href="#关于版本控制" class="headerlink" title="关于版本控制"></a><strong>关于版本控制</strong></h2><p>什么是 <strong>“版本控制”</strong>？我为什么要关心它呢？ 版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。 在本书所展示的例子中，我们对保存着软件源代码的文件作版本控制，但实际上，你可以对任何类型的文件进行版本控制。</p><p>如果你是位图形或网页设计师，可能会需要保存某一幅图片或页面布局文件的所有修订版本（这或许是你非常渴望拥有的功能），采用版本控制系统（VCS）是个明智的选择。有了它你就可以将某个文件回溯到之前的状态，甚至将整个项目都回退到过去某个时间点的状态，你可以比较文件的变化细节，查出最后是谁修改了哪个地方，从而找出导致怪异问题出现的原因，又是谁在何时报告了某个功能缺陷等等。使用版本控制系统通常还意味着，就算你乱来一气把整个项目中的文件改的改删的删，你也照样可以轻松恢复到原先的样子。但额外增加的工作量却微乎其微。</p><p>——<em>摘自《Pro Git 2nd Edition (2014)》</em></p><p><img src="https://git-scm.com/images/progit2.png" class="lazyload" data-srcset="https://git-scm.com/images/progit2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="Pro Git"></p><p>本篇教程只是带领大家快速了解 Git，并掌握 Git 的基础用法。<br>更多规范详细教程请参考：<br>官方文档 <a href="https://git-scm.com/book/en/v2">Pro Git</a> （可切换中文版哦）</p><h2 id="Git的安装及环境配置"><a href="#Git的安装及环境配置" class="headerlink" title="Git的安装及环境配置"></a><strong>Git的安装及环境配置</strong></h2><h3 id="Linux下的安装"><a href="#Linux下的安装" class="headerlink" title="Linux下的安装"></a><strong>Linux下的安装</strong></h3><p>由于 Git 和 Linux 操作系统是同一个作者，因此 Git 在 Linux 上的安装是最简单方便的。比如你用的是 Ubuntu 系统，只需要打开 shell 界面，并输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure><p>按下回车后输入密码，即可完成 Git 的安装。</p><p>如果是老一点的 Linux 系统，要把命令改为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git-core</span><br></pre></td></tr></table></figure><p>因为以前有个软件也叫GIT（GNU Interactive Tools），结果Git就只能叫git-core了。由于Git名气实在太大，后来就把GNU Interactive Tools改成gnuit，git-core正式改为git。</p><h3 id="Windows下的安装"><a href="#Windows下的安装" class="headerlink" title="Windows下的安装"></a><strong>Windows下的安装</strong></h3><p>虽然 Windows 常被程序员诟病是最烂的开发平台，不过我相信在中国，你最有可能使用的还是 Windows 操作系统。不同于 Linux，Windows 上无法通过一行命令就完成安装，我们需要把 Git 的安装包到 <a href="https://git-scm.com/downloads">官网下载</a> 下来，之后一直点击“下一步”就可以完成安装了。</p><h3 id="Mac下的安装"><a href="#Mac下的安装" class="headerlink" title="Mac下的安装"></a><strong>Mac下的安装</strong></h3><p>哈哈，穷小子买不起苹果电脑，没办法给大家演示，不过安装方法都是大同小异，命令行、第三方工具、官网直接下载……</p><h2 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a><strong>创建版本库</strong></h2><h3 id="初次运行Git前的配置"><a href="#初次运行Git前的配置" class="headerlink" title="初次运行Git前的配置"></a><strong>初次运行Git前的配置</strong></h3><p>如果你使用的是 Linux 系统，就先打开 shell 界面，如果用的是 Windows 系统，就从开始里找到 Git Bash 并打开。</p><p>首先应该配置一下你的身份，这样在提交代码的时候 Git 就可以知道是谁提交的了，命令如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;Your name&quot;</span><br><span class="line">git config --global user.email &quot;Your email&quot;</span><br></pre></td></tr></table></figure><p>配置完成后你还可以使用同样的命令查看是否配置成功，只需要将最后的名字和邮箱地址去掉即可，向下面这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name</span><br><span class="line">git config --global user.email</span><br></pre></td></tr></table></figure><p>以上的基础信息配置，作用域是针对全局的（global），也就是说，在当前机器下，默认创建的所有版本仓库都会应用此配置信息，如果想要单独针对某一个仓库设定不同的配置信息，可以针对指定仓库单独配置。</p><h3 id="初始化仓库"><a href="#初始化仓库" class="headerlink" title="初始化仓库"></a><strong>初始化仓库</strong></h3><p>然后我们就可以开始常见代码仓库了，仓库（Repository）适用于保存版本管理所需信息的地方，所有本地提交的代码都会被提交代码仓库中，如果有需要的还可以再推送到远程仓库中。</p><p>首先移动到想要创建仓库的文件夹下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ./YourRepositoryFolder</span><br></pre></td></tr></table></figure><p>初始化仓库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>这时，在你保存 Git 仓库的文件夹下就会生成一个隐藏的 <code>.git</code> 文件夹，这个文件夹就是用来记录本地所有的 Git 操作的，可以通过 <code>ls -al</code> 查看一下。</p><p>如果你想要删除本地仓库，只需要删除这个文件夹就行了。</p><h3 id="提交本地代码"><a href="#提交本地代码" class="headerlink" title="提交本地代码"></a><strong>提交本地代码</strong></h3><p>代码仓库简历完之后就可以提交代码了，其实提交代码也非常简单，只需要使用 <code>add</code> 和 <code>commit</code> 命令就可以了，<code>add</code> 命令用于把想要提交的代码先添加进来（设置 追踪），而 <code>commit</code> 则是真正的去执行提交操作。</p><p>首先我们在刚刚的文件夹下创建两个新文件 <code>one.txt</code> 和 <code>two.txt</code>，我们可以通过以下命令将其添加到进来：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add one.txt</span><br><span class="line">git add two.txt</span><br></pre></td></tr></table></figure><p>也可以一次性添加所有文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure><p>期间，我们可以通过以下命令来随时查看工作区状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><p>接下来我们可以来提交一下，输入如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;First commit&quot;</span><br></pre></td></tr></table></figure><p>注意，在 <code>commit</code> 命令后面，我们一定要通过 <code>-m</code> 参数来加上提交的描述信息，没有描述信息的提交被认为是不合法的。这样所有的代码就已经成功提交了！</p>]]></content>
      
      
      <categories>
          
          <category> 未分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无标签 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
