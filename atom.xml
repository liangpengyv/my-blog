<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>老梁有墨</title>
  
  
  <link href="https://www.laoliang.ink/atom.xml" rel="self"/>
  
  <link href="https://www.laoliang.ink/"/>
  <updated>2024-11-16T11:26:50.346Z</updated>
  <id>https://www.laoliang.ink/</id>
  
  <author>
    <name>会弹吉他的程序员</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>快速入门脚手架(Node.js CLI)开发</title>
    <link href="https://www.laoliang.ink/posts/20240504211910/"/>
    <id>https://www.laoliang.ink/posts/20240504211910/</id>
    <published>2024-05-04T13:19:10.000Z</published>
    <updated>2024-11-16T11:26:50.346Z</updated>
    
    <content type="html"><![CDATA[<p>开发一个 Node.js CLI 脚手架，是创建高效开发工具的重要一步。本文将从基础概念入手，逐步深入开发过程，并以最小依赖实现第一个 CLI 工具。</p><h2 id="一、基础概念与预备知识"><a href="#一、基础概念与预备知识" class="headerlink" title="一、基础概念与预备知识"></a>一、基础概念与预备知识</h2><h3 id="1-什么是-Shell-和-Bash？"><a href="#1-什么是-Shell-和-Bash？" class="headerlink" title="1. 什么是 Shell 和 Bash？"></a>1. 什么是 Shell 和 Bash？</h3><ul><li>Shell：操作系统的命令解释器，允许用户与系统进行交互。常见的 Shell 包括 Bash、zsh、fish 等。</li><li>Bash (Bourne Again Shell)：是 Linux 和 macOS 默认的 Shell，提供了丰富的命令和脚本支持。</li><li>Shell 脚本允许自动化任务，许多 CLI 工具的核心逻辑往往需要与 Shell 交互。</li></ul><h3 id="2-什么是-CLI-与-GUI？"><a href="#2-什么是-CLI-与-GUI？" class="headerlink" title="2. 什么是 CLI 与 GUI？"></a>2. 什么是 CLI 与 GUI？</h3><ul><li>CLI（Command Line Interface，命令行接口）：用户通过命令输入与程序交互，如 git 或 npm。</li><li>GUI（Graphical User Interface，图形用户界面）：用户通过窗口和按钮与系统交互，如 VSCode。</li></ul><p>CLI 工具的优势在于：</p><ul><li>自动化程度高、支持脚本化操作。</li><li>高效处理批量任务，开发时可远程执行。</li></ul><h2 id="二、脚手架开发的预备知识"><a href="#二、脚手架开发的预备知识" class="headerlink" title="二、脚手架开发的预备知识"></a>二、脚手架开发的预备知识</h2><h3 id="1-了解-Node-js-的能力"><a href="#1-了解-Node-js-的能力" class="headerlink" title="1. 了解 Node.js 的能力"></a>1. 了解 Node.js 的能力</h3><ul><li>Node.js 提供内置模块（如 fs、child_process 等），适合开发 CLI。</li><li>Node.js 支持同步与异步 API，CLI 通常选择同步执行关键任务，确保顺序执行。</li></ul><h3 id="2-package-json-的-bin-字段"><a href="#2-package-json-的-bin-字段" class="headerlink" title="2. package.json 的 bin 字段"></a>2. package.json 的 bin 字段</h3><p>在 package.json 中配置 bin 字段，让你的脚手架可以全局执行。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;bin&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;my-cli&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./index.js&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="三、开发第一个脚手架"><a href="#三、开发第一个脚手架" class="headerlink" title="三、开发第一个脚手架"></a>三、开发第一个脚手架</h2><h3 id="1-初始化项目"><a href="#1-初始化项目" class="headerlink" title="1. 初始化项目"></a>1. 初始化项目</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> my-cli &amp;&amp; <span class="built_in">cd</span> my-cli</span><br><span class="line">npm init -y</span><br><span class="line"><span class="built_in">touch</span> index.js</span><br></pre></td></tr></table></figure><h3 id="2-在-index-js-中实现基础-CLI"><a href="#2-在-index-js-中实现基础-CLI" class="headerlink" title="2. 在 index.js 中实现基础 CLI"></a>2. 在 index.js 中实现基础 CLI</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env node</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [,, command, ...args] = process.<span class="property">argv</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (command) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;greet&#x27;</span>:</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;args[<span class="number">0</span>] || <span class="string">&#x27;World&#x27;</span>&#125;</span>!`</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="attr">default</span>:</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Usage: my-cli greet &lt;name&gt;&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>解释</strong> <code>const [,, command, ...args] = process.argv;</code></p><p>这行代码利用了 <strong>解构赋值</strong>，用于从 process.argv 中提取命令和参数。我们逐步解析这一部分代码，并解释为什么 command 前面有两个逗号。</p><p>process.argv 是一个数组，包含运行 Node.js 脚本时传入的所有命令行参数。其中：</p><ul><li>第 0 个元素：Node.js 可执行文件的路径（如 /usr/local/bin/node）。</li><li>第 1 个元素：正在执行的脚本路径（如 /Users/alice/my-cli/index.js）。</li><li>第 2 个元素及之后：用户传入的命令和参数。</li></ul><p>示例：</p><p>如果用户运行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node index.js greet Alice</span><br></pre></td></tr></table></figure><p>那么 process.argv 的值将是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  <span class="string">&#x27;/usr/local/bin/node&#x27;</span>,          <span class="comment">// 第 0 个元素</span></span><br><span class="line">  <span class="string">&#x27;/Users/alice/my-cli/index.js&#x27;</span>, <span class="comment">// 第 1 个元素</span></span><br><span class="line">  <span class="string">&#x27;greet&#x27;</span>,                        <span class="comment">// 第 2 个元素（命令）</span></span><br><span class="line">  <span class="string">&#x27;Alice&#x27;</span>                         <span class="comment">// 第 3 个元素（参数）</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>在 Node.js 中运行脚本时，第 0 个和第 1 个元素分别是 Node.js 可执行文件和脚本的路径。</p><p>对于命令行工具，我们通常不需要这两个路径，因此直接跳过。</p></blockquote><h3 id="3-本地测试"><a href="#3-本地测试" class="headerlink" title="3. 本地测试"></a>3. 本地测试</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./index.js greet Alice</span><br></pre></td></tr></table></figure><h3 id="4-配置全局运行"><a href="#4-配置全局运行" class="headerlink" title="4. 配置全局运行"></a>4. 配置全局运行</h3><p>在 package.json 中添加 bin 字段：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;bin&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;my-cli&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./index.js&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>使用 npm link 进行本地测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="built_in">link</span></span><br><span class="line">my-cli greet Bob</span><br></pre></td></tr></table></figure><h2 id="四、核心原生实现"><a href="#四、核心原生实现" class="headerlink" title="四、核心原生实现"></a>四、核心原生实现</h2><h3 id="1-读取用户输入（process-argv）"><a href="#1-读取用户输入（process-argv）" class="headerlink" title="1. 读取用户输入（process.argv）"></a>1. 读取用户输入（process.argv）</h3><p>Node.js 的 process.argv 提供命令行参数的访问能力：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> args = process.<span class="property">argv</span>.<span class="title function_">slice</span>(<span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Arguments: <span class="subst">$&#123;args.join(<span class="string">&#x27; &#x27;</span>)&#125;</span>`</span>);</span><br></pre></td></tr></table></figure><h3 id="2-文件系统操作（fs-模块）"><a href="#2-文件系统操作（fs-模块）" class="headerlink" title="2. 文件系统操作（fs 模块）"></a>2. 文件系统操作（fs 模块）</h3><p>创建和写入文件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">writeFileSync</span>(<span class="string">&#x27;hello.txt&#x27;</span>, <span class="string">&#x27;Hello, Node.js CLI!&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;File created: hello.txt&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="3-执行系统命令（child-process-模块）"><a href="#3-执行系统命令（child-process-模块）" class="headerlink" title="3. 执行系统命令（child_process 模块）"></a>3. 执行系统命令（child_process 模块）</h3><p>通过 Shell 执行命令：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; execSync &#125; = <span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = <span class="title function_">execSync</span>(<span class="string">&#x27;ls&#x27;</span>).<span class="title function_">toString</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br></pre></td></tr></table></figure><h3 id="4-处理用户交互（readline-模块）"><a href="#4-处理用户交互（readline-模块）" class="headerlink" title="4. 处理用户交互（readline 模块）"></a>4. 处理用户交互（readline 模块）</h3><p>简单实现用户输入：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> readline = <span class="built_in">require</span>(<span class="string">&#x27;readline&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rl = readline.<span class="title function_">createInterface</span>(&#123;</span><br><span class="line">  <span class="attr">input</span>: process.<span class="property">stdin</span>,</span><br><span class="line">  <span class="attr">output</span>: process.<span class="property">stdout</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">rl.<span class="title function_">question</span>(<span class="string">&#x27;What is your name? &#x27;</span>, <span class="function">(<span class="params">answer</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;answer&#125;</span>!`</span>);</span><br><span class="line">  rl.<span class="title function_">close</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="五、第三方库与框架介绍"><a href="#五、第三方库与框架介绍" class="headerlink" title="五、第三方库与框架介绍"></a>五、第三方库与框架介绍</h2><h3 id="1-commander：简化命令和参数处理。"><a href="#1-commander：简化命令和参数处理。" class="headerlink" title="1. commander：简化命令和参数处理。"></a>1. commander：简化命令和参数处理。</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install commander</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">Command</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;commander&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> program = <span class="keyword">new</span> <span class="title class_">Command</span>();</span><br><span class="line"></span><br><span class="line">program</span><br><span class="line">  .<span class="title function_">version</span>(<span class="string">&#x27;1.0.0&#x27;</span>)</span><br><span class="line">  .<span class="title function_">command</span>(<span class="string">&#x27;greet &lt;name&gt;&#x27;</span>)</span><br><span class="line">  .<span class="title function_">description</span>(<span class="string">&#x27;Say hello to someone&#x27;</span>)</span><br><span class="line">  .<span class="title function_">action</span>(<span class="function">(<span class="params">name</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;name&#125;</span>!`</span>));</span><br><span class="line"></span><br><span class="line">program.<span class="title function_">parse</span>(process.<span class="property">argv</span>);</span><br></pre></td></tr></table></figure><h3 id="2-inquirer：增强用户交互体验。"><a href="#2-inquirer：增强用户交互体验。" class="headerlink" title="2. inquirer：增强用户交互体验。"></a>2. inquirer：增强用户交互体验。</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install inquirer</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> inquirer = <span class="built_in">require</span>(<span class="string">&#x27;inquirer&#x27;</span>);</span><br><span class="line"></span><br><span class="line">inquirer.<span class="title function_">prompt</span>([</span><br><span class="line">  &#123; <span class="attr">type</span>: <span class="string">&#x27;input&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;username&#x27;</span>, <span class="attr">message</span>: <span class="string">&#x27;What is your name?&#x27;</span> &#125;</span><br><span class="line">]).<span class="title function_">then</span>(<span class="function"><span class="params">answers</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;answers.username&#125;</span>!`</span>));</span><br></pre></td></tr></table></figure><h3 id="3-chalk：为终端输出添加颜色。"><a href="#3-chalk：为终端输出添加颜色。" class="headerlink" title="3. chalk：为终端输出添加颜色。"></a>3. chalk：为终端输出添加颜色。</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install chalk</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> chalk = <span class="built_in">require</span>(<span class="string">&#x27;chalk&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(chalk.<span class="title function_">green</span>(<span class="string">&#x27;Success!&#x27;</span>));</span><br></pre></td></tr></table></figure><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>开发 CLI 脚手架并不复杂，只需掌握 Node.js 基础模块即可实现很多功能。在此基础上，你可以根据项目需求引入第三方库来增强用户体验。以下是脚手架开发的流程回顾：</p><ol><li>基础概念：理解 Shell、Bash、CLI 与 GUI 的区别。</li><li>项目初始化：配置 package.json 的 bin 字段。</li><li>核心实现：使用 process.argv、fs、child_process 等原生模块。</li><li>扩展功能：根据需要引入第三方库（如 commander 和 inquirer）。</li></ol><p>最后，分享一个自己开发的 Node.js CLI 工具：</p><p><a href="https://www.npmjs.com/package/douban-scanner">douban-scanner</a> —— 豆瓣扫描器，一个用来抓取豆瓣 “书影音” 数据的 CLI 工具</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;开发一个 Node.js CLI 脚手架，是创建高效开发工具的重要一步。本文将从基础概念入手，逐步深入开发过程，并以最小依赖实现第一个 CLI 工具。&lt;/p&gt;
&lt;h2 id=&quot;一、基础概念与预备知识&quot;&gt;&lt;a href=&quot;#一、基础概念与预备知识&quot; class=&quot;header</summary>
      
    
    
    
    <category term="未分类" scheme="https://www.laoliang.ink/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
    
    <category term="无标签" scheme="https://www.laoliang.ink/tags/%E6%97%A0%E6%A0%87%E7%AD%BE/"/>
    
  </entry>
  
  <entry>
    <title>从 Dark 看编程语言空安全特性</title>
    <link href="https://www.laoliang.ink/posts/20231109193941/"/>
    <id>https://www.laoliang.ink/posts/20231109193941/</id>
    <published>2023-11-09T11:39:41.000Z</published>
    <updated>2024-11-16T11:26:50.330Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前段时间想做一个小工具 APP，考虑想用 Flutter 实现，于是去看了看 Dart 语言，发现一个比较有意思的特性 —— “空安全”，这里和大家聊一聊。</p></blockquote><h2 id="什么是空安全"><a href="#什么是空安全" class="headerlink" title="什么是空安全"></a>什么是空安全</h2><p>空安全是指编程语言的类型系统能够区分可为空的类型和不能为空的类型，这种区别可以防止空引用错误（Null Reference Errors）。</p><h2 id="Dart-的空安全"><a href="#Dart-的空安全" class="headerlink" title="Dart 的空安全"></a>Dart 的空安全</h2><p>Dart 在 2.12 版本引入了空安全。</p><h3 id="可空和非空类型"><a href="#可空和非空类型" class="headerlink" title="可空和非空类型"></a><strong><strong>可空和非空类型</strong></strong></h3><p>在 Dart 中，所有类型默认都是非空的。例如，如果你声明一个 <code>String</code> 类型的变量，Dart 会假设它永远不会为空：</p><p><img src="/posts/20231109193941/%E6%B0%B8%E8%BF%9C%E4%B8%8D%E4%BC%9A%E4%B8%BA%E7%A9%BA.png" class="lazyload" data-srcset="/posts/20231109193941/%E6%B0%B8%E8%BF%9C%E4%B8%8D%E4%BC%9A%E4%B8%BA%E7%A9%BA.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="永远不会为空"></p><p>且不能将它赋予 <code>null</code> 值：</p><p><img src="/posts/20231109193941/%E4%B8%8D%E8%83%BD%E8%B5%8B%E4%BA%88null.png" class="lazyload" data-srcset="/posts/20231109193941/%E4%B8%8D%E8%83%BD%E8%B5%8B%E4%BA%88null.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="不能赋予null"></p><p>如果你想声明一个可以为空的 <code>String</code>，你需要在类型后面加上 <code>?</code>：</p><p><img src="/posts/20231109193941/%E5%A3%B0%E6%98%8E%E5%8F%AF%E4%B8%BA%E7%A9%BA%E7%9A%84String.png" class="lazyload" data-srcset="/posts/20231109193941/%E5%A3%B0%E6%98%8E%E5%8F%AF%E4%B8%BA%E7%A9%BA%E7%9A%84String.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="声明可为空的String"></p><h3 id="处理可空值"><a href="#处理可空值" class="headerlink" title="处理可空值"></a><strong><strong>处理可空值</strong></strong></h3><p>与 JS 类似，Dart 也提供了几种方式来处理可能为空的值。</p><p>例如，可以使用 <code>??</code> 操作符来提供一个默认值：</p><p><img src="/posts/20231109193941/%E6%8F%90%E4%BE%9B%E4%B8%80%E4%B8%AA%E9%BB%98%E8%AE%A4%E5%80%BC.png" class="lazyload" data-srcset="/posts/20231109193941/%E6%8F%90%E4%BE%9B%E4%B8%80%E4%B8%AA%E9%BB%98%E8%AE%A4%E5%80%BC.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="提供一个默认值"></p><p>可以使用 <code>?.</code> 操作符，在对象为空时，跳过方法调用或属性访问，避免抛出空引用错误：</p><p><img src="/posts/20231109193941/%E6%8A%9B%E5%87%BA%E7%A9%BA%E5%BC%95%E7%94%A8%E9%94%99%E8%AF%AF.png" class="lazyload" data-srcset="/posts/20231109193941/%E6%8A%9B%E5%87%BA%E7%A9%BA%E5%BC%95%E7%94%A8%E9%94%99%E8%AF%AF.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="抛出空引用错误"></p><p>针对上面这种情况，如果编译器解析出你去访问一个可能为空的对象的属性或方法时，没有使用 <code>?.</code> 操作符，这会在编译时就会报错，避免了运行时才暴露问题：</p><p><img src="/posts/20231109193941/%E9%81%BF%E5%85%8D%E4%BA%86%E8%BF%90%E8%A1%8C%E6%97%B6%E6%89%8D%E6%9A%B4%E9%9C%B2%E9%94%99%E8%AF%AF.png" class="lazyload" data-srcset="/posts/20231109193941/%E9%81%BF%E5%85%8D%E4%BA%86%E8%BF%90%E8%A1%8C%E6%97%B6%E6%89%8D%E6%9A%B4%E9%9C%B2%E9%94%99%E8%AF%AF.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="避免了运行时才暴露错误"></p><h3 id="空值断言操作符-的使用"><a href="#空值断言操作符-的使用" class="headerlink" title="空值断言操作符 ! 的使用"></a>空值断言操作符 <code>!</code> 的使用</h3><p>当我们排除变量或参数的可空的可能后，可以通过 <code>!</code> 来告诉编译器这个可空的变量或者参数不可空，这对我们进行方法传参或将可空的参数传递给一个不可空的入参时特别有用。</p><p>引用 Dart 文档中的一个例子⬇️：（From：<a href="https://dart.cn/null-safety/understanding-null-safety#null-assertion-operator">Dart｜ 空值断言操作符</a>）</p><p><img src="/posts/20231109193941/Dart%E6%96%87%E6%A1%A3%E4%B8%AD%E7%9A%84%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90.png" class="lazyload" data-srcset="/posts/20231109193941/Dart%E6%96%87%E6%A1%A3%E4%B8%AD%E7%9A%84%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="Dart文档中的一个例子"></p><p>由于 <code>error</code> 属性是可空的，在返回结果成功时，它不会有值。我们通过仔细观察类可以看出，当消息为空时，我们永远不会访问 <code>error</code>。但为了知晓这个行为，必须要理解 <code>code</code> 的值与 <code>error</code> 的可空性之间的联系。类型检查器看不出这种联系。</p><p>换句话说，作为代码的人类维护者，我们知道在使用 <code>error</code> 时，它的值不会是 <code>null</code>，并且我们需要对其进行断言。通常你可以通过使用 <code>as</code> 转换来断言类型，这里你也可以这样做：</p><p><img src="/posts/20231109193941/%E9%80%9A%E8%BF%87as%E8%BD%AC%E6%8D%A2%E6%9D%A5%E6%96%AD%E8%A8%80%E7%B1%BB%E5%9E%8B.png" class="lazyload" data-srcset="/posts/20231109193941/%E9%80%9A%E8%BF%87as%E8%BD%AC%E6%8D%A2%E6%9D%A5%E6%96%AD%E8%A8%80%E7%B1%BB%E5%9E%8B.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="通过as转换来断言类型"></p><p>编译时的报错消失了！⬆️</p><p>如果在运行时，将 <code>error</code> 转换为非空的 <code>String</code> 类型出现了无法转换的错误，会抛出一个异常。若转换成功，一个非空的字符串就会回到我们的手上，让我们可以进行方法调用。</p><p>“排除可空性的转换”的场景频繁出现，这促使了 Dart 带来了新的短小精悍的语法。一个作为后缀的感叹号标记 (<code>!</code>) 会让左侧的表达式转换成其对应的非空类型。所以上面的函数等效于：</p><p><img src="/posts/20231109193941/%E9%9D%9E%E7%A9%BA%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.png" class="lazyload" data-srcset="/posts/20231109193941/%E9%9D%9E%E7%A9%BA%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="非空类型转换"></p><p>当原有的类型非常繁琐的时候，这个只有一个字符的 “<code>!</code> 操作符” 就会非常顺手。如果仅仅是为了将一个类型转换为非空，就需要写出类似于 <code>as Map&lt;TransactionProviderFactory, List&lt;Set&lt;ResponseFilter&gt;&gt;&gt;</code> 这样的代码，会让这个过程变得非常烦人。</p><h2 id="TypeScript-开启严格空值检查"><a href="#TypeScript-开启严格空值检查" class="headerlink" title="TypeScript 开启严格空值检查"></a>TypeScript 开启严格空值检查</h2><blockquote><p>目前很多主流编程语言都对空安全有自己的支持，比如：Kotlink、Swift、Rust，包括我们熟悉的 TypeScript，其实也可以手动开启严格空值检查。</p></blockquote><p>TypeScript 里，JS 中的基本数据类型 <code>undefined</code> 和 <code>null</code> 两者各自有自己的类型分别叫做 <code>undefined</code> 和 <code>null</code>。</p><p>默认情况下 <code>null</code> 和 <code>undefined</code> 是所有类型的子类型。 就是说你可以把 <code>null</code> 和 <code>undefined</code> 赋值给 <code>number</code> 类型的变量。</p><p>例如下面的代码，在 TS 中是完全可以执行的：</p><p><img src="/posts/20231109193941/TS%E4%B8%AD%E6%94%AF%E6%8C%81%E6%83%85%E5%86%B5.png" class="lazyload" data-srcset="/posts/20231109193941/TS%E4%B8%AD%E6%94%AF%E6%8C%81%E6%83%85%E5%86%B5.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="TS中支持情况"></p><h3 id="strictNullChecks"><a href="#strictNullChecks" class="headerlink" title="strictNullChecks"></a><strong><strong>strictNullChecks</strong></strong></h3><p>TypeScript 2.0 增加了对 <strong>不可为空类型</strong> 的支持。有一种新的 <strong>严格空值检查</strong> 模式，他提供了 <strong><code>strictNullChecks</code></strong> 来限制对空值的检查，可以通过在命令行上添加 <code>--strictNullChecks</code> 参数来启功严格空值检查，也可以在项目的 <code>tsconfig.json</code> **文件中启用 <code>strictNullChecks</code> 编译器选项。</p><p>在TS中，为了各版本的兼容，<code>strictNullChecks</code> 的默认值是 <code>false</code>，我们需要手动设置为 <code>true</code>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;strictNullChecks&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>此时，我们刚刚的代码，就无法通过编译器检查了：</p><p><img src="/posts/20231109193941/%E6%97%A0%E6%B3%95%E9%80%9A%E8%BF%87%E7%BC%96%E8%AF%91%E5%99%A8%E6%A3%80%E6%9F%A5.png" class="lazyload" data-srcset="/posts/20231109193941/%E6%97%A0%E6%B3%95%E9%80%9A%E8%BF%87%E7%BC%96%E8%AF%91%E5%99%A8%E6%A3%80%E6%9F%A5.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="无法通过编译器检查"></p><h3 id="变量如何可以为空"><a href="#变量如何可以为空" class="headerlink" title="变量如何可以为空"></a>变量如何可以为空</h3><p>开启严格空值检查后，如果我们想要一个变量可以接受空值，我们该怎么办呢？</p><ol><li>使用联合类型 比如下面的代码，<code>username</code> 可以接受 <code>null</code> 类型的值，但是无法接受 <code>undefined</code> 的值：</li></ol><p><img src="/posts/20231109193941/%E5%8F%AF%E4%BB%A5%E6%8E%A5%E5%8F%97null%E4%BD%86%E6%98%AF%E6%97%A0%E6%B3%95%E6%8E%A5%E5%8F%97undefined.png" class="lazyload" data-srcset="/posts/20231109193941/%E5%8F%AF%E4%BB%A5%E6%8E%A5%E5%8F%97null%E4%BD%86%E6%98%AF%E6%97%A0%E6%B3%95%E6%8E%A5%E5%8F%97undefined.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="可以接受null但是无法接受undefined"></p><ol><li>在 Object 中使用 <code>?</code> 可选属性 首先，联合类型可以在 Object 中使用： <img src="/posts/20231109193941/%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B%E5%8F%AF%E4%BB%A5%E5%9C%A8Object%E4%B8%AD%E4%BD%BF%E7%94%A8.png" class="lazyload" data-srcset="/posts/20231109193941/%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B%E5%8F%AF%E4%BB%A5%E5%9C%A8Object%E4%B8%AD%E4%BD%BF%E7%94%A8.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="联合类型可以在Object中使用"> 这里我们设置 <code>age</code> 的类型为 <code>number</code> 和 <code>undefined</code>，下面的两种用法都是正确的： <img src="/posts/20231109193941/%E4%B8%A4%E7%A7%8D%E7%94%A8%E6%B3%95%E9%83%BD%E6%98%AF%E6%AD%A3%E7%A1%AE%E7%9A%84.png" class="lazyload" data-srcset="/posts/20231109193941/%E4%B8%A4%E7%A7%8D%E7%94%A8%E6%B3%95%E9%83%BD%E6%98%AF%E6%AD%A3%E7%A1%AE%E7%9A%84.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="两种用法都是正确的"> 如果我们想要下面的效果，不需要手动给 <code>age</code> 赋值： <img src="/posts/20231109193941/%E4%B8%8D%E9%9C%80%E8%A6%81%E6%89%8B%E5%8A%A8%E7%BB%99age%E8%B5%8B%E5%80%BC.png" class="lazyload" data-srcset="/posts/20231109193941/%E4%B8%8D%E9%9C%80%E8%A6%81%E6%89%8B%E5%8A%A8%E7%BB%99age%E8%B5%8B%E5%80%BC.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="不需要手动给age赋值"> 此时我们就需要用到 <code>?</code> 来使属性成为可选，这样我们就可以完全省略 <code>age</code> 属性的定义。 <img src="/posts/20231109193941/%E7%9C%81%E7%95%A5age%E5%B1%9E%E6%80%A7%E7%9A%84%E5%AE%9A%E4%B9%89.png" class="lazyload" data-srcset="/posts/20231109193941/%E7%9C%81%E7%95%A5age%E5%B1%9E%E6%80%A7%E7%9A%84%E5%AE%9A%E4%B9%89.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="省略age属性的定义"> 在这种情况下：<code>undefined</code> 类型会自动添加到联合类型中。因此，以下所有赋值都是正确的： <img src="/posts/20231109193941/%E4%BB%A5%E4%B8%8B%E6%89%80%E6%9C%89%E8%B5%8B%E5%80%BC%E9%83%BD%E6%98%AF%E6%AD%A3%E7%A1%AE%E7%9A%84.png" class="lazyload" data-srcset="/posts/20231109193941/%E4%BB%A5%E4%B8%8B%E6%89%80%E6%9C%89%E8%B5%8B%E5%80%BC%E9%83%BD%E6%98%AF%E6%AD%A3%E7%A1%AE%E7%9A%84.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="以下所有赋值都是正确的"></li></ol><h2 id="引入空安全的好处"><a href="#引入空安全的好处" class="headerlink" title="引入空安全的好处"></a>引入空安全的好处</h2><ul><li>可以将原本运行时的空值引用错误，变为编译时的分析错误</li><li>增强程序的健壮性，有效避免由Null而导致的崩溃</li><li>由于空安全特性的存在，编译层面可以做很多优化</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;前段时间想做一个小工具 APP，考虑想用 Flutter 实现，于是去看了看 Dart 语言，发现一个比较有意思的特性 —— “空安全”，这里和大家聊一聊。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;什么是空安全&quot;&gt;&lt;a href=&quot;#什</summary>
      
    
    
    
    <category term="未分类" scheme="https://www.laoliang.ink/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
    
    <category term="无标签" scheme="https://www.laoliang.ink/tags/%E6%97%A0%E6%A0%87%E7%AD%BE/"/>
    
  </entry>
  
  <entry>
    <title>客户端与服务器即时通信的几种实现方式</title>
    <link href="https://www.laoliang.ink/posts/20231019221911/"/>
    <id>https://www.laoliang.ink/posts/20231019221911/</id>
    <published>2023-10-19T14:19:11.000Z</published>
    <updated>2024-11-16T11:26:50.330Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-轮询（Polling）——-简单直接的老方法"><a href="#1-轮询（Polling）——-简单直接的老方法" class="headerlink" title="1. 轮询（Polling）—— 简单直接的老方法"></a>1. 轮询（Polling）—— 简单直接的老方法</h2><p>轮询是一种最基础的通信方式，客户端定期向服务器发送 HTTP 请求，询问是否有新数据。</p><h3 id="实现示例"><a href="#实现示例" class="headerlink" title="实现示例"></a><strong>实现示例</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每隔5秒轮询一次服务器是否有新消息</span></span><br><span class="line"><span class="built_in">setInterval</span>(<span class="title function_">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;/api/messages&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> response.<span class="title function_">json</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;新消息:&#x27;</span>, data);</span><br><span class="line">&#125;, <span class="number">5000</span>);</span><br></pre></td></tr></table></figure><h3 id="优缺点分析"><a href="#优缺点分析" class="headerlink" title="优缺点分析"></a><strong>优缺点分析</strong></h3><ul><li>优点：简单易用，所有浏览器都支持。</li><li>缺点：响应不及时，浪费带宽，服务器压力大。</li></ul><p><strong>适用场景</strong>：对实时性要求不高的项目，如低频更新的系统状态检查。</p><h2 id="2-长轮询（Long-Polling）——-聊天系统的好搭档"><a href="#2-长轮询（Long-Polling）——-聊天系统的好搭档" class="headerlink" title="2. 长轮询（Long Polling）—— 聊天系统的好搭档"></a>2. 长轮询（Long Polling）—— 聊天系统的好搭档</h2><p>长轮询是轮询的升级版：客户端发起请求后，如果服务器暂时没有数据，不会立即返回响应，而是等到有新数据时才返回。</p><h3 id="实现示例-1"><a href="#实现示例-1" class="headerlink" title="实现示例"></a><strong>实现示例</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 长轮询请求示例</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">longPoll</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;/api/messages&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> data = <span class="keyword">await</span> response.<span class="title function_">json</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;收到消息:&#x27;</span>, data);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;连接错误:&#x27;</span>, error);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 收到消息或连接断开后，立即发起下一次请求</span></span><br><span class="line">    <span class="title function_">longPoll</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">longPoll</span>();</span><br></pre></td></tr></table></figure><h3 id="优缺点分析-1"><a href="#优缺点分析-1" class="headerlink" title="优缺点分析"></a><strong>优缺点分析</strong></h3><ul><li>优点：比传统轮询更高效，减少了不必要的请求。</li><li>缺点：服务器需要长时间维护连接，对资源占用较高。</li></ul><p><strong>适用场景</strong>：适用于需要准实时响应的聊天系统或通知系统。</p><h2 id="3-WebSocket-——-全双工通信的利器"><a href="#3-WebSocket-——-全双工通信的利器" class="headerlink" title="3. WebSocket —— 全双工通信的利器"></a>3. WebSocket —— 全双工通信的利器</h2><p>WebSocket 是一种基于 TCP 的全双工通信协议，允许客户端和服务器之间建立持久连接，双方可以互相主动发送数据。</p><h3 id="实现示例-2"><a href="#实现示例-2" class="headerlink" title="实现示例"></a><strong>实现示例</strong></h3><p>客户端代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> socket = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&#x27;wss://example.com/socket&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听服务器消息</span></span><br><span class="line">socket.<span class="property">onmessage</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;收到消息:&#x27;</span>, event.<span class="property">data</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送消息给服务器</span></span><br><span class="line">socket.<span class="property">onopen</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  socket.<span class="title function_">send</span>(<span class="string">&#x27;Hello, Server!&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理错误</span></span><br><span class="line">socket.<span class="property">onerror</span> = <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;WebSocket 错误:&#x27;</span>, error);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="优缺点分析-2"><a href="#优缺点分析-2" class="headerlink" title="优缺点分析"></a><strong>优缺点分析</strong></h3><ul><li>优点：双向通信，实时性极高，适合高并发应用。</li><li>缺点：需要服务器支持 WebSocket，客户端实现也较复杂。</li></ul><p><strong>适用场景</strong>：在线游戏、实时协作工具、股票交易系统等对实时性要求极高的应用。</p><h2 id="4-服务器推送事件（Server-Sent-Events-SSE）——-简单的单向推送"><a href="#4-服务器推送事件（Server-Sent-Events-SSE）——-简单的单向推送" class="headerlink" title="4. 服务器推送事件（Server-Sent Events, SSE）—— 简单的单向推送"></a>4. 服务器推送事件（Server-Sent Events, SSE）—— 简单的单向推送</h2><p>SSE 允许服务器主动推送数据给客户端，客户端只需建立一次连接。<br>这是一个基于 HTTP 协议的单向通信方式。</p><h3 id="实现示例-3"><a href="#实现示例-3" class="headerlink" title="实现示例"></a><strong>实现示例</strong></h3><p>服务器端（Node.js 示例）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"></span><br><span class="line">http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.<span class="title function_">writeHead</span>(<span class="number">200</span>, &#123;</span><br><span class="line">    <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/event-stream&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Cache-Control&#x27;</span>: <span class="string">&#x27;no-cache&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Connection&#x27;</span>: <span class="string">&#x27;keep-alive&#x27;</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    res.<span class="title function_">write</span>(<span class="string">`data: <span class="subst">$&#123;<span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleTimeString()&#125;</span>\n\n`</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;).<span class="title function_">listen</span>(<span class="number">3000</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;SSE 服务器已启动，监听端口 3000&#x27;</span>);</span><br></pre></td></tr></table></figure><p>客户端代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> eventSource = <span class="keyword">new</span> <span class="title class_">EventSource</span>(<span class="string">&#x27;/sse&#x27;</span>);</span><br><span class="line"></span><br><span class="line">eventSource.<span class="property">onmessage</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;收到服务器推送:&#x27;</span>, event.<span class="property">data</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="优缺点分析-3"><a href="#优缺点分析-3" class="headerlink" title="优缺点分析"></a><strong>优缺点分析</strong></h3><ul><li>优点：实现简单，支持自动重连，节省带宽。</li><li>缺点：只支持单向通信，客户端无法主动发送数据。</li></ul><p><strong>适用场景</strong>：实时新闻推送、数据监控面板。</p><h2 id="5-HTTP-2-Push-——-优化资源加载的新选择"><a href="#5-HTTP-2-Push-——-优化资源加载的新选择" class="headerlink" title="5. HTTP/2 Push —— 优化资源加载的新选择"></a>5. HTTP/2 Push —— 优化资源加载的新选择</h2><p>HTTP/2 Push 是 HTTP/2 协议中的一项功能，允许服务器在客户端请求前主动推送资源。</p><h3 id="优缺点分析-4"><a href="#优缺点分析-4" class="headerlink" title="优缺点分析"></a><strong>优缺点分析</strong></h3><ul><li>优点：减少延迟，提高页面加载速度。</li><li>缺点：浏览器和服务器必须都支持 HTTP/2。</li></ul><p><strong>适用场景</strong>：主要用于优化前端资源加载，例如预加载 CSS 或 JavaScript 文件。</p><h2 id="总结：如何选择合适的即时通信方案？"><a href="#总结：如何选择合适的即时通信方案？" class="headerlink" title="总结：如何选择合适的即时通信方案？"></a>总结：如何选择合适的即时通信方案？</h2><table><thead><tr><th align="center">方案</th><th align="center">优点</th><th align="center">缺点</th><th align="center">适用场景</th></tr></thead><tbody><tr><td align="center">轮询</td><td align="center">简单直接</td><td align="center">浪费带宽，响应不及时</td><td align="center">低频数据刷新</td></tr><tr><td align="center">长轮询</td><td align="center">相对高效</td><td align="center">服务器资源占用较高</td><td align="center">聊天系统、通知系统</td></tr><tr><td align="center">WebSocket</td><td align="center">双向通信，实时性高</td><td align="center">实现复杂</td><td align="center">在线游戏、协作工具</td></tr><tr><td align="center">SSE</td><td align="center">实现简单，支持自动重连</td><td align="center">单向通信</td><td align="center">数据监控、实时新闻</td></tr><tr><td align="center">HTTP/2 Push</td><td align="center">优化资源加载</td><td align="center">需要 HTTP/2 支持</td><td align="center">前端性能优化</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-轮询（Polling）——-简单直接的老方法&quot;&gt;&lt;a href=&quot;#1-轮询（Polling）——-简单直接的老方法&quot; class=&quot;headerlink&quot; title=&quot;1. 轮询（Polling）—— 简单直接的老方法&quot;&gt;&lt;/a&gt;1. 轮询（Polling</summary>
      
    
    
    
    <category term="未分类" scheme="https://www.laoliang.ink/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
    
    <category term="无标签" scheme="https://www.laoliang.ink/tags/%E6%97%A0%E6%A0%87%E7%AD%BE/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 浮点数与 0 按位或，实现舍弃小数位取整</title>
    <link href="https://www.laoliang.ink/posts/20230607191236/"/>
    <id>https://www.laoliang.ink/posts/20230607191236/</id>
    <published>2023-06-07T11:12:36.000Z</published>
    <updated>2024-11-16T11:26:50.329Z</updated>
    
    <content type="html"><![CDATA[<p>今天工作时，在项目中发现一处有趣的 JavaScript 代码，它将一个浮点数与 0，进行了一个 <strong>按位或</strong> 运算。开始还不清楚所谓何意，后来通过测试和查证才知道。</p><p>原来，使用 <strong>按位或运算符 (|)</strong> 可以将浮点数转为整数，并舍弃小数部分。这是因为按位操作会将数字隐式转换为 <strong>32 位整数</strong>，从而舍弃小数部分。示例代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">5.67</span>;</span><br><span class="line"><span class="keyword">let</span> result = num | <span class="number">0</span>;  <span class="comment">// 按位或运算</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);   <span class="comment">// 输出: 5</span></span><br></pre></td></tr></table></figure><p><strong>原理：</strong></p><ol><li><strong>按位或 (|)</strong> 运算符会将操作数转换为32位有符号整数。</li><li>浮点型的小数部分在转换过程中会被截断，而不是四舍五入。</li></ol><p><strong>优点：</strong></p><ul><li>   性能好：比 Math.floor()、parseInt() 等函数更快。</li><li>   简洁：代码简单，易于书写。</li></ul><p><strong>注意事项：</strong></p><ol><li>只能处理 <strong>32位整数范围内的数值</strong> （即：-2^31 到 2^31 - 1）。对于超出此范围的数，结果可能不准确。</li><li>如果需要 <strong>向下取整</strong> 或处理 <strong>负数</strong>，可以改用 Math.floor()：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(-<span class="number">5.67</span> | <span class="number">0</span>);     <span class="comment">// 输出: -5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="title function_">floor</span>(-<span class="number">5.67</span>)); <span class="comment">// 输出: -6</span></span><br></pre></td></tr></table></figure><p><strong>结论：</strong></p><p>所以，num | 0 确实是一种快速、简便的方式来舍弃小数部分取整，但要注意其处理负数的行为和范围限制。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天工作时，在项目中发现一处有趣的 JavaScript 代码，它将一个浮点数与 0，进行了一个 &lt;strong&gt;按位或&lt;/strong&gt; 运算。开始还不清楚所谓何意，后来通过测试和查证才知道。&lt;/p&gt;
&lt;p&gt;原来，使用 &lt;strong&gt;按位或运算符 (|)&lt;/strong</summary>
      
    
    
    
    <category term="未分类" scheme="https://www.laoliang.ink/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
    
    <category term="无标签" scheme="https://www.laoliang.ink/tags/%E6%97%A0%E6%A0%87%E7%AD%BE/"/>
    
  </entry>
  
  <entry>
    <title>macOS - 给 Terminal(终端)配置网络代理</title>
    <link href="https://www.laoliang.ink/posts/20230102172153/"/>
    <id>https://www.laoliang.ink/posts/20230102172153/</id>
    <published>2023-01-02T09:21:53.000Z</published>
    <updated>2024-11-16T11:26:50.329Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>与浏览器不同，mac 的终端默认并没有开启代理模式，也就是说即使我们电脑安装了代理客户端，在终端中也是无法使用代理的。下面通过样例演示如何对终端配置网络代理。</p></blockquote><h2 id="1-确定客户端端口"><a href="#1-确定客户端端口" class="headerlink" title="1. 确定客户端端口"></a>1. 确定客户端端口</h2><p>首先我们打开使用的代理客户端设置界面，查看其开放的 HTTP 端口，比如我这里是 1087</p><p><img src="/posts/20230102172153/%E7%9B%91%E5%90%AC%E7%AB%AF%E5%8F%A3.png" class="lazyload" data-srcset="/posts/20230102172153/%E7%9B%91%E5%90%AC%E7%AB%AF%E5%8F%A3.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="监听端口"></p><h2 id="2-配置代理"><a href="#2-配置代理" class="headerlink" title="2. 配置代理"></a>2. 配置代理</h2><p>macOS Catalina 之后，Mac 使用 zsh 作为默认的 Shell 终端，我们这里就以 zsh 配置为例展示配置方法。</p><p>修改 <code>~/.zshrc</code> 配置文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.zshrc</span><br></pre></td></tr></table></figure><p>向其中添加如下内容：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Turn on and off all_proxy</span></span><br><span class="line"><span class="built_in">alias</span> proxy=<span class="string">&quot;export all_proxy=http://127.0.0.1:1087 &amp;&amp; echo &#x27;Already turn on all_proxy to http://127.0.0.1:1087&#x27;&quot;</span></span><br><span class="line"><span class="built_in">alias</span> unproxy=<span class="string">&quot;unset all_proxy &amp;&amp; echo &#x27;Already turn off all_proxy&#x27;&quot;</span></span><br></pre></td></tr></table></figure><p>保存退出 vim 后，执行如下命令，使配置生效</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure><h2 id="3-测试"><a href="#3-测试" class="headerlink" title="3. 测试"></a>3. 测试</h2><p>首先我们使用 curl 命令查看终端目前的 IP：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl ipinfo.io</span><br></pre></td></tr></table></figure><p>得到类似下面的结果，可以看出确实使用的是国内的 IP 地址：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;ip&quot;</span><span class="punctuation">:</span> <span class="string">&quot;...&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;region&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Guangdong&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;country&quot;</span><span class="punctuation">:</span> <span class="string">&quot;CN&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;timezone&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Asia/Shanghai&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>接着我们执行 <code>proxy</code> 命令开启终端代理模式（仅针对当前会话生效）：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxy</span><br></pre></td></tr></table></figure><p>再次使用 curl 命令查看可以发现变成了国外的 IP（代理服务器的 IP）：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;ip&quot;</span><span class="punctuation">:</span> <span class="string">&quot;...&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;region&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Tokyo&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;country&quot;</span><span class="punctuation">:</span> <span class="string">&quot;JP&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;timezone&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Asia/Tokyo&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>如果需要关闭代理模式，执行如下命令即可：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unproxy</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;与浏览器不同，mac 的终端默认并没有开启代理模式，也就是说即使我们电脑安装了代理客户端，在终端中也是无法使用代理的。下面通过样例演示如何对终端配置网络代理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-确定客户端端口&quot;&gt;&lt;a href</summary>
      
    
    
    
    <category term="未分类" scheme="https://www.laoliang.ink/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
    
    <category term="无标签" scheme="https://www.laoliang.ink/tags/%E6%97%A0%E6%A0%87%E7%AD%BE/"/>
    
  </entry>
  
  <entry>
    <title>如何减少关键路径渲染（Critical Rendering Path）</title>
    <link href="https://www.laoliang.ink/posts/20221122231311/"/>
    <id>https://www.laoliang.ink/posts/20221122231311/</id>
    <published>2022-11-22T15:13:11.000Z</published>
    <updated>2024-11-16T11:26:50.329Z</updated>
    
    <content type="html"><![CDATA[<p><strong>关键路径渲染（Critical Rendering Path，CRP）</strong> 是指浏览器将 HTML、CSS 和 JavaScript 解析为可视页面的过程。CRP 的优化直接影响 <strong>页面的首次内容呈现时间</strong> 和用户的 <strong>加载体验</strong>。在现代前端开发中，减少关键路径渲染的时间已成为提升网页性能的关键环节。本文将逐步讲解 CRP 的工作原理，并提供实用的优化策略。</p><h2 id="一、什么是关键路径渲染（CRP）？"><a href="#一、什么是关键路径渲染（CRP）？" class="headerlink" title="一、什么是关键路径渲染（CRP）？"></a>一、什么是关键路径渲染（CRP）？</h2><p>浏览器渲染页面的过程大致如下：</p><ol><li>HTML 解析为 DOM 树：浏览器逐行解析 HTML 代码，构建 DOM（Document Object Model）树。</li><li>CSS 解析为 CSSOM 树：同时解析 CSS，构建 CSSOM（CSS Object Model）树。</li><li>合并 DOM 和 CSSOM 树：生成渲染树（Render Tree），决定哪些元素可见。</li><li>布局和绘制：浏览器计算元素的位置和大小（布局），然后将其绘制到屏幕。</li></ol><p>如果某些资源（如 JS 或 CSS 文件）未及时加载并阻塞了这个过程，就会延长页面的首屏呈现时间，导致用户体验下降。</p><h2 id="二、如何减少关键路径渲染的时间？"><a href="#二、如何减少关键路径渲染的时间？" class="headerlink" title="二、如何减少关键路径渲染的时间？"></a>二、如何减少关键路径渲染的时间？</h2><p>减少 CRP 的时间，主要依赖减少资源体积、缩短加载时间和优化资源的解析顺序。以下是一些行之有效的优化策略。</p><h3 id="1-减少阻塞资源"><a href="#1-减少阻塞资源" class="headerlink" title="1. 减少阻塞资源"></a>1. 减少阻塞资源</h3><h4 id="1-1-延迟加载-JavaScript"><a href="#1-1-延迟加载-JavaScript" class="headerlink" title="1.1 延迟加载 JavaScript"></a>1.1 延迟加载 JavaScript</h4><p>JavaScript 文件会阻塞 HTML 的解析，因此可以使用 defer 或 async 来延迟脚本加载。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 使用 <span class="keyword">async</span> 加载，脚本下载完成后立即执行 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;script.js&quot;</span> <span class="attr">async</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;!-- 使用 defer 加载，脚本在 <span class="variable constant_">HTML</span> 解析完成后执行 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;script.js&quot;</span> <span class="attr">defer</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>推荐：将不影响页面首屏展示的 JS 脚本标记为 defer。</p><h4 id="1-2-内联关键-CSS"><a href="#1-2-内联关键-CSS" class="headerlink" title="1.2 内联关键 CSS"></a>1.2 内联关键 CSS</h4><p>将首屏展示所需的 CSS内联到 HTML 中，减少 CSS 文件的加载延迟。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">body</span> &#123; <span class="attribute">margin</span>: <span class="number">0</span>; <span class="attribute">font-family</span>: sans-serif; &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.hero</span> &#123; <span class="attribute">background-color</span>: <span class="number">#4CAF50</span>; <span class="attribute">height</span>: <span class="number">100vh</span>; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-压缩和优化资源"><a href="#2-压缩和优化资源" class="headerlink" title="2. 压缩和优化资源"></a>2. 压缩和优化资源</h3><h4 id="2-1-使用-Gzip-或-Brotli-压缩"><a href="#2-1-使用-Gzip-或-Brotli-压缩" class="headerlink" title="2.1 使用 Gzip 或 Brotli 压缩"></a>2.1 使用 Gzip 或 Brotli 压缩</h4><p>启用服务器端压缩，减少 HTML、CSS 和 JavaScript 文件的传输体积。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 nginx 配置中启用 Gzip</span></span><br><span class="line">gzip on;</span><br><span class="line">gzip_types text/plain text/css application/javascript;</span><br></pre></td></tr></table></figure><h4 id="2-2-使用-Tree-Shaking-和代码拆分"><a href="#2-2-使用-Tree-Shaking-和代码拆分" class="headerlink" title="2.2 使用 Tree Shaking 和代码拆分"></a>2.2 使用 Tree Shaking 和代码拆分</h4><p>通过 Tree Shaking 移除未使用的代码，并利用代码拆分减少首次加载的资源量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Tree Shaking 示例，只打包实际使用的函数</span></span><br><span class="line"><span class="keyword">import</span> &#123; usedFunction &#125; <span class="keyword">from</span> <span class="string">&#x27;./utils&#x27;</span>;</span><br><span class="line"><span class="title function_">usedFunction</span>();</span><br></pre></td></tr></table></figure><h3 id="3-优化-CSS-和字体加载"><a href="#3-优化-CSS-和字体加载" class="headerlink" title="3. 优化 CSS 和字体加载"></a>3. 优化 CSS 和字体加载</h3><h4 id="3-1-减少-CSS-文件体积"><a href="#3-1-减少-CSS-文件体积" class="headerlink" title="3.1 减少 CSS 文件体积"></a>3.1 减少 CSS 文件体积</h4><ul><li>删除未使用的 CSS。</li><li>使用 CSS 压缩工具（如 cssnano）。</li></ul><h4 id="3-2-使用字体加载优化"><a href="#3-2-使用字体加载优化" class="headerlink" title="3.2 使用字体加载优化"></a>3.2 使用字体加载优化</h4><p>使用 font-display: swap 避免字体阻塞渲染。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@font-face</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">&#x27;CustomFont&#x27;</span>;</span><br><span class="line">  <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">&#x27;custom-font.woff2&#x27;</span>) <span class="built_in">format</span>(<span class="string">&#x27;woff2&#x27;</span>);</span><br><span class="line">  <span class="attribute">font-display</span>: swap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-使用缓存提升加载速度"><a href="#4-使用缓存提升加载速度" class="headerlink" title="4. 使用缓存提升加载速度"></a>4. 使用缓存提升加载速度</h3><ol><li>启用浏览器缓存：设置 HTTP 头，如 Cache-Control 和 ETag，确保静态资源被缓存。</li><li>使用 Service Worker：利用 PWA 技术，将资源缓存到本地，提高页面的离线访问能力。</li></ol><h3 id="5-优先加载关键资源"><a href="#5-优先加载关键资源" class="headerlink" title="5. 优先加载关键资源"></a>5. 优先加载关键资源</h3><h4 id="5-1-使用"><a href="#5-1-使用" class="headerlink" title="5.1 使用 "></a>5.1 使用 <link rel="preload"></h4><p>预加载关键资源，确保它们尽快开始下载。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;preload&quot;</span> <span class="attr">href</span>=<span class="string">&quot;styles.css&quot;</span> <span class="attr">as</span>=<span class="string">&quot;style&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;preload&quot;</span> <span class="attr">href</span>=<span class="string">&quot;script.js&quot;</span> <span class="attr">as</span>=<span class="string">&quot;script&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="5-2-使用"><a href="#5-2-使用" class="headerlink" title="5.2 使用 "></a>5.2 使用 <link rel="prefetch"></h4><p>为非关键资源使用预获取策略，提高后续页面加载速度。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;prefetch&quot;</span> <span class="attr">href</span>=<span class="string">&quot;next-page.html&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="6-减少重排与重绘"><a href="#6-减少重排与重绘" class="headerlink" title="6. 减少重排与重绘"></a>6. 减少重排与重绘</h3><ul><li>避免频繁操作 DOM：合并多次 DOM 修改，减少重排开销。</li><li>使用 CSS 动画代替 JavaScript 动画：CSS 动画通常性能更好。</li><li>避免触发 Layout Thrashing：避免在 JS 中频繁读取和写入 DOM 属性。</li></ul><h2 id="三、常见问题与解决方案"><a href="#三、常见问题与解决方案" class="headerlink" title="三、常见问题与解决方案"></a>三、常见问题与解决方案</h2><h3 id="问题-1：如何判断哪些资源属于关键资源？"><a href="#问题-1：如何判断哪些资源属于关键资源？" class="headerlink" title="问题 1：如何判断哪些资源属于关键资源？"></a>问题 1：如何判断哪些资源属于关键资源？</h3><p>解决方案：使用 Chrome DevTools 的“性能面板”查看加载的资源，并标记延迟页面渲染的关键资源。</p><h3 id="问题-2：如何避免字体加载造成的闪烁（FOIT）？"><a href="#问题-2：如何避免字体加载造成的闪烁（FOIT）？" class="headerlink" title="问题 2：如何避免字体加载造成的闪烁（FOIT）？"></a>问题 2：如何避免字体加载造成的闪烁（FOIT）？</h3><p>解决方案：为字体添加 font-display: swap，让浏览器使用系统字体进行替代，直至自定义字体加载完成。</p><h3 id="问题-3：如何减少第三方库对渲染的影响？"><a href="#问题-3：如何减少第三方库对渲染的影响？" class="headerlink" title="问题 3：如何减少第三方库对渲染的影响？"></a>问题 3：如何减少第三方库对渲染的影响？</h3><p>解决方案：</p><ul><li>使用 async 或 defer 延迟加载第三方 JS 脚本，如广告、分析工具等。</li><li>利用动态导入按需加载部分第三方依赖。</li><li>使用轻量替代库，如用 day.js 替代 moment.js。</li></ul><h3 id="问题-4：如何避免图片加载影响页面首屏渲染？"><a href="#问题-4：如何避免图片加载影响页面首屏渲染？" class="headerlink" title="问题 4：如何避免图片加载影响页面首屏渲染？"></a>问题 4：如何避免图片加载影响页面首屏渲染？</h3><p>解决方案：</p><ul><li>使用 lazyload 延迟加载首屏外的图片。</li><li>将小图片转换为 Base64 格式内联到 HTML 中，减少 HTTP 请求。</li><li>使用 srcset 和 sizes 优化响应式图片加载。</li></ul><h3 id="问题-5：如何优化首次访问与返回访问的性能差异？"><a href="#问题-5：如何优化首次访问与返回访问的性能差异？" class="headerlink" title="问题 5：如何优化首次访问与返回访问的性能差异？"></a>问题 5：如何优化首次访问与返回访问的性能差异？</h3><p>解决方案：</p><ul><li>配置 Service Worker 将关键资源缓存到本地，缩短后续访问时间。</li><li>使用 HTTP/2 或 HTTP/3 多路复用技术，提升首次访问时的资源加载速度。</li></ul><h3 id="问题-6：如何监控并持续优化-CRP？"><a href="#问题-6：如何监控并持续优化-CRP？" class="headerlink" title="问题 6：如何监控并持续优化 CRP？"></a>问题 6：如何监控并持续优化 CRP？</h3><p>解决方案：</p><ul><li>使用 Lighthouse 或 Web Vitals 插件定期生成性能报告。</li><li>集成 Google Analytics 的 First Input Delay (FID) 指标，实时分析页面交互性能。</li><li>持续关注 CLS（Cumulative Layout Shift），减少布局偏移问题。</li></ul><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>减少关键路径渲染时间对于提升网页性能和用户体验至关重要。通过减少阻塞资源、压缩和优化资源、优先加载关键内容和减少重排与重绘，我们可以有效缩短页面的首次内容呈现时间。</p><p>在实际项目中，优化 CRP 是一个持续的过程。建议借助 Chrome DevTools 等工具，实时监控性能瓶颈，并逐步优化。优化后的页面不仅能显著提升加载速度，也能提高用户的访问体验，带来更高的转化率。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;关键路径渲染（Critical Rendering Path，CRP）&lt;/strong&gt; 是指浏览器将 HTML、CSS 和 JavaScript 解析为可视页面的过程。CRP 的优化直接影响 &lt;strong&gt;页面的首次内容呈现时间&lt;/strong&gt; 和用户</summary>
      
    
    
    
    <category term="未分类" scheme="https://www.laoliang.ink/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
    
    <category term="无标签" scheme="https://www.laoliang.ink/tags/%E6%97%A0%E6%A0%87%E7%AD%BE/"/>
    
  </entry>
  
  <entry>
    <title>手动实现 JavaScript 迭代器</title>
    <link href="https://www.laoliang.ink/posts/20221121203323/"/>
    <id>https://www.laoliang.ink/posts/20221121203323/</id>
    <published>2022-11-21T12:33:23.000Z</published>
    <updated>2024-11-16T11:26:50.329Z</updated>
    
    <content type="html"><![CDATA[<p>在 JavaScript 中，迭代器是一个非常强大的工具。它允许我们逐步遍历集合中的元素，如数组、字符串、Map 等。然而，除了使用内置的迭代器（如 for…of、Array.prototype.entries() 等），我们还可以手动实现自己的迭代器来满足特殊需求。今天我们就从零开始，逐步带你了解如何实现一个 JavaScript 迭代器。</p><h2 id="一、什么是迭代器？"><a href="#一、什么是迭代器？" class="headerlink" title="一、什么是迭代器？"></a>一、什么是迭代器？</h2><p>迭代器的本质是一个对象，它提供了一种标准化的访问数据的方法。它需要具备两个关键要素：</p><ol><li><strong>next() 方法：</strong> 每次调用时，返回一个包含 value 和 done 属性的对象。</li><li><strong>状态跟踪：</strong> 用于记录当前迭代的进度。</li></ol><p>返回的对象结构为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">value</span>: &lt;当前值&gt;, <span class="attr">done</span>: &lt;是否结束&gt; &#125;</span><br></pre></td></tr></table></figure><ul><li>value 表示当前迭代项的值。</li><li>done 是一个布尔值，用于表示迭代是否结束。</li></ul><h2 id="二、内置迭代器的简单例子"><a href="#二、内置迭代器的简单例子" class="headerlink" title="二、内置迭代器的简单例子"></a>二、内置迭代器的简单例子</h2><p>在继续之前，我们先来看一个数组的内置迭代器：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> iterator = arr[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>()); <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>()); <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>()); <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>()); <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>这里我们使用了数组的内置 Symbol.iterator 方法。每次调用 next() 都会依次获取数组的下一个元素，直到所有元素遍历完成。</p><h2 id="三、手动实现一个简单的迭代器"><a href="#三、手动实现一个简单的迭代器" class="headerlink" title="三、手动实现一个简单的迭代器"></a>三、手动实现一个简单的迭代器</h2><p>我们现在尝试手动实现一个基本的迭代器。目标是实现一个能遍历数组的自定义迭代器。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createArrayIterator</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (index &lt; arr.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">value</span>: arr[index++], <span class="attr">done</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> iterator = <span class="title function_">createArrayIterator</span>([<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>]);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>()); <span class="comment">// &#123; value: 10, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>()); <span class="comment">// &#123; value: 20, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>()); <span class="comment">// &#123; value: 30, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>()); <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><p><strong>代码说明：</strong></p><ol><li>createArrayIterator 函数接收一个数组作为参数。</li><li>每次调用 next()，都会返回当前数组元素并将索引前进一位。</li><li>当数组遍历完成后，返回 { value: undefined, done: true }。</li></ol><h2 id="四、为对象添加迭代器"><a href="#四、为对象添加迭代器" class="headerlink" title="四、为对象添加迭代器"></a>四、为对象添加迭代器</h2><p>我们可以通过 Symbol.iterator 为任何对象定义自定义的迭代逻辑。这样，我们的对象也能在 for…of 循环中使用。下面，我们为一个自定义对象实现迭代器。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> range = &#123;</span><br><span class="line">  <span class="attr">start</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">end</span>: <span class="number">5</span>,</span><br><span class="line">  </span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">    <span class="keyword">let</span> current = <span class="variable language_">this</span>.<span class="property">start</span>;</span><br><span class="line">    <span class="keyword">const</span> end = <span class="variable language_">this</span>.<span class="property">end</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current &lt;= end) &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123; <span class="attr">value</span>: current++, <span class="attr">done</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123; <span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> num <span class="keyword">of</span> range) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(num); <span class="comment">// 输出 1 2 3 4 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码说明：</strong></p><ol><li>range 对象表示一个范围，从 start 到 end。</li><li>在对象内部使用 Symbol.iterator 定义了一个迭代器。</li><li>for…of 会自动调用对象的 <a href>Symbol.iterator</a> 方法来获取迭代器。</li></ol><h2 id="五、实现无限迭代器"><a href="#五、实现无限迭代器" class="headerlink" title="五、实现无限迭代器"></a>五、实现无限迭代器</h2><p>有时候，我们需要创建一个无限序列，比如生成斐波那契数列。下面是一个无限斐波那契迭代器的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fibonacciIterator</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> [prev, curr] = [<span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">      [prev, curr] = [curr, prev + curr];</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">value</span>: prev, <span class="attr">done</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fib = <span class="title function_">fibonacciIterator</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fib.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fib.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fib.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fib.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fib.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// 5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fib.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// 8</span></span><br></pre></td></tr></table></figure><p><strong>代码说明：</strong></p><ul><li>每次调用 next()，斐波那契序列都会前进一位，并返回当前的值。</li><li>无限序列的迭代器没有终止条件，因此 done 始终为 false。</li></ul><h2 id="六、可迭代对象与迭代器的区别"><a href="#六、可迭代对象与迭代器的区别" class="headerlink" title="六、可迭代对象与迭代器的区别"></a>六、可迭代对象与迭代器的区别</h2><ol><li>可迭代对象：具有 <a href>Symbol.iterator</a> 方法的对象，可以在 for…of 中使用，如数组、字符串等。</li><li>迭代器：实现了 next() 方法的对象，每次调用 next() 返回一个 { value, done } 对象。</li></ol><p><strong>总结：</strong> 可迭代对象内部使用迭代器来实现元素的逐个访问。for…of 只是对迭代器的一种封装。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在 JavaScript 中，迭代器是一个非常强大的工具。它允许我们逐步遍历集合中的元素，如数组、字符串、Map 等。然而，除了使用内置的迭代器（如 for…of、Array.prototype.entries() 等），我们还可以手动实现自己的迭代器来满足特殊需求。今天我</summary>
      
    
    
    
    <category term="未分类" scheme="https://www.laoliang.ink/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
    
    <category term="无标签" scheme="https://www.laoliang.ink/tags/%E6%97%A0%E6%A0%87%E7%AD%BE/"/>
    
  </entry>
  
  <entry>
    <title>基于 axios 手写文件上传，实现进度监听、上传中断</title>
    <link href="https://www.laoliang.ink/posts/20220512221823/"/>
    <id>https://www.laoliang.ink/posts/20220512221823/</id>
    <published>2022-05-12T14:18:23.000Z</published>
    <updated>2024-11-16T11:26:50.329Z</updated>
    
    <content type="html"><![CDATA[<p>要基于 axios 手写一个文件上传组件，并实现以下功能：</p><ol><li>选择文件并上传</li><li>监听上传进度</li><li>支持上传中断（取消请求）</li><li>处理成功和失败的回调</li></ol><p>下面是一个完整的实现代码示例：</p><h2 id="1-安装依赖"><a href="#1-安装依赖" class="headerlink" title="1. 安装依赖"></a>1. 安装依赖</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install axios</span><br></pre></td></tr></table></figure><h2 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2. 代码实现"></a>2. 代码实现</h2><p><strong>HTML 模板示例：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">id</span>=<span class="string">&quot;fileInput&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;uploadButton&quot;</span>&gt;</span>上传<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;cancelButton&quot;</span>&gt;</span>取消上传<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;progress&quot;</span>&gt;</span>上传进度: 0%<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>JavaScript 代码实现：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cancelTokenSource = <span class="literal">null</span>; <span class="comment">// 用于取消上传</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听文件选择并上传</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;uploadButton&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> fileInput = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;fileInput&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span> (fileInput.<span class="property">files</span>.<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;请选择文件&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> file = fileInput.<span class="property">files</span>[<span class="number">0</span>];</span><br><span class="line">  <span class="title function_">uploadFile</span>(file);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消上传</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;cancelButton&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (cancelTokenSource) &#123;</span><br><span class="line">    cancelTokenSource.<span class="title function_">cancel</span>(<span class="string">&#x27;上传已取消&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件上传逻辑</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">uploadFile</span>(<span class="params">file</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> url = <span class="string">&#x27;https://your-upload-endpoint.com/upload&#x27;</span>; <span class="comment">// 替换为实际上传地址</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建 Axios 的取消令牌</span></span><br><span class="line">  cancelTokenSource = axios.<span class="property">CancelToken</span>.<span class="title function_">source</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建表单数据</span></span><br><span class="line">  <span class="keyword">const</span> formData = <span class="keyword">new</span> <span class="title class_">FormData</span>();</span><br><span class="line">  formData.<span class="title function_">append</span>(<span class="string">&#x27;file&#x27;</span>, file);</span><br><span class="line"></span><br><span class="line">  axios.<span class="title function_">post</span>(url, formData, &#123;</span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;multipart/form-data&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">cancelToken</span>: cancelTokenSource.<span class="property">token</span>,</span><br><span class="line">    <span class="attr">onUploadProgress</span>: <span class="function">(<span class="params">progressEvent</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> percentCompleted = <span class="title class_">Math</span>.<span class="title function_">round</span>(</span><br><span class="line">        (progressEvent.<span class="property">loaded</span> * <span class="number">100</span>) / progressEvent.<span class="property">total</span></span><br><span class="line">      );</span><br><span class="line">      <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;progress&#x27;</span>).<span class="property">innerText</span> = <span class="string">`上传进度: <span class="subst">$&#123;percentCompleted&#125;</span>%`</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;上传成功&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">data</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (axios.<span class="title function_">isCancel</span>(error)) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;上传被取消:&#x27;</span>, error.<span class="property">message</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;上传失败:&#x27;</span>, error);</span><br><span class="line">      <span class="title function_">alert</span>(<span class="string">&#x27;上传失败&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-代码说明"><a href="#3-代码说明" class="headerlink" title="3. 代码说明"></a>3. 代码说明</h2><ul><li>选择文件并上传：用户点击上传按钮时，调用 uploadFile 函数，将文件上传到指定的服务器端。</li><li>监听上传进度：使用 onUploadProgress 回调函数来实时更新进度。</li><li>支持上传中断：使用 axios.CancelToken 创建可取消的请求，并在用户点击“取消上传”按钮时触发中断。</li><li>处理错误：区分普通错误和用户主动取消上传的情况。</li></ul><h2 id="4-效果预览"><a href="#4-效果预览" class="headerlink" title="4. 效果预览"></a>4. 效果预览</h2><ul><li>进度监听：上传时，页面上会实时显示百分比。</li><li>取消上传：上传过程中的任何时间都可以中断请求。</li></ul><h2 id="5-服务器端（可选参考）"><a href="#5-服务器端（可选参考）" class="headerlink" title="5. 服务器端（可选参考）"></a>5. 服务器端（可选参考）</h2><p>后端需要支持接收 multipart/form-data 请求。如果你使用的是 Node.js，可以用 express 搭配 multer 处理文件上传。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> multer = <span class="built_in">require</span>(<span class="string">&#x27;multer&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> upload = <span class="title function_">multer</span>(&#123; <span class="attr">dest</span>: <span class="string">&#x27;uploads/&#x27;</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">post</span>(<span class="string">&#x27;/upload&#x27;</span>, upload.<span class="title function_">single</span>(<span class="string">&#x27;file&#x27;</span>), <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;文件信息:&#x27;</span>, req.<span class="property">file</span>);</span><br><span class="line">  res.<span class="title function_">send</span>(&#123; <span class="attr">status</span>: <span class="string">&#x27;上传成功&#x27;</span> &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;服务器启动在 http://localhost:3000&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这个组件实现了完整的文件上传流程，你还可以根据需要进一步定制，比如支持多个文件、添加更多的上传校验等。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;要基于 axios 手写一个文件上传组件，并实现以下功能：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;选择文件并上传&lt;/li&gt;
&lt;li&gt;监听上传进度&lt;/li&gt;
&lt;li&gt;支持上传中断（取消请求）&lt;/li&gt;
&lt;li&gt;处理成功和失败的回调&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面是一个完整的实现代码示例</summary>
      
    
    
    
    <category term="未分类" scheme="https://www.laoliang.ink/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
    
    <category term="无标签" scheme="https://www.laoliang.ink/tags/%E6%97%A0%E6%A0%87%E7%AD%BE/"/>
    
  </entry>
  
  <entry>
    <title>在 PowerShell 中使用 Git</title>
    <link href="https://www.laoliang.ink/posts/20220422181821/"/>
    <id>https://www.laoliang.ink/posts/20220422181821/</id>
    <published>2022-04-22T10:18:21.000Z</published>
    <updated>2024-11-16T11:26:50.328Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 macOS 下 git 命令行工具默认有着很好的 tab 补全功能，而在 Windows 下通过 exe 安装的 git 程序，看起来就有些简陋。</p><p>其自带的 Unix Shell 环境模拟窗口 Git Bash，有着丑陋的外观，即便可以通过配置字体、颜色等手段稍加改善，但其一会儿类 Unix 工具链环境的反馈，一会儿 Windows cmd 工具链混搭的集成环境，着实容易让人精神分裂。</p><p>为了更好的自始至终统一使用体验，我们通常会将 git 程序添加到 全局 path 中（引导安装程序即可选配），然后在 cmd 或 PowerShell（通常是功能更强大的 PowerShell）中调用 git。</p><p>然而在 PowerShell 中调用 git 时，我们丧失了 tab 补全功能。</p><p>这里，我们介绍使用 <a href="https://github.com/dahlbyk/posh-git">Posh-Git</a> 这个扩展包，从而在 PowerShell 中应用 git 的 tab 补全。</p><h2 id="安装-Post-Git"><a href="#安装-Post-Git" class="headerlink" title="安装 Post-Git"></a>安装 Post-Git</h2><h3 id="配置脚本执行权限"><a href="#配置脚本执行权限" class="headerlink" title="配置脚本执行权限"></a>配置脚本执行权限</h3><p>在可以运行 PowerShell 脚本之前，你需要将本地的 ExecutionPolicy 设置为 RemoteSigned</p><p>在 PowerShell 中执行下面的命令，更精细化的配置参见 <a href="https://learn.microsoft.com/zh-cn/powershell/module/microsoft.powershell.security/set-executionpolicy?view=powershell-7.2">微软文档 Set-ExecutionPolicy</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope LocalMachine</span><br></pre></td></tr></table></figure><h3 id="使用包管理器安装-posh-git"><a href="#使用包管理器安装-posh-git" class="headerlink" title="使用包管理器安装 posh-git"></a>使用包管理器安装 posh-git</h3><p>在 PowerShell 中执行下面的命令，通过包管理器来安装 posh-git</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Install-Module posh-git -Scope CurrentUser -Force</span><br><span class="line">Install-Module posh-git -Scope CurrentUser -AllowPrerelease -Force # 带有 PowerShell Core 支持的更新的 beta 版</span><br></pre></td></tr></table></figure><p>如果你想为所有的用户安装 posh-git，请使用 <code>-Scope AllUsers</code> 并在管理员权限启动的 PowerShell 控制台中执行。</p><h3 id="更新-PowerShell-提示符"><a href="#更新-PowerShell-提示符" class="headerlink" title="更新 PowerShell 提示符"></a>更新 PowerShell 提示符</h3><p>要在你的提示符中包含 Git 信息，那么需要导入 Posh-Git 模块。 要让 PowerShell 在每次启动时都导入 Posh-Git，请执行 <code>Add-PoshGitToProfile</code> 命令， 它会在你的 $profile 脚本中添加导入语句。此脚本会在每次打开新的 PowerShell 终端时执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Import-Module posh-git</span><br><span class="line">Add-PoshGitToProfile -AllHosts</span><br></pre></td></tr></table></figure><p>更多详细内容，参见：<a href="https://git-scm.com/book/zh/v2/%E9%99%84%E5%BD%95-A%3A-%E5%9C%A8%E5%85%B6%E5%AE%83%E7%8E%AF%E5%A2%83%E4%B8%AD%E4%BD%BF%E7%94%A8-Git-Git-%E5%9C%A8-PowerShell-%E4%B8%AD%E4%BD%BF%E7%94%A8-Git">Git 文档：A1.9 附录 A: 在其它环境中使用 Git - Git 在 PowerShell 中使用 Git</a></p><h2 id="自定义-posh-git-提示符"><a href="#自定义-posh-git-提示符" class="headerlink" title="自定义 posh-git 提示符"></a>自定义 posh-git 提示符</h2><p>当您导入 posh-git 模块时，它将用新的提示功能替换 PowerShell 的默认提示功能。当当前目录位于 Git 存储库中时，posh-git 提示功能将显示 Git 状态摘要信息。如果 posh-git 检测到您有自己的自定义提示功能，则不会替换提示功能。</p><p>这里可以通过编辑当前用户 ps1 文件，实现自定义提示符：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$Profile</span></span><br></pre></td></tr></table></figure><p>得到形如下方的绝对路径，表示当前用户 ps1 配置文件默认加载位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\liang\Documents\WindowsPowerShell\Microsoft.PowerShell_profile.ps1</span><br></pre></td></tr></table></figure><p>打开并编辑这个文件，加入下面的内容：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$GitPromptSettings</span>.DefaultPromptPrefix.Text = <span class="string">&#x27;PS [$(Get-Date -f &quot;HH:mm:ss&quot;)] &#x27;</span></span><br><span class="line"><span class="variable">$GitPromptSettings</span>.DefaultPromptPrefix.ForegroundColor = [ConsoleColor]::Magenta</span><br><span class="line"><span class="variable">$GitPromptSettings</span>.DefaultPromptAbbreviateHomeDirectory = <span class="variable">$true</span></span><br><span class="line"><span class="variable">$GitPromptSettings</span>.BeforePath = <span class="string">&#x27;&#123;&#x27;</span></span><br><span class="line"><span class="variable">$GitPromptSettings</span>.AfterPath = <span class="string">&#x27;&#125;&#x27;</span></span><br><span class="line"><span class="variable">$GitPromptSettings</span>.DefaultPromptPath.ForegroundColor = 0xFFA500</span><br><span class="line"><span class="variable">$GitPromptSettings</span>.BeforePath.ForegroundColor = 0xFFA500</span><br><span class="line"><span class="variable">$GitPromptSettings</span>.AfterPath.ForegroundColor = 0xFFA500</span><br><span class="line"><span class="variable">$GitPromptSettings</span>.DefaultPromptBeforeSuffix.Text = <span class="string">&#x27;`n&#x27;</span></span><br></pre></td></tr></table></figure><p>你将获得一个同时拥有 时间、家目录缩写、git 状态的提示符，它会像下面这样：</p><p><img src="/posts/20220422181821/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8F%90%E7%A4%BA%E7%AC%A6.png" class="lazyload" data-srcset="/posts/20220422181821/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8F%90%E7%A4%BA%E7%AC%A6.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="自定义提示符"></p><p>更多详细内容，参见：<a href="https://github.com/dahlbyk/posh-git?tab=readme-ov-file#customizing-the-posh-git-prompt">GitHub - dahlbyk/posh-git - Customizing the posh-git prompt</a></p><h2 id="顺便说下中文乱码问题"><a href="#顺便说下中文乱码问题" class="headerlink" title="顺便说下中文乱码问题"></a>顺便说下中文乱码问题</h2><p>PowerShell 下 <code>git log</code> 中文、<code>git status</code> 文件名等，可能存在中文乱码的问题。</p><p>可以向下面一样配置 git：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.quotepath false</span><br><span class="line">git config --global gui.encoding utf-8</span><br><span class="line">git config --global i18n.commit.encoding utf-8</span><br><span class="line">git config --global i18n.logoutputencoding utf-8</span><br></pre></td></tr></table></figure><p>一劳永逸的方式：</p><p>系统设置 -&gt; 管理语言设置，打开旧版的区域设置窗口</p><p>更改系统区域设置 -&gt; Beta 版：使用 Unicode UTF-8 提供全球语言支持，勾选它，重启✅</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在 macOS 下 git 命令行工具默认有着很好的 tab 补全功能，而在 Windows 下通过 exe 安装的 git 程序，看起来就</summary>
      
    
    
    
    <category term="未分类" scheme="https://www.laoliang.ink/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
    
    <category term="无标签" scheme="https://www.laoliang.ink/tags/%E6%97%A0%E6%A0%87%E7%AD%BE/"/>
    
  </entry>
  
  <entry>
    <title>PowerShell 修改提示符的文字内容和样式</title>
    <link href="https://www.laoliang.ink/posts/20220422000813/"/>
    <id>https://www.laoliang.ink/posts/20220422000813/</id>
    <published>2022-04-21T16:08:13.000Z</published>
    <updated>2024-11-16T11:26:50.328Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>默认的 PowerShell 提示符丑？</p><p>其实我们可以通过编辑 PowerShell 的启动脚本，来自定义提示符的文字内容和样式</p><h3 id="配置脚本执行权限"><a href="#配置脚本执行权限" class="headerlink" title="配置脚本执行权限"></a>配置脚本执行权限</h3><p>在可以运行 PowerShell 脚本之前，你需要将本地的 ExecutionPolicy 设置为 RemoteSigned</p><p>在 PowerShell 中执行下面的命令，更精细化的配置参见 <a href="https://learn.microsoft.com/zh-cn/powershell/module/microsoft.powershell.security/set-executionpolicy?view=powershell-7.2">微软文档 Set-ExecutionPolicy</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope LocalMachine</span><br></pre></td></tr></table></figure><h2 id="查看当前用户-ps1-文件位置"><a href="#查看当前用户-ps1-文件位置" class="headerlink" title="查看当前用户 ps1 文件位置"></a>查看当前用户 ps1 文件位置</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $Profile</span><br></pre></td></tr></table></figure><p>得到形如下方的绝对路径，表示当前用户 ps1 配置文件默认加载位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\liang\Documents\WindowsPowerShell\Microsoft.PowerShell_profile.ps1</span><br></pre></td></tr></table></figure><h2 id="编辑-ps1-配置文件"><a href="#编辑-ps1-配置文件" class="headerlink" title="编辑 ps1 配置文件"></a>编辑 ps1 配置文件</h2><p>编辑这个 ps1 配置文件，可以改变 PowerShell 初始化时的一些行为</p><p>如果是第一次使用 PowerShell，这个文件可能不存在，需要我们手动创建</p><p>如果当前系统安装有 VScode，可以执行一下命令，快速创建或打开</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code $Profile</span><br></pre></td></tr></table></figure><p>下方是我的自定义配置文件内容，可以参考</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function prompt</span><br><span class="line">&#123;</span><br><span class="line">  Write-Host (&quot;`nPS [&quot;) -nonewline</span><br><span class="line">  Write-Host ($(get-date -Format &quot;HH:mm:ss&quot;)) -nonewline -foregroundcolor Red</span><br><span class="line">  Write-Host (&quot;] &#123;&quot;) -nonewline</span><br><span class="line">  Write-Host ($(pwd)) -nonewline -foregroundcolor Blue</span><br><span class="line">  Write-Host (&quot;&#125;&quot;)</span><br><span class="line">  return &quot;$ &quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使自定义配置文件生效"><a href="#使自定义配置文件生效" class="headerlink" title="使自定义配置文件生效"></a>使自定义配置文件生效</h2><p>一种方式是：</p><p>关闭并重新打开当前 PowerShell 会话，修改的配置文件效果便会生效</p><p>另一种即时生效的方式是：</p><p>执行重新加载命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">. $Profile</span><br></pre></td></tr></table></figure><h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><p><img src="/posts/20220422000813/PowerShell%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8F%90%E7%A4%BA%E7%AC%A6.png" class="lazyload" data-srcset="/posts/20220422000813/PowerShell%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8F%90%E7%A4%BA%E7%AC%A6.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="PowerShell自定义提示符"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;默认的 PowerShell 提示符丑？&lt;/p&gt;
&lt;p&gt;其实我们可以通过编辑 PowerShell 的启动脚本，来自定义提示符的文字内容和样</summary>
      
    
    
    
    <category term="未分类" scheme="https://www.laoliang.ink/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
    
    <category term="无标签" scheme="https://www.laoliang.ink/tags/%E6%97%A0%E6%A0%87%E7%AD%BE/"/>
    
  </entry>
  
  <entry>
    <title>如何封装一个 JavaScript 的轻量级事件总线（Event Bus）</title>
    <link href="https://www.laoliang.ink/posts/20220305202211/"/>
    <id>https://www.laoliang.ink/posts/20220305202211/</id>
    <published>2022-03-05T12:22:11.000Z</published>
    <updated>2024-11-16T11:26:50.328Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h2><p>在前端开发中，组件之间的通信是一项常见需求。虽然常用的库（如 Redux 或 Vuex）可以解决状态管理问题，但有时我们只需要一个简单的事件总线（Event Bus），来让组件之间交换事件，而不引入复杂的状态管理工具。</p><p>接下来我们将一步步实现一个轻量级 JavaScript 事件总线，并介绍其应用场景和最佳实践。</p><h2 id="2-什么是事件总线？"><a href="#2-什么是事件总线？" class="headerlink" title="2. 什么是事件总线？"></a>2. 什么是事件总线？</h2><p>事件总线是一种 发布-订阅模式（Publish-Subscribe）的实现。其核心思想是将事件的发布者和订阅者解耦，让它们无需直接相互依赖。事件总线扮演的是一个中央通道的角色，负责协调不同组件之间的事件通知。</p><h2 id="3-实现一个简单的事件总线"><a href="#3-实现一个简单的事件总线" class="headerlink" title="3. 实现一个简单的事件总线"></a>3. 实现一个简单的事件总线</h2><p>下面我们使用 JavaScript 的原生能力来封装一个简单易用的事件总线。</p><p>基础实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EventBus</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">events</span> = <span class="keyword">new</span> <span class="title class_">Map</span>(); <span class="comment">// 使用 Map 存储事件</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注册事件监听器</span></span><br><span class="line">  <span class="title function_">on</span>(<span class="params">eventName, listener</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">events</span>.<span class="title function_">has</span>(eventName)) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">events</span>.<span class="title function_">set</span>(eventName, []);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">events</span>.<span class="title function_">get</span>(eventName).<span class="title function_">push</span>(listener);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 触发事件</span></span><br><span class="line">  <span class="title function_">emit</span>(<span class="params">eventName, ...args</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">events</span>.<span class="title function_">has</span>(eventName)) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">events</span>.<span class="title function_">get</span>(eventName).<span class="title function_">forEach</span>(<span class="function"><span class="params">listener</span> =&gt;</span> <span class="title function_">listener</span>(...args));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取消注册事件监听器</span></span><br><span class="line">  <span class="title function_">off</span>(<span class="params">eventName, listener</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">events</span>.<span class="title function_">has</span>(eventName)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">const</span> listeners = <span class="variable language_">this</span>.<span class="property">events</span>.<span class="title function_">get</span>(eventName).<span class="title function_">filter</span>(<span class="function"><span class="params">fn</span> =&gt;</span> fn !== listener);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">events</span>.<span class="title function_">set</span>(eventName, listeners);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 清除所有事件监听器</span></span><br><span class="line">  <span class="title function_">clear</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">events</span>.<span class="title function_">clear</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出一个单例事件总线</span></span><br><span class="line"><span class="keyword">const</span> eventBus = <span class="keyword">new</span> <span class="title class_">EventBus</span>();</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> eventBus;</span><br></pre></td></tr></table></figure><h2 id="4-使用方法"><a href="#4-使用方法" class="headerlink" title="4. 使用方法"></a>4. 使用方法</h2><h3 id="4-1-注册事件监听器"><a href="#4-1-注册事件监听器" class="headerlink" title="4.1 注册事件监听器"></a>4.1 注册事件监听器</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> eventBus <span class="keyword">from</span> <span class="string">&#x27;./eventBus&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册一个事件监听器</span></span><br><span class="line">eventBus.<span class="title function_">on</span>(<span class="string">&#x27;userLoggedIn&#x27;</span>, <span class="function">(<span class="params">user</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`用户 <span class="subst">$&#123;user.name&#125;</span> 已登录`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="4-2-触发事件"><a href="#4-2-触发事件" class="headerlink" title="4.2 触发事件"></a>4.2 触发事件</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 触发 &#x27;userLoggedIn&#x27; 事件</span></span><br><span class="line">eventBus.<span class="title function_">emit</span>(<span class="string">&#x27;userLoggedIn&#x27;</span>, &#123; <span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span> &#125;);</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户 Alice 已登录</span><br></pre></td></tr></table></figure><h3 id="4-3-取消事件监听"><a href="#4-3-取消事件监听" class="headerlink" title="4.3 取消事件监听"></a>4.3 取消事件监听</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">onUserLoggedOut</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;用户已登出&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册并取消监听器</span></span><br><span class="line">eventBus.<span class="title function_">on</span>(<span class="string">&#x27;userLoggedOut&#x27;</span>, onUserLoggedOut);</span><br><span class="line">eventBus.<span class="title function_">off</span>(<span class="string">&#x27;userLoggedOut&#x27;</span>, onUserLoggedOut);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试触发（不会有任何输出）</span></span><br><span class="line">eventBus.<span class="title function_">emit</span>(<span class="string">&#x27;userLoggedOut&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="4-4-清除所有事件"><a href="#4-4-清除所有事件" class="headerlink" title="4.4 清除所有事件"></a>4.4 清除所有事件</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 清除所有事件监听器</span></span><br><span class="line">eventBus.<span class="title function_">clear</span>();</span><br></pre></td></tr></table></figure><h2 id="5-进阶功能：一次性监听（once）"><a href="#5-进阶功能：一次性监听（once）" class="headerlink" title="5. 进阶功能：一次性监听（once）"></a>5. 进阶功能：一次性监听（once）</h2><p>有时候，我们希望某个监听器只响应一次事件，这可以通过扩展 on 方法来实现。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EventBus</span> &#123;</span><br><span class="line">  <span class="comment">// 省略其他方法...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一次性监听事件</span></span><br><span class="line">  <span class="title function_">once</span>(<span class="params">eventName, listener</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">wrapper</span> = (<span class="params">...args</span>) =&gt; &#123;</span><br><span class="line">      <span class="title function_">listener</span>(...args);</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">off</span>(eventName, wrapper); <span class="comment">// 自动取消监听</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">on</span>(eventName, wrapper);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 once 监听事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">eventBus.<span class="title function_">once</span>(<span class="string">&#x27;dataLoaded&#x27;</span>, <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;数据已加载:&#x27;</span>, data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一次触发会响应</span></span><br><span class="line">eventBus.<span class="title function_">emit</span>(<span class="string">&#x27;dataLoaded&#x27;</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// 输出: 数据已加载: [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二次触发不会响应</span></span><br><span class="line">eventBus.<span class="title function_">emit</span>(<span class="string">&#x27;dataLoaded&#x27;</span>, [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]);</span><br></pre></td></tr></table></figure><h2 id="6-常见应用场景"><a href="#6-常见应用场景" class="headerlink" title="6. 常见应用场景"></a>6. 常见应用场景</h2><ul><li>组件通信：在 React、Vue 等框架中，实现兄弟组件或跨层级组件的通信。</li><li>全局状态管理：用于简易的全局事件通知，比如用户登录、登出事件。</li><li>异步事件处理：监听某些异步任务的状态变更，如网络请求完成或 WebSocket 消息接收。</li><li>解耦模块之间的依赖：减少模块之间的直接调用，提升代码的可维护性。</li></ul><h2 id="7-性能优化与注意事项"><a href="#7-性能优化与注意事项" class="headerlink" title="7. 性能优化与注意事项"></a>7. 性能优化与注意事项</h2><ul><li>内存泄漏：确保在组件销毁或不再需要事件时取消监听器，否则可能导致内存泄漏。</li><li>事件名规范：为事件命名时，建议使用命名空间风格，如 user:login，以防止事件名冲突。</li><li>频繁触发的事件：对于高频事件（如滚动或鼠标移动），可以结合 <strong>节流（throttle）或防抖（debounce）</strong> 来优化性能。</li></ul><h2 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. 总结</h2><p>通过本文的介绍，我们实现了一个简单且高效的事件总线，并展示了它在实际开发中的使用场景。相比于 Redux 等复杂的状态管理库，这种轻量级的事件总线能满足许多日常需求，尤其适用于中小型项目或临时状态共享的场景。</p><p>如果你有更多需求，比如需要持久化事件状态、事件队列等功能，可以在此基础上进一步扩展。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-引言&quot;&gt;&lt;a href=&quot;#1-引言&quot; class=&quot;headerlink&quot; title=&quot;1. 引言&quot;&gt;&lt;/a&gt;1. 引言&lt;/h2&gt;&lt;p&gt;在前端开发中，组件之间的通信是一项常见需求。虽然常用的库（如 Redux 或 Vuex）可以解决状态管理问题，但有时我们</summary>
      
    
    
    
    <category term="未分类" scheme="https://www.laoliang.ink/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
    
    <category term="无标签" scheme="https://www.laoliang.ink/tags/%E6%97%A0%E6%A0%87%E7%AD%BE/"/>
    
  </entry>
  
  <entry>
    <title>什么是微前端（Micro-Frontend）</title>
    <link href="https://www.laoliang.ink/posts/20220220222831/"/>
    <id>https://www.laoliang.ink/posts/20220220222831/</id>
    <published>2022-02-20T14:28:31.000Z</published>
    <updated>2024-11-16T11:26:50.328Z</updated>
    
    <content type="html"><![CDATA[<p>随着前端项目的复杂度不断提升，传统的单页应用（SPA）架构逐渐暴露出性能瓶颈和团队协作难题。为了解决这些问题，微前端（Micro-Frontend）应运而生。微前端是一种将大型前端应用拆分为多个可独立开发和部署的微型应用的架构理念。本文将介绍微前端的基本概念、核心思想、常见实现方式和优缺点，为你快速入门奠定基础。</p><h2 id="一、微前端的背景和由来"><a href="#一、微前端的背景和由来" class="headerlink" title="一、微前端的背景和由来"></a>一、微前端的背景和由来</h2><p>传统的前端开发以单页应用（SPA）为主流。随着业务复杂度增加，单一代码库会遇到以下问题：</p><ul><li>代码库庞大：单一应用的代码量庞大，构建速度变慢，调试和维护困难。</li><li>协作复杂：多团队协作时容易发生代码冲突，团队之间的开发周期互相依赖。</li><li>技术升级困难：某部分需要升级技术栈时可能影响整个项目。</li></ul><p>微前端借鉴了微服务架构的理念，通过将大型前端项目拆分为多个独立的小型应用来解决这些问题。</p><h2 id="二、什么是微前端？"><a href="#二、什么是微前端？" class="headerlink" title="二、什么是微前端？"></a>二、什么是微前端？</h2><p>微前端是一种将前端应用按功能模块划分为多个独立单元，每个单元称为微应用（Micro App）。这些微应用可以独立开发、测试和部署，但在用户看来，它们协同组成一个完整的网站。</p><p>核心思想：</p><ol><li>独立性：每个微应用可以独立开发、构建和部署，甚至可以采用不同的技术栈。</li><li>松耦合：微应用之间尽量减少依赖，保证彼此独立运行。</li><li>团队自治：不同团队可以负责不同的微应用，减少协作冲突。</li><li>渐进集成：支持逐步从传统应用迁移到微前端架构，避免一次性重构的高风险。</li></ol><h2 id="三、微前端的常见实现方式"><a href="#三、微前端的常见实现方式" class="headerlink" title="三、微前端的常见实现方式"></a>三、微前端的常见实现方式</h2><h3 id="1-基于-iframe-的方式"><a href="#1-基于-iframe-的方式" class="headerlink" title="1. 基于 iframe 的方式"></a>1. 基于 iframe 的方式</h3><ul><li>将不同的微应用嵌入到主应用的页面中。</li><li>优点：隔离性强，不同应用之间不会相互干扰。</li><li>缺点：iframe 的体验较差，SEO 和跨应用通信复杂。</li></ul><h3 id="2-基于路由的分割（主子应用架构）"><a href="#2-基于路由的分割（主子应用架构）" class="headerlink" title="2. 基于路由的分割（主子应用架构）"></a>2. 基于路由的分割（主子应用架构）</h3><ul><li>通过路由系统将不同的路径映射到不同的微应用上。</li><li>场景：用户访问 /dashboard 时加载微应用 A，访问 /profile 时加载微应用 B。</li><li>实现方式：采用 single-spa 等框架，实现多个微应用的动态加载。</li></ul><h3 id="3-模块联邦（Module-Federation）"><a href="#3-模块联邦（Module-Federation）" class="headerlink" title="3. 模块联邦（Module Federation）"></a>3. 模块联邦（Module Federation）</h3><ul><li>利用 Webpack 5 的模块联邦功能，实现微应用之间的模块共享。</li><li>优点：支持在运行时加载远程模块，实现不同应用之间的动态依赖。</li><li>缺点：需要复杂的构建配置和依赖管理。</li></ul><h2 id="四、微前端的优缺点"><a href="#四、微前端的优缺点" class="headerlink" title="四、微前端的优缺点"></a>四、微前端的优缺点</h2><p>优点</p><ul><li>技术栈无关：不同微应用可以使用不同的技术框架（React、Vue、Angular 等）。</li><li>独立部署：每个微应用可以单独更新、部署，减少对其他模块的影响。</li><li>提高协作效率：多个团队可以并行开发不同的微应用，减少代码冲突。</li><li>渐进迁移：支持逐步迁移和重构，降低系统升级风险。</li></ul><p>缺点</p><ul><li>复杂性增加：需要处理微应用之间的通信、状态共享和样式隔离等问题。</li><li>性能开销：加载多个微应用可能增加页面加载时间，需要优化资源管理。</li><li>构建配置繁琐：不同微应用的构建和集成需要复杂的工具链支持。</li></ul><h2 id="五、微前端的应用场景"><a href="#五、微前端的应用场景" class="headerlink" title="五、微前端的应用场景"></a>五、微前端的应用场景</h2><h3 id="1-大型企业级项目"><a href="#1-大型企业级项目" class="headerlink" title="1. 大型企业级项目"></a>1. 大型企业级项目</h3><ul><li>适合具有多个团队合作、业务模块复杂的大型企业项目，如电商平台或企业管理系统。</li></ul><h3 id="2-多品牌或多产品线网站"><a href="#2-多品牌或多产品线网站" class="headerlink" title="2. 多品牌或多产品线网站"></a>2. 多品牌或多产品线网站</h3><ul><li>当一个网站需要支持多个品牌或产品线时，每个品牌可以作为一个独立的微应用。</li></ul><h3 id="3-渐进式重构"><a href="#3-渐进式重构" class="headerlink" title="3. 渐进式重构"></a>3. 渐进式重构</h3><ul><li>在原有单页应用基础上，通过逐步拆分为微应用实现系统的渐进重构。</li></ul><h2 id="六、微前端的框架与工具"><a href="#六、微前端的框架与工具" class="headerlink" title="六、微前端的框架与工具"></a>六、微前端的框架与工具</h2><ul><li>single-spa：一个流行的微前端框架，支持多框架共存和微应用集成。</li><li>qiankun：基于 single-spa 的增强版，适用于企业级应用。</li><li>Webpack Module Federation：用于实现运行时模块共享的强大工具。</li><li>Pirate Ship：一款实验性的微前端开发工具，专注于快速集成。</li></ul><h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>微前端是一种有效解决大型前端项目复杂性和团队协作问题的架构理念。通过将应用拆分为多个独立的微应用，团队可以提高开发效率，并减少部署和升级的风险。然而，微前端也带来了更多的复杂性，需要开发者在应用设计、工具链选择和性能优化上进行合理规划。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;随着前端项目的复杂度不断提升，传统的单页应用（SPA）架构逐渐暴露出性能瓶颈和团队协作难题。为了解决这些问题，微前端（Micro-Frontend）应运而生。微前端是一种将大型前端应用拆分为多个可独立开发和部署的微型应用的架构理念。本文将介绍微前端的基本概念、核心思想、常见</summary>
      
    
    
    
    <category term="未分类" scheme="https://www.laoliang.ink/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
    
    <category term="无标签" scheme="https://www.laoliang.ink/tags/%E6%97%A0%E6%A0%87%E7%AD%BE/"/>
    
  </entry>
  
  <entry>
    <title>详解防抖与节流</title>
    <link href="https://www.laoliang.ink/posts/20211120211545/"/>
    <id>https://www.laoliang.ink/posts/20211120211545/</id>
    <published>2021-11-20T13:15:45.000Z</published>
    <updated>2024-11-16T11:26:50.328Z</updated>
    
    <content type="html"><![CDATA[<p>在前端开发中，<strong>防抖（Debounce）和节流（Throttle）</strong>是两个优化频繁操作的常用技巧。它们主要用于减少高频率触发的事件处理次数，提升性能。本文将由浅入深地介绍这两者的原理、实现方式及应用场景，并比较它们的异同。</p><h2 id="一、为什么需要防抖与节流？"><a href="#一、为什么需要防抖与节流？" class="headerlink" title="一、为什么需要防抖与节流？"></a>一、为什么需要防抖与节流？</h2><p>在浏览器中，有一些事件会频繁触发，比如：</p><ul><li>窗口 resize、scroll 事件：用户移动滚轮或拖拽窗口时会连续触发。</li><li>输入框 keyup 事件：用户快速输入内容时会在每次按键后触发。</li></ul><p>如果这些事件都直接绑定了处理函数，可能会触发大量不必要的计算，导致页面卡顿或响应迟缓。</p><p>防抖和节流应运而生，帮助我们控制事件触发频率，避免性能瓶颈。</p><h2 id="二、防抖（Debounce）"><a href="#二、防抖（Debounce）" class="headerlink" title="二、防抖（Debounce）"></a>二、防抖（Debounce）</h2><h3 id="1-防抖的定义"><a href="#1-防抖的定义" class="headerlink" title="1. 防抖的定义"></a>1. 防抖的定义</h3><p>防抖的核心是多次触发同一事件时，只执行最后一次。即：事件被触发后，只有在指定时间内没有再次触发，处理函数才会执行。如果事件在等待时间内又触发了，则重新计时。</p><h3 id="2-防抖的实现"><a href="#2-防抖的实现" class="headerlink" title="2. 防抖的实现"></a>2. 防抖的实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">func, delay</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timeout;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timeout);  <span class="comment">// 每次触发时清除之前的计时器</span></span><br><span class="line">    timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      func.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);  <span class="comment">// 最后一次触发后执行</span></span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-应用场景"><a href="#3-应用场景" class="headerlink" title="3. 应用场景"></a>3. 应用场景</h3><ul><li>搜索框：用户输入时避免每次按键都发送请求，只有停止输入一段时间后再进行搜索。</li><li>窗口调整：防止频繁 resize 事件导致页面频繁重绘。</li></ul><h2 id="三、节流（Throttle）"><a href="#三、节流（Throttle）" class="headerlink" title="三、节流（Throttle）"></a>三、节流（Throttle）</h2><h3 id="1-节流的定义"><a href="#1-节流的定义" class="headerlink" title="1. 节流的定义"></a>1. 节流的定义</h3><p>节流的核心是规定在单位时间内只能执行一次，即使在这段时间内事件被多次触发，处理函数也只会按规定间隔执行。</p><h3 id="2-节流的实现"><a href="#2-节流的实现" class="headerlink" title="2. 节流的实现"></a>2. 节流的实现</h3><p>时间戳版</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">func, interval</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> lastTime = <span class="number">0</span>;  </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> now = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">    <span class="keyword">if</span> (now - lastTime &gt;= interval) &#123;</span><br><span class="line">      lastTime = now;</span><br><span class="line">      func.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定时器版</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">func, interval</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timeout;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!timeout) &#123;</span><br><span class="line">      timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        timeout = <span class="literal">null</span>;</span><br><span class="line">        func.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">      &#125;, interval);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-应用场景-1"><a href="#3-应用场景-1" class="headerlink" title="3. 应用场景"></a>3. 应用场景</h3><ul><li>   页面滚动事件：滚动过程中每隔一段时间触发一次，而非每像素移动都触发。</li><li>   按钮防重复点击：避免用户频繁点击按钮导致多次触发请求。</li></ul><h2 id="四、防抖与节流的区别"><a href="#四、防抖与节流的区别" class="headerlink" title="四、防抖与节流的区别"></a>四、防抖与节流的区别</h2><table><thead><tr><th align="center">特性</th><th align="center">防抖(Debounce)</th><th align="center">节流(Throttle)</th></tr></thead><tbody><tr><td align="center">触发方式</td><td align="center">多次触发后只执行最后一次</td><td align="center">每隔固定间隔执行一次</td></tr><tr><td align="center">适合场景</td><td align="center">用户停止频繁操作后执行处理逻辑</td><td align="center">持续执行过程中限制调用频率</td></tr><tr><td align="center">实现方式</td><td align="center">基于计时器</td><td align="center">基于时间戳或定时器</td></tr><tr><td align="center">效果</td><td align="center">避免短时间内的频繁触发</td><td align="center">限制高频操作的处理次数</td></tr></tbody></table><h2 id="五、如何选择？"><a href="#五、如何选择？" class="headerlink" title="五、如何选择？"></a>五、如何选择？</h2><ol><li>用户停止操作后需要进行处理：选用防抖。例如搜索框输入、防止多次提交表单。</li><li>限制操作频率：选用节流。例如页面滚动、窗口大小调整等需要频繁触发的事件。</li></ol><h2 id="六、结合防抖与节流"><a href="#六、结合防抖与节流" class="headerlink" title="六、结合防抖与节流"></a>六、结合防抖与节流</h2><p>在某些复杂场景中，可能需要结合防抖和节流的特点。<br>举例：在页面滚动时进行懒加载时，我们希望：</p><ul><li>滚动时限频触发（节流），减少性能消耗；</li><li>停止滚动后立即处理剩余任务（防抖），确保用户停下后能立刻看到内容。</li></ul><p>可以使用如下方式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounceThrottle</span>(<span class="params">func, delay, interval</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> lastTime = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> timeout;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> now = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (now - lastTime &gt;= interval) &#123;</span><br><span class="line">      lastTime = now;</span><br><span class="line">      func.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">      timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        lastTime = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">        func.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">      &#125;, delay);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>七、总结</p><p>防抖和节流是前端开发中的重要性能优化手段，能有效减少不必要的事件处理。防抖适用于停止操作后的处理逻辑，节流适用于持续操作的限频处理。理解两者的异同与应用场景，能帮助我们编写更加高效的代码。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在前端开发中，&lt;strong&gt;防抖（Debounce）和节流（Throttle）&lt;/strong&gt;是两个优化频繁操作的常用技巧。它们主要用于减少高频率触发的事件处理次数，提升性能。本文将由浅入深地介绍这两者的原理、实现方式及应用场景，并比较它们的异同。&lt;/p&gt;
&lt;h2 id</summary>
      
    
    
    
    <category term="未分类" scheme="https://www.laoliang.ink/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
    
    <category term="无标签" scheme="https://www.laoliang.ink/tags/%E6%97%A0%E6%A0%87%E7%AD%BE/"/>
    
  </entry>
  
  <entry>
    <title>宏任务、微任务，以及 Vue.js 中的 nextTick</title>
    <link href="https://www.laoliang.ink/posts/20211116193512/"/>
    <id>https://www.laoliang.ink/posts/20211116193512/</id>
    <published>2021-11-16T11:35:12.000Z</published>
    <updated>2024-11-16T11:26:50.327Z</updated>
    
    <content type="html"><![CDATA[<p>在 JavaScript 的异步机制中，“宏任务”（Macro Task）和“微任务”（Micro Task）扮演着非常重要的角色。特别是当我们使用 Vue 2 或 Vue 3 进行前端开发时，nextTick 这个 API 与它们密切相关。本文将由浅入深，带你理解它们的区别，以及 nextTick 在 Vue 中的应用。</p><h2 id="一、宏任务与微任务：事件循环的基础"><a href="#一、宏任务与微任务：事件循环的基础" class="headerlink" title="一、宏任务与微任务：事件循环的基础"></a>一、宏任务与微任务：事件循环的基础</h2><h3 id="1-1-什么是事件循环（Event-Loop）？"><a href="#1-1-什么是事件循环（Event-Loop）？" class="headerlink" title="1.1 什么是事件循环（Event Loop）？"></a>1.1 什么是事件循环（Event Loop）？</h3><p>JavaScript 是一种单线程的语言，意味着同一时间只能执行一段代码。为了解决阻塞问题，JavaScript 引入了事件循环机制，允许任务异步执行。事件循环的主要逻辑是：</p><ol><li>从任务队列中取出一个任务并执行（主线程）。</li><li>如果任务内部产生异步操作（如定时器、Promise），这些任务会被放入不同队列。</li><li>等到当前执行栈为空时，再根据优先级处理这些任务。</li></ol><h3 id="1-2-宏任务-vs-微任务"><a href="#1-2-宏任务-vs-微任务" class="headerlink" title="1.2 宏任务 vs. 微任务"></a>1.2 宏任务 vs. 微任务</h3><p>在事件循环中，任务分为宏任务和微任务两类：</p><p>常见的宏任务（Macro Task）包括：</p><ul><li>setTimeout、setInterval</li><li>DOM 渲染任务</li><li>用户交互事件（如点击、输入）</li></ul><p>宏任务会先进入“任务队列”，等待前面的所有任务执行完毕后，才会进入主线程执行。</p><p>微任务（Micro Task）主要包括：</p><ul><li>Promise.then、queueMicrotask</li><li>MutationObserver（监听 DOM 变化）</li></ul><p>微任务的优先级高于宏任务，在当前宏任务执行完之后，会立刻执行微任务队列中的任务。</p><p>顺序总结：</p><ol><li>一个宏任务执行完毕后，检查所有的微任务并执行它们。</li><li>微任务执行完毕后，事件循环再去执行下一个宏任务。</li></ol><h3 id="1-3-宏任务与微任务的简单示例"><a href="#1-3-宏任务与微任务的简单示例" class="headerlink" title="1.3 宏任务与微任务的简单示例"></a>1.3 宏任务与微任务的简单示例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script start&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;macro task - setTimeout&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;micro task - Promise&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script end&#x27;</span>);</span><br></pre></td></tr></table></figure><p>输出顺序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">script start</span><br><span class="line">script end</span><br><span class="line">micro task - Promise</span><br><span class="line">macro task - setTimeout</span><br></pre></td></tr></table></figure><p>解释：</p><ol><li>console.log(‘script start’) 和 console.log(‘script end’) 属于主线程中的同步任务，按顺序执行。</li><li>setTimeout 的回调是宏任务，放入宏任务队列中。</li><li>Promise.then 是微任务，会在当前宏任务结束后立即执行。</li><li>最后，setTimeout 的回调才会执行。</li></ol><h2 id="二、nextTick-在-Vue-2-和-Vue-3-中的作用"><a href="#二、nextTick-在-Vue-2-和-Vue-3-中的作用" class="headerlink" title="二、nextTick 在 Vue 2 和 Vue 3 中的作用"></a>二、nextTick 在 Vue 2 和 Vue 3 中的作用</h2><p>在 Vue 中，我们经常遇到这样的场景：修改数据后，DOM 并未立刻更新。这是因为 Vue 的响应式更新是异步的。为优化性能，Vue 会在本次事件循环结束后，统一执行所有的 DOM 更新任务。此时，nextTick 就派上了用场。</p><h3 id="2-1-Vue-的异步-DOM-更新"><a href="#2-1-Vue-的异步-DOM-更新" class="headerlink" title="2.1 Vue 的异步 DOM 更新"></a>2.1 Vue 的异步 DOM 更新</h3><p>Vue 会把数据变更后的 DOM 更新任务放入微任务队列中，而不是立即更新。假设我们在修改数据后立即访问 DOM，会发现 DOM 还没有反应过来。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">count</span> = <span class="number">1</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">counter</span>.<span class="property">innerText</span>); <span class="comment">// 可能还是 0</span></span><br></pre></td></tr></table></figure><p>要确保获取到最新的 DOM，需要等待下一次 DOM 更新完成。Vue 提供了 this.$nextTick 来解决这个问题。</p><h2 id="三、Vue-2-和-Vue-3-中的-nextTick-使用"><a href="#三、Vue-2-和-Vue-3-中的-nextTick-使用" class="headerlink" title="三、Vue 2 和 Vue 3 中的 nextTick 使用"></a>三、Vue 2 和 Vue 3 中的 nextTick 使用</h2><h3 id="3-1-Vue-2-的-nextTick"><a href="#3-1-Vue-2-的-nextTick" class="headerlink" title="3.1 Vue 2 的 nextTick"></a>3.1 Vue 2 的 nextTick</h3><p>在 Vue 2 中，this.$nextTick 是一个实例方法，用于等待 DOM 更新完成后执行回调：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">count</span> = <span class="number">1</span>;</span><br><span class="line"><span class="variable language_">this</span>.$nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">counter</span>.<span class="property">innerText</span>); <span class="comment">// 1</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果你需要确保多个数据变更后统一操作 DOM，可以将所有逻辑放在 nextTick 回调中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">count</span> = <span class="number">1</span>;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">msg</span> = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line"><span class="variable language_">this</span>.$nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">counter</span>.<span class="property">innerText</span>); <span class="comment">// 1</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">message</span>.<span class="property">innerText</span>); <span class="comment">// Hello</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="3-2-Vue-3-的-nextTick"><a href="#3-2-Vue-3-的-nextTick" class="headerlink" title="3.2 Vue 3 的 nextTick"></a>3.2 Vue 3 的 nextTick</h3><p>在 Vue 3 中，nextTick 变成了一个顶层导出的函数，不再需要通过实例调用。使用方法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; nextTick &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"></span><br><span class="line">count.<span class="property">value</span> = <span class="number">1</span>;</span><br><span class="line"><span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(counterRef.<span class="property">value</span>.<span class="property">innerText</span>); <span class="comment">// 1</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Vue 3 的 nextTick 在 Composition API 中的使用更加灵活，因为你可以在任何地方调用它，而不需要依赖组件实例。</p><h2 id="四、nextTick-底层原理分析"><a href="#四、nextTick-底层原理分析" class="headerlink" title="四、nextTick 底层原理分析"></a>四、nextTick 底层原理分析</h2><h3 id="4-1-nextTick-的实现：微任务的运用"><a href="#4-1-nextTick-的实现：微任务的运用" class="headerlink" title="4.1 nextTick 的实现：微任务的运用"></a>4.1 nextTick 的实现：微任务的运用</h3><p>Vue 的 nextTick 内部实现非常巧妙，它利用了微任务机制（Promise 或 MutationObserver）来确保回调函数在 DOM 更新后执行。</p><p>Vue 2 的实现简要代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">nextTick</span>(<span class="params">cb</span>) &#123;</span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(cb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Vue 3 的实现会更加复杂：</p><p>Vue 3 内部根据环境决定使用何种微任务，比如优先使用 queueMicrotask，在不支持的环境下降级为 Promise。</p><h3 id="4-2-为什么不直接使用-setTimeout？"><a href="#4-2-为什么不直接使用-setTimeout？" class="headerlink" title="4.2 为什么不直接使用 setTimeout？"></a>4.2 为什么不直接使用 setTimeout？</h3><p>虽然 setTimeout 也可以异步执行任务，但它是宏任务，会导致回调的执行延迟。Vue 选择使用微任务（如 Promise），确保在本轮事件循环内尽快更新 DOM。</p><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><ul><li>宏任务和微任务是 JavaScript 异步机制中的重要概念。微任务优先于宏任务执行。</li><li>Vue 的响应式更新是异步的，为了性能优化，Vue 会将多次数据更新合并到一个微任务中执行。</li><li>nextTick 是 Vue 中用于确保 DOM 更新完成后执行回调的工具。在 Vue 2 中，它是实例方法，而在 Vue 3 中，它变成了顶层导出的函数。</li></ul><p>了解了宏任务、微任务和 nextTick 后，你就能更好地掌握 Vue 的异步更新机制，写出更高效的代码！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在 JavaScript 的异步机制中，“宏任务”（Macro Task）和“微任务”（Micro Task）扮演着非常重要的角色。特别是当我们使用 Vue 2 或 Vue 3 进行前端开发时，nextTick 这个 API 与它们密切相关。本文将由浅入深，带你理解它们的区</summary>
      
    
    
    
    <category term="未分类" scheme="https://www.laoliang.ink/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
    
    <category term="无标签" scheme="https://www.laoliang.ink/tags/%E6%97%A0%E6%A0%87%E7%AD%BE/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 支持哪些模块加载方式</title>
    <link href="https://www.laoliang.ink/posts/20211028211629/"/>
    <id>https://www.laoliang.ink/posts/20211028211629/</id>
    <published>2021-10-28T13:16:29.000Z</published>
    <updated>2024-11-16T11:26:50.327Z</updated>
    
    <content type="html"><![CDATA[<p>在 JavaScript 中，导入模块的方式根据使用的模块规范（如 CommonJS、ESM 等）有所不同。下面介绍几种常见的导入方式：</p><h2 id="1-CommonJS-模块导入"><a href="#1-CommonJS-模块导入" class="headerlink" title="1. CommonJS 模块导入"></a>1. CommonJS 模块导入</h2><ul><li>用于 Node.js 环境（也可以在支持的工具中使用，如 Webpack）。</li><li>语法：require</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>); <span class="comment">// 导入 Node 内置模块</span></span><br><span class="line"><span class="keyword">const</span> myModule = <span class="built_in">require</span>(<span class="string">&#x27;./myModule&#x27;</span>); <span class="comment">// 导入本地模块</span></span><br></pre></td></tr></table></figure><ul><li>特性：<ul><li>模块导入是同步的。</li><li>   常用于老版本项目和 Node.js 中。</li></ul></li></ul><h2 id="2-ESM（ECMAScript-Module）导入"><a href="#2-ESM（ECMAScript-Module）导入" class="headerlink" title="2. ESM（ECMAScript Module）导入"></a>2. ESM（ECMAScript Module）导入</h2><ul><li>   原生支持的 ES6 模块系统。现代前端项目和 Node.js (v12+) 支持 ESM。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入默认导出</span></span><br><span class="line"><span class="keyword">import</span> defaultExport <span class="keyword">from</span> <span class="string">&#x27;./myModule.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入命名导出</span></span><br><span class="line"><span class="keyword">import</span> &#123; namedExport1, namedExport2 &#125; <span class="keyword">from</span> <span class="string">&#x27;./myModule.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重命名导入的变量</span></span><br><span class="line"><span class="keyword">import</span> &#123; namedExport <span class="keyword">as</span> alias &#125; <span class="keyword">from</span> <span class="string">&#x27;./myModule.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入所有内容为对象</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> myModule <span class="keyword">from</span> <span class="string">&#x27;./myModule.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态导入</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable language_">module</span> = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">&#x27;./myModule.js&#x27;</span>);</span><br></pre></td></tr></table></figure><ul><li> 特性：<ul><li>   更加模块化，支持 tree-shaking。</li><li>   可与 async/await 配合动态导入。</li></ul></li></ul><h2 id="3-AMD（Asynchronous-Module-Definition）导入"><a href="#3-AMD（Asynchronous-Module-Definition）导入" class="headerlink" title="3. AMD（Asynchronous Module Definition）导入"></a>3. AMD（Asynchronous Module Definition）导入</h2><ul><li>   常见于老的前端工具（如 RequireJS）。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="string">&#x27;./myModule&#x27;</span>], <span class="keyword">function</span> (<span class="params">myModule</span>) &#123;</span><br><span class="line">  <span class="comment">// 模块加载完成后的操作</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li> 特性：<ul><li>   适用于浏览器，支持异步加载模块。</li><li>   不常见于现代项目。</li></ul></li></ul><h2 id="4-UMD（Universal-Module-Definition）导入"><a href="#4-UMD（Universal-Module-Definition）导入" class="headerlink" title="4. UMD（Universal Module Definition）导入"></a>4. UMD（Universal Module Definition）导入</h2><ul><li>   兼容 CommonJS、AMD 和全局变量的模块。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> (<span class="params">root, factory</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">&#x27;function&#x27;</span> &amp;&amp; define.<span class="property">amd</span>) &#123;</span><br><span class="line">    <span class="title function_">define</span>([<span class="string">&#x27;dependency&#x27;</span>], factory); <span class="comment">// AMD</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">module</span> === <span class="string">&#x27;object&#x27;</span> &amp;&amp; <span class="variable language_">module</span>.<span class="property">exports</span>) &#123;</span><br><span class="line">    <span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title function_">factory</span>(<span class="built_in">require</span>(<span class="string">&#x27;dependency&#x27;</span>)); <span class="comment">// CommonJS</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    root.<span class="property">myModule</span> = <span class="title function_">factory</span>(root.<span class="property">dependency</span>); <span class="comment">// 浏览器全局</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;(<span class="variable language_">this</span>, <span class="keyword">function</span> (<span class="params">dependency</span>) &#123;</span><br><span class="line">  <span class="comment">// 模块逻辑</span></span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><ul><li> 特性：<ul><li>   用于需要同时支持多种环境的库。</li></ul></li></ul><h2 id="5-全局变量方式导入"><a href="#5-全局变量方式导入" class="headerlink" title="5. 全局变量方式导入"></a>5. 全局变量方式导入</h2><ul><li>   不使用模块系统，通过 &lt;script&gt; 标签引入脚本。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;myModule.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">myModule</span>); <span class="comment">// 直接访问全局变量</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li> 特性：<ul><li>   适合简单页面，但无法实现模块隔离。</li></ul></li></ul><h2 id="总结：什么时候用哪种导入方式？"><a href="#总结：什么时候用哪种导入方式？" class="headerlink" title="总结：什么时候用哪种导入方式？"></a>总结：什么时候用哪种导入方式？</h2><ul><li>   Node.js：推荐使用 ESM (import)，但 CommonJS (require) 仍然广泛支持。</li><li>   现代前端项目：推荐使用 ESM 导入。</li><li>   老旧项目或浏览器兼容性需求：可能使用 AMD 或 UMD。</li><li>   简单静态页面：直接使用全局变量导入。</li></ul><p>如需在 ESM 和 CommonJS 间兼容，你可能需要配置工具（如 Rollup、Webpack）或添加 .cjs、.mjs 文件后缀来区分模块类型。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在 JavaScript 中，导入模块的方式根据使用的模块规范（如 CommonJS、ESM 等）有所不同。下面介绍几种常见的导入方式：&lt;/p&gt;
&lt;h2 id=&quot;1-CommonJS-模块导入&quot;&gt;&lt;a href=&quot;#1-CommonJS-模块导入&quot; class=&quot;heade</summary>
      
    
    
    
    <category term="未分类" scheme="https://www.laoliang.ink/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
    
    <category term="无标签" scheme="https://www.laoliang.ink/tags/%E6%97%A0%E6%A0%87%E7%AD%BE/"/>
    
  </entry>
  
  <entry>
    <title>如何区分反向代理和正向代理</title>
    <link href="https://www.laoliang.ink/posts/20211026095522/"/>
    <id>https://www.laoliang.ink/posts/20211026095522/</id>
    <published>2021-10-26T01:55:22.000Z</published>
    <updated>2024-11-16T11:26:50.327Z</updated>
    
    <content type="html"><![CDATA[<p>反向代理和正向代理的主要区别在于它们代理的对象和使用场景不同。</p><p>以下是它们的概念、工作方式和使用场景的详细对比：</p><h2 id="1-反向代理（Reverse-Proxy）"><a href="#1-反向代理（Reverse-Proxy）" class="headerlink" title="1. 反向代理（Reverse Proxy）"></a>1. 反向代理（Reverse Proxy）</h2><p><strong>定义：</strong></p><p>反向代理服务器位于客户端和服务器之间，它代表服务器接收客户端的请求，并将请求转发给真正的后端服务器，然后将服务器的响应返回给客户端。</p><p><strong>工作流程：</strong></p><ol><li>客户端发出请求到代理服务器。</li><li>代理服务器将请求转发给内部的真实服务器。</li><li>真实服务器返回响应给代理服务器。</li><li>代理服务器再将响应返回给客户端。</li></ol><p><strong>典型场景：</strong></p><ul><li>负载均衡：将请求分配到多个后端服务器，减轻单一服务器的压力。</li><li>安全防护：隐藏后端服务器的真实 IP，保护其不受攻击。</li><li>缓存加速：将常用资源缓存在代理服务器上，提高响应速度。</li><li>跨域处理（CORS）：前端开发时，通过反向代理解决跨域问题。</li></ul><p><strong>示例：</strong></p><ul><li>   使用 Nginx 或 Apache 作为反向代理，将请求转发到不同的后端服务器。</li><li>CDN（内容分发网络）也是反向代理的一种，通过代理服务器缓存资源，减少主服务器负载。</li></ul><h2 id="2-正向代理（Forward-Proxy）"><a href="#2-正向代理（Forward-Proxy）" class="headerlink" title="2. 正向代理（Forward Proxy）"></a>2. 正向代理（Forward Proxy）</h2><p><strong>定义：</strong></p><p>正向代理位于客户端和服务器之间，它代表客户端发出请求，将客户端的请求转发给目标服务器，然后将服务器的响应返回给客户端。</p><p><strong>工作流程：</strong></p><ol><li>客户端先向正向代理服务器发送请求。</li><li>代理服务器代表客户端与目标服务器建立连接。</li><li>目标服务器返回响应给代理服务器。</li><li>代理服务器再将响应传回客户端。</li></ol><p><strong>典型场景：</strong></p><ul><li>   访问受限资源：通过代理访问被屏蔽的网站（例如翻墙工具）。</li><li>   隐匿客户端 IP：隐藏用户的真实 IP，提高匿名性和隐私。</li><li>   缓存内容：减少多次访问相同资源的网络消耗。</li><li>   企业内网管理：限制员工访问某些网站或监控上网行为。</li></ul><p><strong>示例：</strong></p><ul><li>   使用 Shadowsocks 或 Squid 实现网络代理访问外网。</li><li>   通过公司内网的代理服务器访问互联网。</li></ul><h2 id="3-反向代理-vs-正向代理：核心区别"><a href="#3-反向代理-vs-正向代理：核心区别" class="headerlink" title="3. 反向代理 vs 正向代理：核心区别"></a>3. 反向代理 vs 正向代理：核心区别</h2><table><thead><tr><th align="center">对比维度</th><th align="center">反向代理</th><th align="center">正向代理</th></tr></thead><tbody><tr><td align="center">代理对象</td><td align="center">服务器（替服务器接收请求）</td><td align="center">客户端（替客户端发出请求）</td></tr><tr><td align="center">客户端感知</td><td align="center">客户端无需知道真实服务器的存在</td><td align="center">目标服务器无需知道客户端的存在</td></tr><tr><td align="center">隐藏的 IP</td><td align="center">隐藏服务器的 IP</td><td align="center">隐藏客户端的 IP</td></tr><tr><td align="center">适用场景</td><td align="center">负载均衡、安全防护、缓存、CORS 处理</td><td align="center">匿名上网、访问受限资源、缓存、企业管控</td></tr><tr><td align="center">典型应用</td><td align="center">Nginx、CDN、API、网关</td><td align="center">Shadowsocks、VPN、公司网络代理</td></tr></tbody></table><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><ul><li>   正向代理更像是客户端的“助手”，帮助客户端访问外部资源，尤其是那些受限或无法直接访问的资源。</li><li>   反向代理更像是服务器的“看门人”，代理服务器替后端服务器处理请求，提供安全性、负载均衡和缓存等服务。</li></ul><p>简而言之：</p><ul><li>   正向代理是“我（客户端）无法直接访问，但通过代理我能去”。</li><li>   反向代理是“你找我（代理服务器）就对了，我帮你转发给正确的后端服务器”。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;反向代理和正向代理的主要区别在于它们代理的对象和使用场景不同。&lt;/p&gt;
&lt;p&gt;以下是它们的概念、工作方式和使用场景的详细对比：&lt;/p&gt;
&lt;h2 id=&quot;1-反向代理（Reverse-Proxy）&quot;&gt;&lt;a href=&quot;#1-反向代理（Reverse-Proxy）&quot; class</summary>
      
    
    
    
    <category term="未分类" scheme="https://www.laoliang.ink/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
    
    <category term="无标签" scheme="https://www.laoliang.ink/tags/%E6%97%A0%E6%A0%87%E7%AD%BE/"/>
    
  </entry>
  
  <entry>
    <title>一文彻底搞懂 CORS 及常见开发调试的解决方案</title>
    <link href="https://www.laoliang.ink/posts/20211025192521/"/>
    <id>https://www.laoliang.ink/posts/20211025192521/</id>
    <published>2021-10-25T11:25:21.000Z</published>
    <updated>2024-11-16T11:26:50.327Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>你是否在开发前后端分离项目时遇到过 <strong>跨域资源共享 (CORS)</strong> 的报错？<br>比如，明明后端已经返回了数据，前端却弹出一个 <strong>“Access-Control-Allow-Origin”</strong> 的错误。这篇文章将带你深入理解 CORS 的原理，并分享一些常见的开发调试解决方案，帮你在开发过程中游刃有余。</p><h2 id="什么是-CORS？"><a href="#什么是-CORS？" class="headerlink" title="什么是 CORS？"></a>什么是 CORS？</h2><p><strong>CORS</strong>（Cross-Origin Resource Sharing）是一种 <strong>浏览器安全机制</strong>，用于限制来自不同源的请求，以防止潜在的跨站攻击。</p><p>简单来说，**”同源”** 是指：  </p><ul><li><strong>协议</strong>、<strong>域名</strong>、<strong>端口号</strong> 三者相同<br>例如：<code>https://example.com:8080</code> 和 <code>https://example.com:80</code> 因端口号不同，就被视为 <strong>不同源</strong>。</li></ul><p>浏览器对跨源请求的限制，主要是为了保护用户信息。CORS 的出现，允许服务器明确声明哪些跨源请求是允许的，从而控制前端是否可以正常访问这些资源。</p><hr><h2 id="浏览器中的-CORS-行为"><a href="#浏览器中的-CORS-行为" class="headerlink" title="浏览器中的 CORS 行为"></a>浏览器中的 CORS 行为</h2><p>浏览器根据 <strong>HTTP 请求方法</strong> 对跨域请求分为两类：</p><ol><li><strong>简单请求 (Simple Request)</strong>  </li><li><strong>预检请求 (Preflight Request)</strong>  </li></ol><h3 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h3><p>如果满足以下条件，浏览器会直接发送请求：</p><ul><li>请求方法是 <code>GET</code>、<code>POST</code> 或 <code>HEAD</code>。</li><li>请求头是<strong>简单头</strong>：如 <code>Accept</code>、<code>Content-Type: text/plain</code> 等。</li><li>没有使用复杂的自定义头。</li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;https://api.example.com/data&#x27;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> response.<span class="title function_">json</span>())</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(data))</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;CORS 错误:&#x27;</span>, error));</span><br></pre></td></tr></table></figure><p>如果服务器允许这个跨域请求，响应头中会包含如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: *</span><br></pre></td></tr></table></figure><p>* 表示允许任何来源的请求访问资源。</p><h3 id="预检请求"><a href="#预检请求" class="headerlink" title="预检请求"></a>预检请求</h3><p>对于复杂请求（如 PUT、DELETE 或带有自定义头的请求），浏览器会在发送请求前，先发起一个 OPTIONS 请求，这就是 预检请求。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;https://api.example.com/data&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">  <span class="attr">headers</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;X-Custom-Header&#x27;</span>: <span class="string">&#x27;foobar&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">body</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span> &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>预检请求的目的是询问服务器：</p><p>“这个请求可以发送吗？如果可以，我该如何发送？”</p><p><strong>响应示例：</strong></p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">204</span> No Content</span><br><span class="line"><span class="attribute">Access-Control-Allow-Origin</span><span class="punctuation">: </span>https://myfrontend.com</span><br><span class="line"><span class="attribute">Access-Control-Allow-Methods</span><span class="punctuation">: </span>POST, OPTIONS</span><br><span class="line"><span class="attribute">Access-Control-Allow-Headers</span><span class="punctuation">: </span>X-Custom-Header</span><br></pre></td></tr></table></figure><h2 id="CORS-常见错误及解决方案"><a href="#CORS-常见错误及解决方案" class="headerlink" title="CORS 常见错误及解决方案"></a>CORS 常见错误及解决方案</h2><h3 id="错误-1：No-‘Access-Control-Allow-Origin’-header-is-present"><a href="#错误-1：No-‘Access-Control-Allow-Origin’-header-is-present" class="headerlink" title="错误 1：No ‘Access-Control-Allow-Origin’ header is present"></a>错误 1：No ‘Access-Control-Allow-Origin’ header is present</h3><p>这是最常见的错误，表示服务器没有返回 Access-Control-Allow-Origin 头。</p><p><strong>解决方案：</strong></p><p>在服务器端增加响应头：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Node.js 示例</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;*&#x27;</span>); <span class="comment">// 允许所有来源</span></span><br><span class="line">  <span class="title function_">next</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/data&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.<span class="title function_">json</span>(&#123; <span class="attr">message</span>: <span class="string">&#x27;Hello, CORS!&#x27;</span> &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>, <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Server running on port 3000&#x27;</span>));</span><br></pre></td></tr></table></figure><p>注意：生产环境中尽量不要使用 *，而是指定具体的来源，避免安全隐患。</p><h3 id="错误-2：CORS-Preflight-Did-Not-Succeed"><a href="#错误-2：CORS-Preflight-Did-Not-Succeed" class="headerlink" title="错误 2：CORS Preflight Did Not Succeed"></a>错误 2：CORS Preflight Did Not Succeed</h3><p>这是由于 <strong>预检请求</strong> 被服务器拒绝。</p><p><strong>解决方案：</strong></p><p>确保服务器正确处理 OPTIONS 请求：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">options</span>(<span class="string">&#x27;/data&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;https://myfrontend.com&#x27;</span>);</span><br><span class="line">  res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Methods&#x27;</span>, <span class="string">&#x27;POST, OPTIONS&#x27;</span>);</span><br><span class="line">  res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>, <span class="string">&#x27;X-Custom-Header&#x27;</span>);</span><br><span class="line">  res.<span class="title function_">sendStatus</span>(<span class="number">204</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果使用 NGINX 代理服务，可以配置：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> /api/ &#123;</span><br><span class="line">    <span class="attribute">if</span> (<span class="variable">$request_method</span> = OPTIONS) &#123;</span><br><span class="line">        <span class="attribute">add_header</span> <span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span> <span class="string">&#x27;https://myfrontend.com&#x27;</span>;</span><br><span class="line">        <span class="attribute">add_header</span> <span class="string">&#x27;Access-Control-Allow-Methods&#x27;</span> <span class="string">&#x27;GET, POST, OPTIONS&#x27;</span>;</span><br><span class="line">        <span class="attribute">add_header</span> <span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span> <span class="string">&#x27;X-Custom-Header&#x27;</span>;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">204</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何在开发环境中绕过-CORS？"><a href="#如何在开发环境中绕过-CORS？" class="headerlink" title="如何在开发环境中绕过 CORS？"></a>如何在开发环境中绕过 CORS？</h2><p>在开发过程中，为了快速调试，你可以采用以下方法：</p><h3 id="方法-1：使用-Chrome-禁用-CORS-检查"><a href="#方法-1：使用-Chrome-禁用-CORS-检查" class="headerlink" title="方法 1：使用 Chrome 禁用 CORS 检查"></a>方法 1：使用 Chrome 禁用 CORS 检查</h3><p>你可以通过命令行启动 Chrome，禁用 CORS 检查：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open -na <span class="string">&quot;Google Chrome&quot;</span> --args --disable-web-security --user-data-dir=/tmp/cors</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 此方法仅适用于开发环境，不要在生产环境中使用。</p><h3 id="方法-2：使用代理服务器"><a href="#方法-2：使用代理服务器" class="headerlink" title="方法 2：使用代理服务器"></a>方法 2：使用代理服务器</h3><p>你可以通过前端设置 反向代理，将跨域请求转发到同源服务器。例如，在本地的 webpack 中配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="attr">proxy</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;/api&#x27;</span>: &#123;</span><br><span class="line">        <span class="attr">target</span>: <span class="string">&#x27;https://api.example.com&#x27;</span>,</span><br><span class="line">        <span class="attr">changeOrigin</span>: <span class="literal">true</span>, <span class="comment">// 解决跨域问题</span></span><br><span class="line">        <span class="attr">pathRewrite</span>: &#123; <span class="string">&#x27;^/api&#x27;</span>: <span class="string">&#x27;&#x27;</span> &#125;, <span class="comment">// 重写路径，将 /api 去掉</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>使用说明：</strong></p><ol><li>上述配置将前端发往 /api 的请求代理到 <a href="https://api.example.com./">https://api.example.com。</a></li><li>changeOrigin: true 可以伪造请求来源，避免目标服务器拒绝求。</li><li>pathRewrite 将匹配到的 /api 前缀去掉，保证请求路径正确射。</li></ol><h3 id="方法-3：安装-CORS-浏览器插件"><a href="#方法-3：安装-CORS-浏览器插件" class="headerlink" title="方法 3：安装 CORS 浏览器插件"></a>方法 3：安装 CORS 浏览器插件</h3><p>一些浏览器插件可以绕过 CORS 检查，例如 CORS Unblock。虽然方便，但这种方法存在安全风险，建议慎用。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>CORS 是现代 Web 开发中的重要机制，它帮助浏览器保护用户数据的安全。理解其工作原理并合理配置服务器，可以有效避免开发中的跨域问题。</p><p>总结一下，我们可以：</p><ol><li>在服务器端设置 Access-Control-Allow-Origin 响应头。</li><li>正确处理 预检请求，避免 CORS 请求被拒绝。</li><li>在开发环境中使用代理或临时禁用 CORS 检查，提升调试效率。</li></ol><p>希望这篇文章能帮助你彻底搞懂 CORS，并在开发过程中得心应手。如果你遇到其他跨域问题，欢迎在评论区交流！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;你是否在开发前后端分离项目时遇到过 &lt;strong&gt;跨域资源共享 (CORS)&lt;/strong&gt; 的报错？&lt;br&gt;比如，明明后端已经返回了数</summary>
      
    
    
    
    <category term="未分类" scheme="https://www.laoliang.ink/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
    
    <category term="无标签" scheme="https://www.laoliang.ink/tags/%E6%97%A0%E6%A0%87%E7%AD%BE/"/>
    
  </entry>
  
  <entry>
    <title>script元素脚本加载详解</title>
    <link href="https://www.laoliang.ink/posts/20210320215035/"/>
    <id>https://www.laoliang.ink/posts/20210320215035/</id>
    <published>2021-03-20T13:50:35.000Z</published>
    <updated>2024-11-16T11:26:50.324Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我们知道，将 JavaScript 插入 HTML 的主要方法是使用 <code>&lt;script&gt;</code> 元素。这个元素是由网景公司创造出来，并最早在 Netscape Navigator 2 中实现的。后来，这个元素被正式加入到 HTML 规范。</p><p>为了更好地了解 JavaScript 在 HTML 中的加载情况，我们先简单介绍一些基础知识。</p></blockquote><p><code>&lt;script&gt;</code> 元素有下列 8 个属性：</p><ul><li><strong><code>async</code></strong> : 可选。表示应该立即开始下载脚本，但不能组织其他页面动作，比如下载资源或等待其他脚本加载。只对外部脚本文件有效。</li><li><code>charset</code> : 可选。使用 <code>src</code> 属性指定的代码字符集。这个属性很少使用，因为大多数浏览器不在乎它的值。</li><li><code>crossorigin</code> : 可选。配置相关请求 CORS（跨域资源共享）设置。默认不适用 CORS。crossorigin=”anonymous” 配置文件请求不必设置凭据标志。</li><li><strong><code>defer</code></strong> : 可选。表示脚本可以延迟到文档完全被解析和显示之后再执行。只对外部脚本文件有效。在 IE7 及更早的版本中，对行内脚本也可以指定这个属性。</li><li><code>integrity</code> : 可选。允许比对接收到和指定的加密签名以验证子资源完整性（SRI，Subresource Integrity）。如果接收到的资源的签名与这个属性指定的签名不匹配，则页面会报错，脚本不会执行。这个属性可以用于确保内容分发网络（CDN，Content Delivery Network）不会提供恶意内容。</li><li><code>language</code> : 废弃。最初用于表示代码块中的脚本语言（如“JavaScript”、“JavaScript 1.2”或“VBScript”）。大多数浏览器都会忽略这个属性，不应该再使用它。</li><li><strong><code>src</code></strong> : 可选。表示包含要执行的代码的外部文件。</li><li><code>type</code> : 可选。代替 <code>language</code>，表示代码块中脚本语言的内容类型（也称 MIME 类型）。按照惯例，这个值始终都是 <code>text/javascript</code> ，尽管 <code>text/javascript</code> 和 <code>ecmascript</code> 都已经废弃了。JavaScript 文件的 MIME 类型通常是 <code>application/x-javascript</code> ，不过给 <code>type</code> 属性这个值有可能 <strong>导致脚本被忽略</strong>。在非 IE 的浏览器中有效的其他值还有 <code>application/javascript</code> 和 <code>application/ecmascript</code> 。如果这个是 <strong><code>module</code></strong> ，则代码会被当成 ES6 模块，而且只有这时候代码中才能出现 <strong><code>import</code></strong> 和 <strong><code>export</code></strong> 关键字。</li></ul><h2 id="外部-JavaScript-的加载与解释"><a href="#外部-JavaScript-的加载与解释" class="headerlink" title="外部 JavaScript 的加载与解释"></a>外部 JavaScript 的加载与解释</h2><p>使用 <code>src</code> 属性解析外部资源时，会向 <code>src</code> 属性指定的路径发送一个 GET 请求，以取得相应资源，假定是一个 JavaScript 文件。这个初始的请求不受浏览器同源策略限制，但返回并执行的 JavaScript 则受限制。当然，这个请求仍然受父页面 HTTP/HTTPS 协议的限制。</p><p>默认状态下，浏览器会按照 <code>&lt;script&gt;</code> 在页面中出现的顺序依次解释它们，前提是它们没有使用 <code>defer</code> 和 <code>async</code> 属性。第二个 <code>&lt;script&gt;</code> 元素的代码必须在第一个 <code>&lt;script&gt;</code> 元素的代码解释完毕才能开始解释，第三个则必须等第二个解释完，以此类推。</p><h2 id="标签位置"><a href="#标签位置" class="headerlink" title="标签位置"></a>标签位置</h2><p>过去，所有 <code>&lt;script</code> 元素都被放在页面的 <code>&lt;head&gt;</code> 标签内，如下面的例子所示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;example11.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;example12.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 这里是页面内容 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这种做法的主要目的是把外部的 CSS 和 JavaScript 文件都集中放到一起。不过，把所有 JavaScript 文件都放在 <code>&lt;head&gt;</code> 里，也就意味着必须把所有 JavaScript 代码都下载、解析和解释完成后，才能开始渲染页面（页面在浏览器解析到 <code>&lt;body&gt;</code> 的起始标签时开始渲染）。对于需要很多 JavaScript 的页面，这会导致页面渲染的明显延迟，在此期间浏览器窗口完全空白。未解决这个问题，现代 Web 应用程序通常将所有 JavaScript 引用放在 <code>&lt;body&gt;</code> 元素中的页面内容后面，如下面的例子所示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 这里是页面内容 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;example11.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;example12.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样一来，页面会在处理 JavaScript 代码之前完全渲染页面。用户会感觉页面加载更快了，因为浏览器显示空白页面的时间短了。</p><h2 id="推迟脚本执行（defer）"><a href="#推迟脚本执行（defer）" class="headerlink" title="推迟脚本执行（defer）"></a>推迟脚本执行（defer）</h2><p>HTML 4.01 为 <code>&lt;script&gt;</code> 元素定义了一个叫 <code>defer</code> 的属性。这个属性表示脚本在执行的时候不会改变页面的结构。也就是说，脚本会被延迟到整个页面都解析完毕后再运行。因此，在 <code>&lt;script&gt;</code> 元素上设置 <code>defer</code> 属性，相当于告诉浏览器立即下载，但延迟执行。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">&quot;example11.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">&quot;example12.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 这里是页面内容 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>虽然这个例子中的 <code>&lt;script&gt;</code> 元素包含在页面的 <code>&lt;head&gt;</code> 中，但它们会在浏览器解析到结束的 <code>&lt;/html&gt;</code> 标签后才会执行。HTML5 规范要求脚本应该按照它们出现的顺序执行，因此第一个推迟的脚本会在第二个推迟的脚本之前执行，而且两者会在 DOMContentLoaded 事件之前执行。不过在实际当中，推迟执行的脚本不一定总会按顺序执行或者在 DOMContentLoaded 事件之前执行，因此最好只包含一个这样的脚本。</p><h2 id="异步执行脚本（async）"><a href="#异步执行脚本（async）" class="headerlink" title="异步执行脚本（async）"></a>异步执行脚本（async）</h2><p>HTML5 为 <code>&lt;script&gt;</code> 元素定义了 <code>async</code> 属性。从改变脚本处理方式上看，<code>async</code> 属性与 <code>defer</code> 类似。当然，它们两者也都只适用于外部脚本，都会告诉浏览器立即开始下载。不过，与 <code>defer</code> 不同的是，标记为 <code>async</code> 的脚本并不保证能按照它们出现的次序执行，比如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">&quot;example11.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">&quot;example12.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 这里是页面内容 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在这个例子中，第二个脚本可能先于第一个脚本执行。因此，重点在于它们之间没有依赖关系。给脚本添加 <code>async</code> 属性的目的是告诉浏览器，不必等脚本下载和执行完后再加载页面，同样也不必等到该一步脚本下载和执行后再加载其他脚本。正因为如此，异步脚本不应该在加载期间修改 DOM。</p><p>异步脚本保证会在页面的 load 事件前执行，但可能会在 DOMContentLoaded 之后或之前。</p><h2 id="脚本加载时机对比"><a href="#脚本加载时机对比" class="headerlink" title="脚本加载时机对比"></a>脚本加载时机对比</h2><p><img src="/posts/20210320215035/script%E8%84%9A%E6%9C%AC%E5%8A%A0%E8%BD%BD%E6%97%B6%E6%9C%BA.png" class="lazyload" data-srcset="/posts/20210320215035/script%E8%84%9A%E6%9C%AC%E5%8A%A0%E8%BD%BD%E6%97%B6%E6%9C%BA.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="script脚本加载时机"></p><p>我们上一张图👆</p><blockquote><ul><li><p>绿色 parser：指的是 HTML 引擎的解析，解析 HTML 文本的解析器</p></li><li><p>蓝色 fetch：代表的是获取脚本资源</p></li><li><p>红色 execution：代表的脚本的执行</p></li></ul></blockquote><h3 id="默认情况下"><a href="#默认情况下" class="headerlink" title="默认情况下"></a>默认情况下</h3><p>默认情况下，脚本的加载和解析执行，会中断 HTML 文本的解析。</p><p>这是由于，由于 JS 解析引擎 和 浏览器渲染引擎，是互斥的，JS 在解析执行过程中，GUI渲染线程会被挂起（渲染的当前状态会被保存）。当 JS 执行结束后，渲染线程才会继续。</p><h3 id="使用-defer-属性时"><a href="#使用-defer-属性时" class="headerlink" title="使用 defer 属性时"></a>使用 defer 属性时</h3><p>使用 <code>defer</code> 属性，脚本的获取加载过程不会中断 HTML 文本的解析，而是通过异步的方式获取脚本。但是，此时脚本的解析执行，仍然要等到 HTML 文本的解析结束后。</p><h3 id="使用-async-属性时"><a href="#使用-async-属性时" class="headerlink" title="使用 async 属性时"></a>使用 async 属性时</h3><p>使用 <code>async</code> 属性时，与 <code>defer</code> 相似的是，脚本的加载同样是异步的方式，不同的是，脚本的解析执行不依赖 HTML 文档的解析结束，脚本会在加载完成后立即解析执行，且这时候会中断 HTML 文本的解析。</p><h3 id="针对-type-”module”-的加载执行"><a href="#针对-type-”module”-的加载执行" class="headerlink" title="针对 type=”module” 的加载执行"></a>针对 type=”module” 的加载执行</h3><p>上面的基础知识部分提到，使用 <code>type=&quot;module&quot;</code> 标记的 <code>&lt;script&gt;</code> 元素，代码会被当成 ES6 模块。</p><p>这时候脚本的加载和执行逻辑默认和 <code>defer</code> 属性标记时的规则是一致的，当遇到 <code>&lt;script&gt;</code> 标签元素时，脚本会从模块入口异步开始加载，过程中可能会分叉去加载引用的其他脚本，最后回到入口模块，整个加载过程不会中断 HTML 文本的解析。而脚本的解析执行则像加了 <code>defer</code> 属性一样，需要等待 HTML 文本解析结束后才能开始。</p><p>若 使用 <code>type=&quot;module&quot;</code> 时，同时使用 <code>async</code> 属性，那么脚本的解析执行会在加载完成后立即进行，且解析执行过程会中断 HTML 文本的解析。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们知道 <code>&lt;script&gt;</code> 标签是在网页中使用 JavaScript 的最根本的机制，所以，对这些加载时机和各种属性的理解，对我们将来做性能优化和提升脚本的安全性是非常重要的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;我们知道，将 JavaScript 插入 HTML 的主要方法是使用 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 元素。这个元素是由网景公司创造出来，并最早在 Netscape Navigator 2 中实现的。后来，这个元素被正式加入</summary>
      
    
    
    
    <category term="未分类" scheme="https://www.laoliang.ink/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
    
    <category term="无标签" scheme="https://www.laoliang.ink/tags/%E6%97%A0%E6%A0%87%E7%AD%BE/"/>
    
  </entry>
  
  <entry>
    <title>一种适合小团队的Git协作流程</title>
    <link href="https://www.laoliang.ink/posts/20210313223731/"/>
    <id>https://www.laoliang.ink/posts/20210313223731/</id>
    <published>2021-03-13T14:37:31.000Z</published>
    <updated>2024-11-16T11:26:50.327Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>团队开发中，遵循一个合理、清晰的Git使用流程，是非常重要的</p><p>否则，每个人都提交一堆杂乱无章的commit，项目很快就会变得难以协调和维护</p></blockquote><h3 id="分支介绍"><a href="#分支介绍" class="headerlink" title="分支介绍"></a>分支介绍</h3><ol><li><strong>master - 主分支</strong><ul><li>所有提供给用户使用的正式版本，都在这个主分支上发布</li><li>开发者在此分支 <strong>不可进行 <code>push</code> 操作</strong></li></ul></li><li><strong>dev - 开发分支</strong><ul><li>日常开发所使用的分支，开发者完成的阶段性功能模块将首先被合并到此分支</li><li>此分支亦是团队内部测试、阶段性工作验证所使用的分支</li><li>开发者在此分支 <strong>不可进行 <code>push</code> 操作</strong>，只能通过 <strong>Pull Request</strong> 的方式将个人分支合并到此分支</li><li>开发过程中，要经常与此分支保持同步</li></ul></li><li><strong>feature/xxx - 特性分支</strong><ul><li>用于某个功能模块的开发，例如：张三创建了一个 <code>feature/package-manager</code> 分支负责开发包管理器模块</li><li>当该功能模块开发任务完成后，通过 <strong>Pull Request</strong> 的形式进行请求合并，管理员 <strong>Code Review</strong> 通过后，将该分支合并到 <code>dev</code> 分支；此后，该分支将被删除</li><li>一旦完成开发，它们就会被合并进 <code>dev</code> 分支<strong>（仅能通过 Pull Request 的方式）</strong>，然后被删除</li><li>此类分支由开发者个人管理和使用， <strong>可以进行 <code>push</code> 操作</strong></li><li>开发过程中，此类分支要经常与 <code>dev</code> 分支保持同步</li></ul></li><li><strong>hotfix/xxx - 补丁分支</strong><ul><li>用于紧急修复 Bug 的分支，可以由 <code>master</code> 或 <code>dev</code> 分支创建</li><li>同 <code>feature/xxx</code> 分支一样，一旦修复工作完成，它们就会被合并进 <code>master</code> 或 <code>dev</code> 分支 <strong>（仅能通过 Pull Request 的方式）</strong>，然后就被删除</li></ul></li></ol><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开发前克隆 dev 分支到本地</span></span><br><span class="line">git clone -b dev https://github.com/liangpengyv/vue-mvvm.git</span><br></pre></td></tr></table></figure><h4 id="第一步：新建分支"><a href="#第一步：新建分支" class="headerlink" title="第一步：新建分支"></a>第一步：新建分支</h4><p>首先，每次开发新功能，都应该新建一个单独的分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取 dev 分支最新代码</span></span><br><span class="line">git checkout dev</span><br><span class="line">git pull</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">新建一个特性分支</span></span><br><span class="line">git branch feature/xxx</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切换到该特性分支，进行开发</span></span><br><span class="line">git checkout feature/xxx</span><br></pre></td></tr></table></figure><h4 id="第二部：提交分支"><a href="#第二部：提交分支" class="headerlink" title="第二部：提交分支"></a>第二部：提交分支</h4><p>分支修改后，就可以提交了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">提交代码</span></span><br><span class="line">git add .</span><br><span class="line">git commit</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开发过程中，将本地仓库开发中的特性分支 push 到远程仓库（可选的）</span></span><br><span class="line">git push -u origin feature/xxx</span><br></pre></td></tr></table></figure><p><code>git push</code> 的 <code>-u</code> 参数，表示将远程仓库 <code>origin/feature/xxx</code> 与 本地仓库 <code>feature/xxx</code> 建立关联，下一次执行 <code>push</code> 命令，可省略后面的远程仓库名和分支名，直接输入 <code>git push</code> 即可</p><h4 id="第三步：与-dev-主干同步"><a href="#第三步：与-dev-主干同步" class="headerlink" title="第三步：与 dev 主干同步"></a>第三步：与 dev 主干同步</h4><p>分支的开发过程中，要经常与 <code>dev</code> 主干保持同步</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取 dev 分支最新代码</span></span><br><span class="line">git checkout dev</span><br><span class="line">git pull</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切换回当前开发的特性分支</span></span><br><span class="line">git checkout feature/xxx</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">合并 dev 分支到当前分支</span></span><br><span class="line">git merge dev</span><br></pre></td></tr></table></figure><h4 id="第四步：发出-Pull-Request"><a href="#第四步：发出-Pull-Request" class="headerlink" title="第四步：发出 Pull Request"></a>第四步：发出 Pull Request</h4><p>完成当前特性分支的所有开发任务，进行最后一次 <strong>与 dev 主干同步</strong> 工作，并提交到远程仓库以后，就可以发出 <strong>Pull Request 到 dev 分支</strong>，然后请求管理员进行 <strong>Code Review</strong> ，确认可以合并到 <code>dev</code> 分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">最后进行一次步骤三的同步工作</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">提交到远程仓库</span></span><br><span class="line">git checkout feature/xxx</span><br><span class="line">git push origin feature/xxx</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在 GitHub 管理界面创建 Pull Request，等待管理员进行 Code Review</span></span><br></pre></td></tr></table></figure><h4 id="第五步：清理无用的分支"><a href="#第五步：清理无用的分支" class="headerlink" title="第五步：清理无用的分支"></a>第五步：清理无用的分支</h4><p>某个特性分支开发任务全部完成后，应删除它</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">首先，切换回 dev 分支</span></span><br><span class="line">git checkout dev</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">先删除远程特性分支</span></span><br><span class="line">git push origin -d feature/xxx</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">再删除本地特性分支</span></span><br><span class="line">git branch -d feature/xxx</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;团队开发中，遵循一个合理、清晰的Git使用流程，是非常重要的&lt;/p&gt;
&lt;p&gt;否则，每个人都提交一堆杂乱无章的commit，项目很快就会变得难以协调和维护&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;分支介绍&quot;&gt;&lt;a href=&quot;#分支介绍&quot;</summary>
      
    
    
    
    <category term="未分类" scheme="https://www.laoliang.ink/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
    
    <category term="无标签" scheme="https://www.laoliang.ink/tags/%E6%97%A0%E6%A0%87%E7%AD%BE/"/>
    
  </entry>
  
  <entry>
    <title>Vue的双向绑定原理及简单实现</title>
    <link href="https://www.laoliang.ink/posts/20210306094502/"/>
    <id>https://www.laoliang.ink/posts/20210306094502/</id>
    <published>2021-03-06T01:45:02.000Z</published>
    <updated>2024-11-16T11:26:50.323Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vue-数据双向绑定原理"><a href="#Vue-数据双向绑定原理" class="headerlink" title="Vue 数据双向绑定原理"></a>Vue 数据双向绑定原理</h2><p>Vue 数据双向绑定是通过 <strong>数据劫持</strong> 结合 <strong>发布者-订阅者模式</strong> 的方式来实现的。</p><p>我们先来看下定义在 Vue 初始化数据上的对象是什么样的</p><p><strong>代码：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">obj</span>: &#123;</span><br><span class="line">      <span class="attr">foo</span>: <span class="number">1</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">obj</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><p><img src="/posts/20210306094502/Vue-data%E7%BB%93%E6%9E%84.png" class="lazyload" data-srcset="/posts/20210306094502/Vue-data%E7%BB%93%E6%9E%84.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="Vue-data结构"></p><p>可以看到属性 <code>foo</code> 有两个对应的 <code>get</code> 和 <code>set</code> 方法，这两个方法是如何出现的呢？这是因为 Vue 通过 <code>Object.defineProperty()</code> 来实现数据劫持的，它可以控制对象属性的一些特有操作，如读写权限、是否可枚举等，这里着重关注 <code>get</code> 和 <code>set</code> 两个函数。（有关 <code>Object.defineProperty()</code> 的更多内容，请点击 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">👆MDN-Object.defineProperty</a>）</p><p>首先，我们使用字面量形式初始化一个对象属性</p><p><strong>代码：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> book = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;JavaScript高级程序设计&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(book.<span class="property">name</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(book)</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><p><img src="/posts/20210306094502/JavaScript%E5%AF%B9%E8%B1%A1.png" class="lazyload" data-srcset="/posts/20210306094502/JavaScript%E5%AF%B9%E8%B1%A1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="JavaScript对象"></p><p>我们重新使用 <code>Object.defineProperty()</code> 的方式来定义对象属性，并对其 <code>get</code> 和 <code>set</code> 方法进行重写操作</p><p><strong>代码：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> book = &#123;&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(book, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">get</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;《&#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&#x27;》&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">set</span>: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = value</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;设置 name 属性值为：&#x27;</span> + value)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">book.<span class="property">name</span> = <span class="string">&#x27;JavaScript高级程序设计&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(book.<span class="property">name</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(book)</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><p><img src="/posts/20210306094502/%E7%9B%91%E5%90%AC%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7.png" class="lazyload" data-srcset="/posts/20210306094502/%E7%9B%91%E5%90%AC%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="监听对象属性"></p><p>可以看到，这次打印出来的数据，和通过 Vue 初始化的数据结构比较像了吧，它也有了 <code>get</code> 和 <code>set</code> 函数，这正是 Vue 实现 <strong>数据劫持</strong> 的实现原理。</p><h2 id="MVVM-实现思路分析"><a href="#MVVM-实现思路分析" class="headerlink" title="MVVM 实现思路分析"></a>MVVM 实现思路分析</h2><p>实现 MVVM 主要包含两个方面：</p><ul><li>数据变化更新视图</li><li>视图变化更新数据</li></ul><p><img src="/posts/20210306094502/MVVM.png" class="lazyload" data-srcset="/posts/20210306094502/MVVM.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="MVVM"></p><p>其中，view 更新 data 只需要通过事件监听即可，重点是 data 更新 view 是如何做到的呢？</p><p>其实，上文 <strong>数据劫持</strong> 的示例已经给出了答案。通过 <code>Object.defineProperty()</code> 对属性设置一个 set 函数，当数据改变时，set 函数就会被触发，所以我们只需要将更新 view 的方法写到这里，就可以实现 data 更新 view 了。</p><p><img src="/posts/20210306094502/%E6%95%B0%E6%8D%AE%E7%9B%91%E5%90%AC.png" class="lazyload" data-srcset="/posts/20210306094502/%E6%95%B0%E6%8D%AE%E7%9B%91%E5%90%AC.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="数据监听"></p><h2 id="实现一个监听器-Observer"><a href="#实现一个监听器-Observer" class="headerlink" title="实现一个监听器 Observer"></a>实现一个监听器 Observer</h2><p><strong>监听器</strong> 的作用就是去监听数据的每一个属性，通过上面的例子，我们知道可以用 <code>Object.defineProperty()</code> 方法实现。</p><p>当监听到属性值发生变化时，通知 <strong>订阅者 Watcher</strong> 执行更新函数去更新视图。</p><p>这个过程中，会有许多订阅者，所以我们还需要创建一个 <strong>订阅器 Dep</strong> 来统一管理，订阅器 Dep 有一个容器 subs，负责收集订阅者。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">defineReactive</span>(<span class="params">data, key, value</span>) &#123;</span><br><span class="line">    <span class="comment">// 递归遍历所有子属性</span></span><br><span class="line">    <span class="title function_">observe</span>(value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> dep = <span class="keyword">new</span> <span class="title class_">Dep</span>()</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(data, key, &#123;</span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">get</span>: <span class="keyword">function</span> <span class="title function_">reactiveGetter</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="title class_">Dep</span>.<span class="property">target</span>) &#123;</span><br><span class="line">                dep.<span class="title function_">addSub</span>(<span class="title class_">Dep</span>.<span class="property">target</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> value</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">set</span>: <span class="keyword">function</span> <span class="title function_">reactiveSetter</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (value === newValue) &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            value = newValue</span><br><span class="line">            dep.<span class="title function_">notify</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">observe</span>(<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!data || <span class="keyword">typeof</span> data !== <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">keys</span>(data).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">defineReactive</span>(data, key, data[key])</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Dep</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subs</span> = []</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Dep</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">    <span class="title function_">addSub</span>(<span class="params">sub</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">subs</span>.<span class="title function_">push</span>(sub)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">notify</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">subs</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">sub</span> =&gt;</span> &#123;</span><br><span class="line">            sub.<span class="title function_">update</span>()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Dep</span>.<span class="property">target</span> = <span class="literal">null</span></span><br></pre></td></tr></table></figure><h2 id="实现一个订阅者-Watcher"><a href="#实现一个订阅者-Watcher" class="headerlink" title="实现一个订阅者 Watcher"></a>实现一个订阅者 Watcher</h2><p><strong>订阅者 Watcher</strong> 的作用主要是接收属性变化的通知，然后去执行视图更新函数。</p><p>订阅者 Watcher 初始化时，需要将自己添加到订阅器 Dep 中。我们已经知道在监听器 Observer 的 get 函数中通过订阅器 Dep 执行了添加订阅者 Wather 的操作，所以只需要在 Watcher 初始化时触发 Observer 的 get 函数即可。而要触发 get 函数，只要获取对应的属性值便可触发了，这正是因为我们使用了 <code>Object.defineProperty()</code> 进行数据监听。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Watcher</span>(<span class="params">vm, exp, cb</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">vm</span> = vm</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">exp</span> = exp</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cb</span> = cb</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = <span class="variable language_">this</span>.<span class="title function_">get</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Watcher</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">    <span class="title function_">update</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> value = <span class="variable language_">this</span>.<span class="property">vm</span>.<span class="property">$data</span>[<span class="variable language_">this</span>.<span class="property">exp</span>]</span><br><span class="line">        <span class="keyword">const</span> oldValue = <span class="variable language_">this</span>.<span class="property">value</span></span><br><span class="line">        <span class="keyword">if</span> (value !== oldValue) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">value</span> = value</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">cb</span>(value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title class_">Dep</span>.<span class="property">target</span> = <span class="variable language_">this</span></span><br><span class="line">        <span class="keyword">const</span> value = <span class="variable language_">this</span>.<span class="property">vm</span>.<span class="property">$data</span>[<span class="variable language_">this</span>.<span class="property">exp</span>]</span><br><span class="line">        <span class="title class_">Dep</span>.<span class="property">target</span> = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现一个解析器-Compile"><a href="#实现一个解析器-Compile" class="headerlink" title="实现一个解析器 Compile"></a>实现一个解析器 Compile</h2><p><strong>解析器 Compile</strong> 的作用主要有两个方面：</p><ol><li>解析 DOM 节点，识别出模板指令，替换模板数据</li><li>对模板指令的节点添加订阅者，绑定更新函数</li></ol><p>为实现这两点功能，我们有如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Compile</span>(<span class="params">vm</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">vm</span> = vm</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">el</span> = vm.<span class="property">$el</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">fragment</span> = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">init</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Compile</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">    <span class="title function_">init</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">fragment</span> = <span class="variable language_">this</span>.<span class="title function_">nodeToFragment</span>(<span class="variable language_">this</span>.<span class="property">el</span>)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">compileNode</span>(<span class="variable language_">this</span>.<span class="property">fragment</span>)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">el</span>.<span class="title function_">appendChild</span>(<span class="variable language_">this</span>.<span class="property">fragment</span>)</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="title function_">nodeToFragment</span>(<span class="params">el</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> fragment = <span class="variable language_">document</span>.<span class="title function_">createDocumentFragment</span>()</span><br><span class="line">        <span class="keyword">let</span> child = el.<span class="property">firstChild</span></span><br><span class="line">        <span class="keyword">while</span> (child) &#123;</span><br><span class="line">            fragment.<span class="title function_">appendChild</span>(child)</span><br><span class="line">            child = el.<span class="property">firstChild</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fragment</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">compileNode</span>(<span class="params">fragment</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> childNodes = fragment.<span class="property">childNodes</span></span><br><span class="line">        <span class="keyword">const</span> childNodesArray = [...childNodes]</span><br><span class="line">        childNodesArray.<span class="title function_">forEach</span>(<span class="function"><span class="params">node</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">isElementNode</span>(node)) &#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="title function_">compile</span>(node)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> reg = <span class="regexp">/\&#123;\&#123;(.*)\&#125;\&#125;/</span></span><br><span class="line">            <span class="keyword">let</span> text = node.<span class="property">textContent</span></span><br><span class="line">            <span class="keyword">if</span> (reg.<span class="title function_">test</span>(text)) &#123;</span><br><span class="line">                <span class="keyword">let</span> prop = reg.<span class="title function_">exec</span>(text)[<span class="number">1</span>]</span><br><span class="line">                <span class="variable language_">this</span>.<span class="title function_">compileText</span>(node, prop)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (node.<span class="property">childNodes</span> &amp;&amp; node.<span class="property">childNodes</span>.<span class="property">length</span>) &#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="title function_">compileNode</span>(node)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">compile</span>(<span class="params">node</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> nodeAttrs = node.<span class="property">attributes</span></span><br><span class="line">        <span class="keyword">const</span> nodeAttrsArray = [...nodeAttrs]</span><br><span class="line">        nodeAttrsArray.<span class="title function_">forEach</span>(<span class="function"><span class="params">attr</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> name = attr.<span class="property">name</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">isDirective</span>(name)) &#123;</span><br><span class="line">                <span class="keyword">let</span> value = attr.<span class="property">value</span></span><br><span class="line">                <span class="keyword">if</span> (name === <span class="string">&#x27;v-model&#x27;</span>) &#123;</span><br><span class="line">                    <span class="variable language_">this</span>.<span class="title function_">compileModel</span>(node, value)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">compileModel</span>(<span class="params">node, prop</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> val = <span class="variable language_">this</span>.<span class="property">vm</span>.<span class="property">$data</span>[prop]</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">updateModel</span>(node, val)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Watcher</span>(<span class="variable language_">this</span>.<span class="property">vm</span>, prop, <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">updateModel</span>(node, value)</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        node.<span class="title function_">addEventListener</span>(<span class="string">&#x27;input&#x27;</span>, <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> newValue = event.<span class="property">target</span>.<span class="property">value</span></span><br><span class="line">            <span class="keyword">if</span> (val === newValue) &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">vm</span>.<span class="property">$data</span>[prop] = newValue</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">compileText</span>(<span class="params">node, prop</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> text = <span class="variable language_">this</span>.<span class="property">vm</span>.<span class="property">$data</span>[prop]</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">updateView</span>(node, text)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Watcher</span>(<span class="variable language_">this</span>.<span class="property">vm</span>, prop, <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">updateView</span>(node, value)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="title function_">updateModel</span>(<span class="params">node, value</span>) &#123;</span><br><span class="line">        node.<span class="property">value</span> = <span class="keyword">typeof</span> value === <span class="string">&#x27;undefined&#x27;</span> ? <span class="string">&#x27;&#x27;</span> : value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">updateView</span>(<span class="params">node, value</span>) &#123;</span><br><span class="line">        node.<span class="property">textContent</span> = <span class="keyword">typeof</span> value === <span class="string">&#x27;undefined&#x27;</span> ? <span class="string">&#x27;&#x27;</span> : value</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="title function_">isDirective</span>(<span class="params">attr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> attr.<span class="title function_">indexOf</span>(<span class="string">&#x27;v-&#x27;</span>) !== -<span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">isElementNode</span>(<span class="params">node</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> node.<span class="property">nodeType</span> === <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">isTextNode</span>(<span class="params">node</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> node.<span class="property">nodeType</span> === <span class="number">3</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段较长的代码，其核心目的就是实现上面说的 2 点功能。</p><p>其中，在解析 DOM 过程中，因为会频繁操作 DOM，所以这里先将其缓存到一个 fragment 中，然后再进行解析，解析编译完成后，再把 fragment 添加到页面中。</p><p>这里我们只是简单的实现了差值表达式 <code>&#123;&#123;&#125;&#125;</code> 和 <code>v-model</code> 的识别。</p><h2 id="创建-MyVue"><a href="#创建-MyVue" class="headerlink" title="创建 MyVue"></a>创建 MyVue</h2><p>这里我们创建一个 MyVue 类，来连接 Observer、Watcher、Compile。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">MyVue</span>(<span class="params">options</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$el</span> = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(options.<span class="property">el</span>)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$data</span> = options.<span class="property">data</span></span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">init</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">MyVue</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">    <span class="title function_">init</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">proxyData</span>(<span class="variable language_">this</span>)</span><br><span class="line">        <span class="title function_">observe</span>(<span class="variable language_">this</span>.<span class="property">$data</span>)</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Compile</span>(<span class="variable language_">this</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">proxyData</span>(<span class="params">vm</span>) &#123;</span><br><span class="line">        <span class="title class_">Object</span>.<span class="title function_">keys</span>(vm.<span class="property">$data</span>).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(vm, key, &#123;</span><br><span class="line">                <span class="attr">get</span>: <span class="keyword">function</span> <span class="title function_">proxyGetter</span>(<span class="params"></span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> vm.<span class="property">$data</span>[key]</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">set</span>: <span class="keyword">function</span> <span class="title function_">proxySetter</span>(<span class="params">value</span>) &#123;</span><br><span class="line">                    vm.<span class="property">$data</span>[key] = value</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用-MyVue-替换-Vue"><a href="#使用-MyVue-替换-Vue" class="headerlink" title="使用 MyVue 替换 Vue"></a>使用 MyVue 替换 Vue</h2><p>现在，我们使用 MyVue 来替换 Vue 接管我们的视图。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&#x27;name&#x27;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- &lt;script src=&quot;vender/vue.js&quot;&gt;&lt;/script&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/observer.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/watcher.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/compile.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/index.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// let app = new Vue(&#123;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//     el: &#x27;#app&#x27;,</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//     data: &#123;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//         name: &#x27;JavaScript&#x27;,</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//     &#125;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// &#125;)</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// console.log(app)</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> myApp = <span class="keyword">new</span> <span class="title class_">MyVue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">name</span>: <span class="string">&#x27;JavaScript&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(myApp)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/posts/20210306094502/MyVue%E6%BC%94%E7%A4%BA.gif" class="lazyload" data-srcset="/posts/20210306094502/MyVue%E6%BC%94%E7%A4%BA.gif" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="MyVue演示"></p><p>到这里，我们便实现了一个简单的数据双向绑定。</p><h2 id="完整源码"><a href="#完整源码" class="headerlink" title="完整源码"></a>完整源码</h2><p>完整源码请点击 <a href="https://github.com/liangpengyv/vue-mvvm">👆GitHub-vue-mvvm</a> 查看</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Vue-数据双向绑定原理&quot;&gt;&lt;a href=&quot;#Vue-数据双向绑定原理&quot; class=&quot;headerlink&quot; title=&quot;Vue 数据双向绑定原理&quot;&gt;&lt;/a&gt;Vue 数据双向绑定原理&lt;/h2&gt;&lt;p&gt;Vue 数据双向绑定是通过 &lt;strong&gt;数据劫持&lt;/st</summary>
      
    
    
    
    <category term="未分类" scheme="https://www.laoliang.ink/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
    
    <category term="无标签" scheme="https://www.laoliang.ink/tags/%E6%97%A0%E6%A0%87%E7%AD%BE/"/>
    
  </entry>
  
</feed>
